<!DOCTYPE html>

<html lang="en">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Anime_Recommender</title><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<style type="text/css">
    pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: var(--jp-cell-editor-active-background) }
.highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) }
.highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */
.highlight .err { color: var(--jp-mirror-editor-error-color) } /* Error */
.highlight .k { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword */
.highlight .o { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator */
.highlight .p { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation */
.highlight .ch { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Multiline */
.highlight .cp { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Single */
.highlight .cs { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Special */
.highlight .kc { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Type */
.highlight .m { color: var(--jp-mirror-editor-number-color) } /* Literal.Number */
.highlight .s { color: var(--jp-mirror-editor-string-color) } /* Literal.String */
.highlight .ow { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator.Word */
.highlight .pm { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation.Marker */
.highlight .w { color: var(--jp-mirror-editor-variable-color) } /* Text.Whitespace */
.highlight .mb { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Bin */
.highlight .mf { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Float */
.highlight .mh { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Hex */
.highlight .mi { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer */
.highlight .mo { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Oct */
.highlight .sa { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Affix */
.highlight .sb { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Backtick */
.highlight .sc { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Char */
.highlight .dl { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Delimiter */
.highlight .sd { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Doc */
.highlight .s2 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Double */
.highlight .se { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Escape */
.highlight .sh { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Heredoc */
.highlight .si { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Interpol */
.highlight .sx { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Other */
.highlight .sr { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Regex */
.highlight .s1 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Single */
.highlight .ss { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Symbol */
.highlight .il { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer.Long */
  </style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
 * Mozilla scrollbar styling
 */

/* use standard opaque scrollbars for most nodes */
[data-jp-theme-scrollbars='true'] {
  scrollbar-color: rgb(var(--jp-scrollbar-thumb-color))
    var(--jp-scrollbar-background-color);
}

/* for code nodes, use a transparent style of scrollbar. These selectors
 * will match lower in the tree, and so will override the above */
[data-jp-theme-scrollbars='true'] .CodeMirror-hscrollbar,
[data-jp-theme-scrollbars='true'] .CodeMirror-vscrollbar {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
}

/* tiny scrollbar */

.jp-scrollbar-tiny {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
  scrollbar-width: thin;
}

/* tiny scrollbar */

.jp-scrollbar-tiny::-webkit-scrollbar,
.jp-scrollbar-tiny::-webkit-scrollbar-corner {
  background-color: transparent;
  height: 4px;
  width: 4px;
}

.jp-scrollbar-tiny::-webkit-scrollbar-thumb {
  background: rgba(var(--jp-scrollbar-thumb-color), 0.5);
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:horizontal {
  border-left: 0 solid transparent;
  border-right: 0 solid transparent;
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:vertical {
  border-top: 0 solid transparent;
  border-bottom: 0 solid transparent;
}

/*
 * Lumino
 */

.lm-ScrollBar[data-orientation='horizontal'] {
  min-height: 16px;
  max-height: 16px;
  min-width: 45px;
  border-top: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] {
  min-width: 16px;
  max-width: 16px;
  min-height: 45px;
  border-left: 1px solid #a0a0a0;
}

.lm-ScrollBar-button {
  background-color: #f0f0f0;
  background-position: center center;
  min-height: 15px;
  max-height: 15px;
  min-width: 15px;
  max-width: 15px;
}

.lm-ScrollBar-button:hover {
  background-color: #dadada;
}

.lm-ScrollBar-button.lm-mod-active {
  background-color: #cdcdcd;
}

.lm-ScrollBar-track {
  background: #f0f0f0;
}

.lm-ScrollBar-thumb {
  background: #cdcdcd;
}

.lm-ScrollBar-thumb:hover {
  background: #bababa;
}

.lm-ScrollBar-thumb.lm-mod-active {
  background: #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal'] .lm-ScrollBar-thumb {
  height: 100%;
  min-width: 15px;
  border-left: 1px solid #a0a0a0;
  border-right: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] .lm-ScrollBar-thumb {
  width: 100%;
  min-height: 15px;
  border-top: 1px solid #a0a0a0;
  border-bottom: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-left);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-right);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-up);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-down);
  background-size: 17px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Widget {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
}

.lm-Widget.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.lm-AccordionPanel[data-orientation='horizontal'] > .lm-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  display: flex;
  flex-direction: column;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-CommandPalette-search {
  flex: 0 0 auto;
}

.lm-CommandPalette-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  min-height: 0;
  overflow: auto;
  list-style-type: none;
}

.lm-CommandPalette-header {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-CommandPalette-item {
  display: flex;
  flex-direction: row;
}

.lm-CommandPalette-itemIcon {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemContent {
  flex: 1 1 auto;
  overflow: hidden;
}

.lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemLabel {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-close-icon {
  border: 1px solid transparent;
  background-color: transparent;
  position: absolute;
  z-index: 1;
  right: 3%;
  top: 0;
  bottom: 0;
  margin: auto;
  padding: 7px 0;
  display: none;
  vertical-align: middle;
  outline: 0;
  cursor: pointer;
}
.lm-close-icon:after {
  content: 'X';
  display: block;
  width: 15px;
  height: 15px;
  text-align: center;
  color: #000;
  font-weight: normal;
  font-size: 12px;
  cursor: pointer;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-DockPanel {
  z-index: 0;
}

.lm-DockPanel-widget {
  z-index: 0;
}

.lm-DockPanel-tabBar {
  z-index: 1;
}

.lm-DockPanel-handle {
  z-index: 2;
}

.lm-DockPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-DockPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-DockPanel-handle[data-orientation='horizontal'] {
  cursor: ew-resize;
}

.lm-DockPanel-handle[data-orientation='vertical'] {
  cursor: ns-resize;
}

.lm-DockPanel-handle[data-orientation='horizontal']:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-DockPanel-handle[data-orientation='vertical']:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

.lm-DockPanel-overlay {
  z-index: 3;
  box-sizing: border-box;
  pointer-events: none;
}

.lm-DockPanel-overlay.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Menu {
  z-index: 10000;
  position: absolute;
  white-space: nowrap;
  overflow-x: hidden;
  overflow-y: auto;
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-Menu-content {
  margin: 0;
  padding: 0;
  display: table;
  list-style-type: none;
}

.lm-Menu-item {
  display: table-row;
}

.lm-Menu-item.lm-mod-hidden,
.lm-Menu-item.lm-mod-collapsed {
  display: none !important;
}

.lm-Menu-itemIcon,
.lm-Menu-itemSubmenuIcon {
  display: table-cell;
  text-align: center;
}

.lm-Menu-itemLabel {
  display: table-cell;
  text-align: left;
}

.lm-Menu-itemShortcut {
  display: table-cell;
  text-align: right;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-MenuBar {
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-MenuBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: row;
  list-style-type: none;
}

.lm-MenuBar-item {
  box-sizing: border-box;
}

.lm-MenuBar-itemIcon,
.lm-MenuBar-itemLabel {
  display: inline-block;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-ScrollBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-ScrollBar[data-orientation='horizontal'] {
  flex-direction: row;
}

.lm-ScrollBar[data-orientation='vertical'] {
  flex-direction: column;
}

.lm-ScrollBar-button {
  box-sizing: border-box;
  flex: 0 0 auto;
}

.lm-ScrollBar-track {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  flex: 1 1 auto;
}

.lm-ScrollBar-thumb {
  box-sizing: border-box;
  position: absolute;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-SplitPanel-child {
  z-index: 0;
}

.lm-SplitPanel-handle {
  z-index: 1;
}

.lm-SplitPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-SplitPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle {
  cursor: ew-resize;
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle {
  cursor: ns-resize;
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-TabBar[data-orientation='horizontal'] {
  flex-direction: row;
  align-items: flex-end;
}

.lm-TabBar[data-orientation='vertical'] {
  flex-direction: column;
  align-items: flex-end;
}

.lm-TabBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex: 1 1 auto;
  list-style-type: none;
}

.lm-TabBar[data-orientation='horizontal'] > .lm-TabBar-content {
  flex-direction: row;
}

.lm-TabBar[data-orientation='vertical'] > .lm-TabBar-content {
  flex-direction: column;
}

.lm-TabBar-tab {
  display: flex;
  flex-direction: row;
  box-sizing: border-box;
  overflow: hidden;
  touch-action: none; /* Disable native Drag/Drop */
}

.lm-TabBar-tabIcon,
.lm-TabBar-tabCloseIcon {
  flex: 0 0 auto;
}

.lm-TabBar-tabLabel {
  flex: 1 1 auto;
  overflow: hidden;
  white-space: nowrap;
}

.lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
}

.lm-TabBar-tab.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar-addButton.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab {
  position: relative;
}

.lm-TabBar.lm-mod-dragging[data-orientation='horizontal'] .lm-TabBar-tab {
  left: 0;
  transition: left 150ms ease;
}

.lm-TabBar.lm-mod-dragging[data-orientation='vertical'] .lm-TabBar-tab {
  top: 0;
  transition: top 150ms ease;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab.lm-mod-dragging {
  transition: none;
}

.lm-TabBar-tabLabel .lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
  background: inherit;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabPanel-tabBar {
  z-index: 1;
}

.lm-TabPanel-stackedPanel {
  z-index: 0;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapse {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

.jp-Collapse-header {
  padding: 1px 12px;
  background-color: var(--jp-layout-color1);
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  align-items: center;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  text-transform: uppercase;
  user-select: none;
}

.jp-Collapser-icon {
  height: 16px;
}

.jp-Collapse-header-collapsed .jp-Collapser-icon {
  transform: rotate(-90deg);
  margin: auto 0;
}

.jp-Collapser-title {
  line-height: 25px;
}

.jp-Collapse-contents {
  padding: 0 12px;
  background-color: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* This file was auto-generated by ensureUiComponents() in @jupyterlab/buildutils */

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

/* Icons urls */

:root {
  --jp-icon-add-above: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5MikiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik00Ljc1IDQuOTMwNjZINi42MjVWNi44MDU2NkM2LjYyNSA3LjAxMTkxIDYuNzkzNzUgNy4xODA2NiA3IDcuMTgwNjZDNy4yMDYyNSA3LjE4MDY2IDcuMzc1IDcuMDExOTEgNy4zNzUgNi44MDU2NlY0LjkzMDY2SDkuMjVDOS40NTYyNSA0LjkzMDY2IDkuNjI1IDQuNzYxOTEgOS42MjUgNC41NTU2NkM5LjYyNSA0LjM0OTQxIDkuNDU2MjUgNC4xODA2NiA5LjI1IDQuMTgwNjZINy4zNzVWMi4zMDU2NkM3LjM3NSAyLjA5OTQxIDcuMjA2MjUgMS45MzA2NiA3IDEuOTMwNjZDNi43OTM3NSAxLjkzMDY2IDYuNjI1IDIuMDk5NDEgNi42MjUgMi4zMDU2NlY0LjE4MDY2SDQuNzVDNC41NDM3NSA0LjE4MDY2IDQuMzc1IDQuMzQ5NDEgNC4zNzUgNC41NTU2NkM0LjM3NSA0Ljc2MTkxIDQuNTQzNzUgNC45MzA2NiA0Ljc1IDQuOTMwNjZaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC43Ii8+CjwvZz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjUgOS41VjExLjVMMi41IDExLjVWOS41TDExLjUgOS41Wk0xMiA4QzEyLjU1MjMgOCAxMyA4LjQ0NzcyIDEzIDlWMTJDMTMgMTIuNTUyMyAxMi41NTIzIDEzIDEyIDEzTDIgMTNDMS40NDc3MiAxMyAxIDEyLjU1MjMgMSAxMlY5QzEgOC40NDc3MiAxLjQ0NzcxIDggMiA4TDEyIDhaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5MiI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDAgMCAxIDEwIDEuNTU1NjYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==);
  --jp-icon-add-below: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5OCkiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik05LjI1IDEwLjA2OTNMNy4zNzUgMTAuMDY5M0w3LjM3NSA4LjE5NDM0QzcuMzc1IDcuOTg4MDkgNy4yMDYyNSA3LjgxOTM0IDcgNy44MTkzNEM2Ljc5Mzc1IDcuODE5MzQgNi42MjUgNy45ODgwOSA2LjYyNSA4LjE5NDM0TDYuNjI1IDEwLjA2OTNMNC43NSAxMC4wNjkzQzQuNTQzNzUgMTAuMDY5MyA0LjM3NSAxMC4yMzgxIDQuMzc1IDEwLjQ0NDNDNC4zNzUgMTAuNjUwNiA0LjU0Mzc1IDEwLjgxOTMgNC43NSAxMC44MTkzTDYuNjI1IDEwLjgxOTNMNi42MjUgMTIuNjk0M0M2LjYyNSAxMi45MDA2IDYuNzkzNzUgMTMuMDY5MyA3IDEzLjA2OTNDNy4yMDYyNSAxMy4wNjkzIDcuMzc1IDEyLjkwMDYgNy4zNzUgMTIuNjk0M0w3LjM3NSAxMC44MTkzTDkuMjUgMTAuODE5M0M5LjQ1NjI1IDEwLjgxOTMgOS42MjUgMTAuNjUwNiA5LjYyNSAxMC40NDQzQzkuNjI1IDEwLjIzODEgOS40NTYyNSAxMC4wNjkzIDkuMjUgMTAuMDY5M1oiIGZpbGw9IiM2MTYxNjEiIHN0cm9rZT0iIzYxNjE2MSIgc3Ryb2tlLXdpZHRoPSIwLjciLz4KPC9nPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMi41IDUuNUwyLjUgMy41TDExLjUgMy41TDExLjUgNS41TDIuNSA1LjVaTTIgN0MxLjQ0NzcyIDcgMSA2LjU1MjI4IDEgNkwxIDNDMSAyLjQ0NzcyIDEuNDQ3NzIgMiAyIDJMMTIgMkMxMi41NTIzIDIgMTMgMi40NDc3MiAxMyAzTDEzIDZDMTMgNi41NTIyOSAxMi41NTIzIDcgMTIgN0wyIDdaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5OCI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMS43NDg0NmUtMDcgMS43NDg0NmUtMDcgLTEgNCAxMy40NDQzKSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=);
  --jp-icon-add: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bell: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiPgogICA8cGF0aCBjbGFzcz0ianAtaWNvbjIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzMzMzMzIgogICAgICBkPSJtOCAwLjI5Yy0xLjQgMC0yLjcgMC43My0zLjYgMS44LTEuMiAxLjUtMS40IDMuNC0xLjUgNS4yLTAuMTggMi4yLTAuNDQgNC0yLjMgNS4zbDAuMjggMS4zaDVjMC4wMjYgMC42NiAwLjMyIDEuMSAwLjcxIDEuNSAwLjg0IDAuNjEgMiAwLjYxIDIuOCAwIDAuNTItMC40IDAuNi0xIDAuNzEtMS41aDVsMC4yOC0xLjNjLTEuOS0wLjk3LTIuMi0zLjMtMi4zLTUuMy0wLjEzLTEuOC0wLjI2LTMuNy0xLjUtNS4yLTAuODUtMS0yLjItMS44LTMuNi0xLjh6bTAgMS40YzAuODggMCAxLjkgMC41NSAyLjUgMS4zIDAuODggMS4xIDEuMSAyLjcgMS4yIDQuNCAwLjEzIDEuNyAwLjIzIDMuNiAxLjMgNS4yaC0xMGMxLjEtMS42IDEuMi0zLjQgMS4zLTUuMiAwLjEzLTEuNyAwLjMtMy4zIDEuMi00LjQgMC41OS0wLjcyIDEuNi0xLjMgMi41LTEuM3ptLTAuNzQgMTJoMS41Yy0wLjAwMTUgMC4yOCAwLjAxNSAwLjc5LTAuNzQgMC43OS0wLjczIDAuMDAxNi0wLjcyLTAuNTMtMC43NC0wLjc5eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-bug-dot: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiPgogICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuMTkgOEgyMFYxMEgxNy45MUMxNy45NiAxMC4zMyAxOCAxMC42NiAxOCAxMVYxMkgyMFYxNEgxOC41SDE4VjE0LjAyNzVDMTUuNzUgMTQuMjc2MiAxNCAxNi4xODM3IDE0IDE4LjVDMTQgMTkuMjA4IDE0LjE2MzUgMTkuODc3OSAxNC40NTQ5IDIwLjQ3MzlDMTMuNzA2MyAyMC44MTE3IDEyLjg3NTcgMjEgMTIgMjFDOS43OCAyMSA3Ljg1IDE5Ljc5IDYuODEgMThINFYxNkg2LjA5QzYuMDQgMTUuNjcgNiAxNS4zNCA2IDE1VjE0SDRWMTJINlYxMUM2IDEwLjY2IDYuMDQgMTAuMzMgNi4wOSAxMEg0VjhINi44MUM3LjI2IDcuMjIgNy44OCA2LjU1IDguNjIgNi4wNEw3IDQuNDFMOC40MSAzTDEwLjU5IDUuMTdDMTEuMDQgNS4wNiAxMS41MSA1IDEyIDVDMTIuNDkgNSAxMi45NiA1LjA2IDEzLjQyIDUuMTdMMTUuNTkgM0wxNyA0LjQxTDE1LjM3IDYuMDRDMTYuMTIgNi41NSAxNi43NCA3LjIyIDE3LjE5IDhaTTEwIDE2SDE0VjE0SDEwVjE2Wk0xMCAxMkgxNFYxMEgxMFYxMloiIGZpbGw9IiM2MTYxNjEiLz4KICAgICAgICA8cGF0aCBkPSJNMjIgMTguNUMyMiAyMC40MzMgMjAuNDMzIDIyIDE4LjUgMjJDMTYuNTY3IDIyIDE1IDIwLjQzMyAxNSAxOC41QzE1IDE2LjU2NyAxNi41NjcgMTUgMTguNSAxNUMyMC40MzMgMTUgMjIgMTYuNTY3IDIyIDE4LjVaIiBmaWxsPSIjNjE2MTYxIi8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bug: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yMCA4aC0yLjgxYy0uNDUtLjc4LTEuMDctMS40NS0xLjgyLTEuOTZMMTcgNC40MSAxNS41OSAzbC0yLjE3IDIuMTdDMTIuOTYgNS4wNiAxMi40OSA1IDEyIDVjLS40OSAwLS45Ni4wNi0xLjQxLjE3TDguNDEgMyA3IDQuNDFsMS42MiAxLjYzQzcuODggNi41NSA3LjI2IDcuMjIgNi44MSA4SDR2MmgyLjA5Yy0uMDUuMzMtLjA5LjY2LS4wOSAxdjFINHYyaDJ2MWMwIC4zNC4wNC42Ny4wOSAxSDR2MmgyLjgxYzEuMDQgMS43OSAyLjk3IDMgNS4xOSAzczQuMTUtMS4yMSA1LjE5LTNIMjB2LTJoLTIuMDljLjA1LS4zMy4wOS0uNjYuMDktMXYtMWgydi0yaC0ydi0xYzAtLjM0LS4wNC0uNjctLjA5LTFIMjBWOHptLTYgOGgtNHYtMmg0djJ6bTAtNGgtNHYtMmg0djJ6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-build: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE0LjkgMTcuNDVDMTYuMjUgMTcuNDUgMTcuMzUgMTYuMzUgMTcuMzUgMTVDMTcuMzUgMTMuNjUgMTYuMjUgMTIuNTUgMTQuOSAxMi41NUMxMy41NCAxMi41NSAxMi40NSAxMy42NSAxMi40NSAxNUMxMi40NSAxNi4zNSAxMy41NCAxNy40NSAxNC45IDE3LjQ1Wk0yMC4xIDE1LjY4TDIxLjU4IDE2Ljg0QzIxLjcxIDE2Ljk1IDIxLjc1IDE3LjEzIDIxLjY2IDE3LjI5TDIwLjI2IDE5LjcxQzIwLjE3IDE5Ljg2IDIwIDE5LjkyIDE5LjgzIDE5Ljg2TDE4LjA5IDE5LjE2QzE3LjczIDE5LjQ0IDE3LjMzIDE5LjY3IDE2LjkxIDE5Ljg1TDE2LjY0IDIxLjdDMTYuNjIgMjEuODcgMTYuNDcgMjIgMTYuMyAyMkgxMy41QzEzLjMyIDIyIDEzLjE4IDIxLjg3IDEzLjE1IDIxLjdMMTIuODkgMTkuODVDMTIuNDYgMTkuNjcgMTIuMDcgMTkuNDQgMTEuNzEgMTkuMTZMOS45NjAwMiAxOS44NkM5LjgxMDAyIDE5LjkyIDkuNjIwMDIgMTkuODYgOS41NDAwMiAxOS43MUw4LjE0MDAyIDE3LjI5QzguMDUwMDIgMTcuMTMgOC4wOTAwMiAxNi45NSA4LjIyMDAyIDE2Ljg0TDkuNzAwMDIgMTUuNjhMOS42NTAwMSAxNUw5LjcwMDAyIDE0LjMxTDguMjIwMDIgMTMuMTZDOC4wOTAwMiAxMy4wNSA4LjA1MDAyIDEyLjg2IDguMTQwMDIgMTIuNzFMOS41NDAwMiAxMC4yOUM5LjYyMDAyIDEwLjEzIDkuODEwMDIgMTAuMDcgOS45NjAwMiAxMC4xM0wxMS43MSAxMC44NEMxMi4wNyAxMC41NiAxMi40NiAxMC4zMiAxMi44OSAxMC4xNUwxMy4xNSA4LjI4OTk4QzEzLjE4IDguMTI5OTggMTMuMzIgNy45OTk5OCAxMy41IDcuOTk5OThIMTYuM0MxNi40NyA3Ljk5OTk4IDE2LjYyIDguMTI5OTggMTYuNjQgOC4yODk5OEwxNi45MSAxMC4xNUMxNy4zMyAxMC4zMiAxNy43MyAxMC41NiAxOC4wOSAxMC44NEwxOS44MyAxMC4xM0MyMCAxMC4wNyAyMC4xNyAxMC4xMyAyMC4yNiAxMC4yOUwyMS42NiAxMi43MUMyMS43NSAxMi44NiAyMS43MSAxMy4wNSAyMS41OCAxMy4xNkwyMC4xIDE0LjMxTDIwLjE1IDE1TDIwLjEgMTUuNjhaIi8+CiAgICA8cGF0aCBkPSJNNy4zMjk2NiA3LjQ0NDU0QzguMDgzMSA3LjAwOTU0IDguMzM5MzIgNi4wNTMzMiA3LjkwNDMyIDUuMjk5ODhDNy40NjkzMiA0LjU0NjQzIDYuNTA4MSA0LjI4MTU2IDUuNzU0NjYgNC43MTY1NkM1LjM5MTc2IDQuOTI2MDggNS4xMjY5NSA1LjI3MTE4IDUuMDE4NDkgNS42NzU5NEM0LjkxMDA0IDYuMDgwNzEgNC45NjY4MiA2LjUxMTk4IDUuMTc2MzQgNi44NzQ4OEM1LjYxMTM0IDcuNjI4MzIgNi41NzYyMiA3Ljg3OTU0IDcuMzI5NjYgNy40NDQ1NFpNOS42NTcxOCA0Ljc5NTkzTDEwLjg2NzIgNC45NTE3OUMxMC45NjI4IDQuOTc3NDEgMTEuMDQwMiA1LjA3MTMzIDExLjAzODIgNS4xODc5M0wxMS4wMzg4IDYuOTg4OTNDMTEuMDQ1NSA3LjEwMDU0IDEwLjk2MTYgNy4xOTUxOCAxMC44NTUgNy4yMTA1NEw5LjY2MDAxIDcuMzgwODNMOS4yMzkxNSA4LjEzMTg4TDkuNjY5NjEgOS4yNTc0NUM5LjcwNzI5IDkuMzYyNzEgOS42NjkzNCA5LjQ3Njk5IDkuNTc0MDggOS41MzE5OUw4LjAxNTIzIDEwLjQzMkM3LjkxMTMxIDEwLjQ5MiA3Ljc5MzM3IDEwLjQ2NzcgNy43MjEwNSAxMC4zODI0TDYuOTg3NDggOS40MzE4OEw2LjEwOTMxIDkuNDMwODNMNS4zNDcwNCAxMC4zOTA1QzUuMjg5MDkgMTAuNDcwMiA1LjE3MzgzIDEwLjQ5MDUgNS4wNzE4NyAxMC40MzM5TDMuNTEyNDUgOS41MzI5M0MzLjQxMDQ5IDkuNDc2MzMgMy4zNzY0NyA5LjM1NzQxIDMuNDEwNzUgOS4yNTY3OUwzLjg2MzQ3IDguMTQwOTNMMy42MTc0OSA3Ljc3NDg4TDMuNDIzNDcgNy4zNzg4M0wyLjIzMDc1IDcuMjEyOTdDMi4xMjY0NyA3LjE5MjM1IDIuMDQwNDkgNy4xMDM0MiAyLjA0MjQ1IDYuOTg2ODJMMi4wNDE4NyA1LjE4NTgyQzIuMDQzODMgNS4wNjkyMiAyLjExOTA5IDQuOTc5NTggMi4yMTcwNCA0Ljk2OTIyTDMuNDIwNjUgNC43OTM5M0wzLjg2NzQ5IDQuMDI3ODhMMy40MTEwNSAyLjkxNzMxQzMuMzczMzcgMi44MTIwNCAzLjQxMTMxIDIuNjk3NzYgMy41MTUyMyAyLjYzNzc2TDUuMDc0MDggMS43Mzc3NkM1LjE2OTM0IDEuNjgyNzYgNS4yODcyOSAxLjcwNzA0IDUuMzU5NjEgMS43OTIzMUw2LjExOTE1IDIuNzI3ODhMNi45ODAwMSAyLjczODkzTDcuNzI0OTYgMS43ODkyMkM3Ljc5MTU2IDEuNzA0NTggNy45MTU0OCAxLjY3OTIyIDguMDA4NzkgMS43NDA4Mkw5LjU2ODIxIDIuNjQxODJDOS42NzAxNyAyLjY5ODQyIDkuNzEyODUgMi44MTIzNCA5LjY4NzIzIDIuOTA3OTdMOS4yMTcxOCA0LjAzMzgzTDkuNDYzMTYgNC4zOTk4OEw5LjY1NzE4IDQuNzk1OTNaIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iOS45LDEzLjYgMy42LDcuNCA0LjQsNi42IDkuOSwxMi4yIDE1LjQsNi43IDE2LjEsNy40ICIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNS45TDksOS43bDMuOC0zLjhsMS4yLDEuMmwtNC45LDVsLTQuOS01TDUuMiw1Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNy41TDksMTEuMmwzLjgtMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-left: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik0xMC44LDEyLjhMNy4xLDlsMy44LTMuOGwwLDcuNkgxMC44eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-right: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik03LjIsNS4yTDEwLjksOWwtMy44LDMuOFY1LjJINy4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-up-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMTUuNCwxMy4zIDkuOSw3LjcgNC40LDEzLjIgMy42LDEyLjUgOS45LDYuMyAxNi4xLDEyLjYgIi8+Cgk8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-up: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik01LjIsMTAuNUw5LDYuOGwzLjgsMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-case-sensitive: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWFjY2VudDIiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTcuNiw4aDAuOWwzLjUsOGgtMS4xTDEwLDE0SDZsLTAuOSwySDRMNy42LDh6IE04LDkuMUw2LjQsMTNoMy4yTDgsOS4xeiIvPgogICAgPHBhdGggZD0iTTE2LjYsOS44Yy0wLjIsMC4xLTAuNCwwLjEtMC43LDAuMWMtMC4yLDAtMC40LTAuMS0wLjYtMC4yYy0wLjEtMC4xLTAuMi0wLjQtMC4yLTAuNyBjLTAuMywwLjMtMC42LDAuNS0wLjksMC43Yy0wLjMsMC4xLTAuNywwLjItMS4xLDAuMmMtMC4zLDAtMC41LDAtMC43LTAuMWMtMC4yLTAuMS0wLjQtMC4yLTAuNi0wLjNjLTAuMi0wLjEtMC4zLTAuMy0wLjQtMC41IGMtMC4xLTAuMi0wLjEtMC40LTAuMS0wLjdjMC0wLjMsMC4xLTAuNiwwLjItMC44YzAuMS0wLjIsMC4zLTAuNCwwLjQtMC41QzEyLDcsMTIuMiw2LjksMTIuNSw2LjhjMC4yLTAuMSwwLjUtMC4xLDAuNy0wLjIgYzAuMy0wLjEsMC41LTAuMSwwLjctMC4xYzAuMiwwLDAuNC0wLjEsMC42LTAuMWMwLjIsMCwwLjMtMC4xLDAuNC0wLjJjMC4xLTAuMSwwLjItMC4yLDAuMi0wLjRjMC0xLTEuMS0xLTEuMy0xIGMtMC40LDAtMS40LDAtMS40LDEuMmgtMC45YzAtMC40LDAuMS0wLjcsMC4yLTFjMC4xLTAuMiwwLjMtMC40LDAuNS0wLjZjMC4yLTAuMiwwLjUtMC4zLDAuOC0wLjNDMTMuMyw0LDEzLjYsNCwxMy45LDQgYzAuMywwLDAuNSwwLDAuOCwwLjFjMC4zLDAsMC41LDAuMSwwLjcsMC4yYzAuMiwwLjEsMC40LDAuMywwLjUsMC41QzE2LDUsMTYsNS4yLDE2LDUuNnYyLjljMCwwLjIsMCwwLjQsMCwwLjUgYzAsMC4xLDAuMSwwLjIsMC4zLDAuMmMwLjEsMCwwLjIsMCwwLjMsMFY5Ljh6IE0xNS4yLDYuOWMtMS4yLDAuNi0zLjEsMC4yLTMuMSwxLjRjMCwxLjQsMy4xLDEsMy4xLTAuNVY2Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-circle-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDJDNi40NyAyIDIgNi40NyAyIDEyczQuNDcgMTAgMTAgMTAgMTAtNC40NyAxMC0xMFMxNy41MyAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-circle: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-clear: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8bWFzayBpZD0iZG9udXRIb2xlIj4KICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiIC8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSJibGFjayIvPgogIDwvbWFzaz4KCiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxyZWN0IGhlaWdodD0iMTgiIHdpZHRoPSIyIiB4PSIxMSIgeT0iMyIgdHJhbnNmb3JtPSJyb3RhdGUoMzE1LCAxMiwgMTIpIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgbWFzaz0idXJsKCNkb251dEhvbGUpIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-close: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1ub25lIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIGpwLWljb24zLWhvdmVyIiBmaWxsPSJub25lIj4KICAgIDxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjExIi8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIGpwLWljb24tYWNjZW50Mi1ob3ZlciIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiIvPgogIDwvZz4KCiAgPGcgY2xhc3M9ImpwLWljb24tbm9uZSBqcC1pY29uLWJ1c3kiIGZpbGw9Im5vbmUiPgogICAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICA8cGF0aCBkPSJNNi41OSwzLjQxTDIsOEw2LjU5LDEyLjZMOCwxMS4xOEw0LjgyLDhMOCw0LjgyTDYuNTksMy40MU0xMi40MSwzLjQxTDExLDQuODJMMTQuMTgsOEwxMSwxMS4xOEwxMi40MSwxMi42TDE3LDhMMTIuNDEsMy40MU0yMS41OSwxMS41OUwxMy41LDE5LjY4TDkuODMsMTZMOC40MiwxNy40MUwxMy41LDIyLjVMMjMsMTNMMjEuNTksMTEuNTlaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTExLjQgMTguNkw2LjggMTRMMTEuNCA5LjRMMTAgOEw0IDE0TDEwIDIwTDExLjQgMTguNlpNMTYuNiAxOC42TDIxLjIgMTRMMTYuNiA5LjRMMTggOEwyNCAxNEwxOCAyMEwxNi42IDE4LjZWMTguNloiLz4KCTwvZz4KPC9zdmc+Cg==);
  --jp-icon-collapse-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNNiAxM3YyaDh2LTJ6IiAvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-console: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwMCAyMDAiPgogIDxnIGNsYXNzPSJqcC1jb25zb2xlLWljb24tYmFja2dyb3VuZC1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMjg4RDEiPgogICAgPHBhdGggZD0iTTIwIDE5LjhoMTYwdjE1OS45SDIweiIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtY29uc29sZS1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIj4KICAgIDxwYXRoIGQ9Ik0xMDUgMTI3LjNoNDB2MTIuOGgtNDB6TTUxLjEgNzdMNzQgOTkuOWwtMjMuMyAyMy4zIDEwLjUgMTAuNSAyMy4zLTIzLjNMOTUgOTkuOSA4NC41IDg5LjQgNjEuNiA2Ni41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copy: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTExLjksMUgzLjJDMi40LDEsMS43LDEuNywxLjcsMi41djEwLjJoMS41VjIuNWg4LjdWMXogTTE0LjEsMy45aC04Yy0wLjgsMC0xLjUsMC43LTEuNSwxLjV2MTAuMmMwLDAuOCwwLjcsMS41LDEuNSwxLjVoOCBjMC44LDAsMS41LTAuNywxLjUtMS41VjUuNEMxNS41LDQuNiwxNC45LDMuOSwxNC4xLDMuOXogTTE0LjEsMTUuNWgtOFY1LjRoOFYxNS41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copyright: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCI+CiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0xMS44OCw5LjE0YzEuMjgsMC4wNiwxLjYxLDEuMTUsMS42MywxLjY2aDEuNzljLTAuMDgtMS45OC0xLjQ5LTMuMTktMy40NS0zLjE5QzkuNjQsNy42MSw4LDksOCwxMi4xNCBjMCwxLjk0LDAuOTMsNC4yNCwzLjg0LDQuMjRjMi4yMiwwLDMuNDEtMS42NSwzLjQ0LTIuOTVoLTEuNzljLTAuMDMsMC41OS0wLjQ1LDEuMzgtMS42MywxLjQ0QzEwLjU1LDE0LjgzLDEwLDEzLjgxLDEwLDEyLjE0IEMxMCw5LjI1LDExLjI4LDkuMTYsMTEuODgsOS4xNHogTTEyLDJDNi40OCwyLDIsNi40OCwyLDEyczQuNDgsMTAsMTAsMTBzMTAtNC40OCwxMC0xMFMxNy41MiwyLDEyLDJ6IE0xMiwyMGMtNC40MSwwLTgtMy41OS04LTggczMuNTktOCw4LThzOCwzLjU5LDgsOFMxNi40MSwyMCwxMiwyMHoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-cut: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkuNjQgNy42NGMuMjMtLjUuMzYtMS4wNS4zNi0xLjY0IDAtMi4yMS0xLjc5LTQtNC00UzIgMy43OSAyIDZzMS43OSA0IDQgNGMuNTkgMCAxLjE0LS4xMyAxLjY0LS4zNkwxMCAxMmwtMi4zNiAyLjM2QzcuMTQgMTQuMTMgNi41OSAxNCA2IDE0Yy0yLjIxIDAtNCAxLjc5LTQgNHMxLjc5IDQgNCA0IDQtMS43OSA0LTRjMC0uNTktLjEzLTEuMTQtLjM2LTEuNjRMMTIgMTRsNyA3aDN2LTFMOS42NCA3LjY0ek02IDhjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTAgMTJjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTYtNy41Yy0uMjggMC0uNS0uMjItLjUtLjVzLjIyLS41LjUtLjUuNS4yMi41LjUtLjIyLjUtLjUuNXpNMTkgM2wtNiA2IDIgMiA3LTdWM3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-delete: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIiAvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjI2MjYyIiBkPSJNNiAxOWMwIDEuMS45IDIgMiAyaDhjMS4xIDAgMi0uOSAyLTJWN0g2djEyek0xOSA0aC0zLjVsLTEtMWgtNWwtMSAxSDV2MmgxNFY0eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-download: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDloLTRWM0g5djZINWw3IDcgNy03ek01IDE4djJoMTR2LTJINXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-duplicate: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIuNzk5OTggMC44NzVIOC44OTU4MkM5LjIwMDYxIDAuODc1IDkuNDQ5OTggMS4xMzkxNCA5LjQ0OTk4IDEuNDYxOThDOS40NDk5OCAxLjc4NDgyIDkuMjAwNjEgMi4wNDg5NiA4Ljg5NTgyIDIuMDQ4OTZIMy4zNTQxNUMzLjA0OTM2IDIuMDQ4OTYgMi43OTk5OCAyLjMxMzEgMi43OTk5OCAyLjYzNTk0VjkuNjc5NjlDMi43OTk5OCAxMC4wMDI1IDIuNTUwNjEgMTAuMjY2NyAyLjI0NTgyIDEwLjI2NjdDMS45NDEwMyAxMC4yNjY3IDEuNjkxNjUgMTAuMDAyNSAxLjY5MTY1IDkuNjc5NjlWMi4wNDg5NkMxLjY5MTY1IDEuNDAzMjggMi4xOTA0IDAuODc1IDIuNzk5OTggMC44NzVaTTUuMzY2NjUgMTEuOVY0LjU1SDExLjA4MzNWMTEuOUg1LjM2NjY1Wk00LjE0MTY1IDQuMTQxNjdDNC4xNDE2NSAzLjY5MDYzIDQuNTA3MjggMy4zMjUgNC45NTgzMiAzLjMyNUgxMS40OTE3QzExLjk0MjcgMy4zMjUgMTIuMzA4MyAzLjY5MDYzIDEyLjMwODMgNC4xNDE2N1YxMi4zMDgzQzEyLjMwODMgMTIuNzU5NCAxMS45NDI3IDEzLjEyNSAxMS40OTE3IDEzLjEyNUg0Ljk1ODMyQzQuNTA3MjggMTMuMTI1IDQuMTQxNjUgMTIuNzU5NCA0LjE0MTY1IDEyLjMwODNWNC4xNDE2N1oiIGZpbGw9IiM2MTYxNjEiLz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNOS40MzU3NCA4LjI2NTA3SDguMzY0MzFWOS4zMzY1QzguMzY0MzEgOS40NTQzNSA4LjI2Nzg4IDkuNTUwNzggOC4xNTAwMiA5LjU1MDc4QzguMDMyMTcgOS41NTA3OCA3LjkzNTc0IDkuNDU0MzUgNy45MzU3NCA5LjMzNjVWOC4yNjUwN0g2Ljg2NDMxQzYuNzQ2NDUgOC4yNjUwNyA2LjY1MDAyIDguMTY4NjQgNi42NTAwMiA4LjA1MDc4QzYuNjUwMDIgNy45MzI5MiA2Ljc0NjQ1IDcuODM2NSA2Ljg2NDMxIDcuODM2NUg3LjkzNTc0VjYuNzY1MDdDNy45MzU3NCA2LjY0NzIxIDguMDMyMTcgNi41NTA3OCA4LjE1MDAyIDYuNTUwNzhDOC4yNjc4OCA2LjU1MDc4IDguMzY0MzEgNi42NDcyMSA4LjM2NDMxIDYuNzY1MDdWNy44MzY1SDkuNDM1NzRDOS41NTM2IDcuODM2NSA5LjY1MDAyIDcuOTMyOTIgOS42NTAwMiA4LjA1MDc4QzkuNjUwMDIgOC4xNjg2NCA5LjU1MzYgOC4yNjUwNyA5LjQzNTc0IDguMjY1MDdaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC41Ii8+Cjwvc3ZnPgo=);
  --jp-icon-edit: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMgMTcuMjVWMjFoMy43NUwxNy44MSA5Ljk0bC0zLjc1LTMuNzVMMyAxNy4yNXpNMjAuNzEgNy4wNGMuMzktLjM5LjM5LTEuMDIgMC0xLjQxbC0yLjM0LTIuMzRjLS4zOS0uMzktMS4wMi0uMzktMS40MSAwbC0xLjgzIDEuODMgMy43NSAzLjc1IDEuODMtMS44M3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-ellipses: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iNSIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxOSIgY3k9IjEyIiByPSIyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-error: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjE5IiByPSIyIi8+PHBhdGggZD0iTTEwIDNoNHYxMmgtNHoiLz48L2c+CjxwYXRoIGZpbGw9Im5vbmUiIGQ9Ik0wIDBoMjR2MjRIMHoiLz4KPC9zdmc+Cg==);
  --jp-icon-expand-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNMTEgMTBIOXYzSDZ2MmgzdjNoMnYtM2gzdi0yaC0zeiIgLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-extension: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwLjUgMTFIMTlWN2MwLTEuMS0uOS0yLTItMmgtNFYzLjVDMTMgMi4xMiAxMS44OCAxIDEwLjUgMVM4IDIuMTIgOCAzLjVWNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAydjMuOEgzLjVjMS40OSAwIDIuNyAxLjIxIDIuNyAyLjdzLTEuMjEgMi43LTIuNyAyLjdIMlYyMGMwIDEuMS45IDIgMiAyaDMuOHYtMS41YzAtMS40OSAxLjIxLTIuNyAyLjctMi43IDEuNDkgMCAyLjcgMS4yMSAyLjcgMi43VjIySDE3YzEuMSAwIDItLjkgMi0ydi00aDEuNWMxLjM4IDAgMi41LTEuMTIgMi41LTIuNVMyMS44OCAxMSAyMC41IDExeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-fast-forward: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-file-upload: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkgMTZoNnYtNmg0bC03LTctNyA3aDR6bS00IDJoMTR2Mkg1eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-file: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuMyA4LjJsLTUuNS01LjVjLS4zLS4zLS43LS41LTEuMi0uNUgzLjljLS44LjEtMS42LjktMS42IDEuOHYxNC4xYzAgLjkuNyAxLjYgMS42IDEuNmgxNC4yYy45IDAgMS42LS43IDEuNi0xLjZWOS40Yy4xLS41LS4xLS45LS40LTEuMnptLTUuOC0zLjNsMy40IDMuNmgtMy40VjQuOXptMy45IDEyLjdINC43Yy0uMSAwLS4yIDAtLjItLjJWNC43YzAtLjIuMS0uMy4yLS4zaDcuMnY0LjRzMCAuOC4zIDEuMWMuMy4zIDEuMS4zIDEuMS4zaDQuM3Y3LjJzLS4xLjItLjIuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-filter-dot: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWRvdCIgZmlsbD0iI0ZGRiI+CiAgICA8Y2lyY2xlIGN4PSIxOCIgY3k9IjE3IiByPSIzIj48L2NpcmNsZT4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-filter-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEwIDE4aDR2LTJoLTR2MnpNMyA2djJoMThWNkgzem0zIDdoMTJ2LTJINnYyeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-filter: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-folder-favorite: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+PHBhdGggY2xhc3M9ImpwLWljb24zIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxNjE2MSIgZD0iTTIwIDZoLThsLTItMkg0Yy0xLjEgMC0yIC45LTIgMnYxMmMwIDEuMS45IDIgMiAyaDE2YzEuMSAwIDItLjkgMi0yVjhjMC0xLjEtLjktMi0yLTJ6bS0yLjA2IDExTDE1IDE1LjI4IDEyLjA2IDE3bC43OC0zLjMzLTIuNTktMi4yNCAzLjQxLS4yOUwxNSA4bDEuMzQgMy4xNCAzLjQxLjI5LTIuNTkgMi4yNC43OCAzLjMzeiIvPgo8L3N2Zz4K);
  --jp-icon-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yaC04bC0yLTJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-home: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-html5: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uMCBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMDAiIGQ9Ik0xMDguNCAwaDIzdjIyLjhoMjEuMlYwaDIzdjY5aC0yM1Y0NmgtMjF2MjNoLTIzLjJNMjA2IDIzaC0yMC4zVjBoNjMuN3YyM0gyMjl2NDZoLTIzbTUzLjUtNjloMjQuMWwxNC44IDI0LjNMMzEzLjIgMGgyNC4xdjY5aC0yM1YzNC44bC0xNi4xIDI0LjgtMTYuMS0yNC44VjY5aC0yMi42bTg5LjItNjloMjN2NDYuMmgzMi42VjY5aC01NS42Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2U0NGQyNiIgZD0iTTEwNy42IDQ3MWwtMzMtMzcwLjRoMzYyLjhsLTMzIDM3MC4yTDI1NS43IDUxMiIvPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNmMTY1MjkiIGQ9Ik0yNTYgNDgwLjVWMTMxaDE0OC4zTDM3NiA0NDciLz4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNlYmViZWIiIGQ9Ik0xNDIgMTc2LjNoMTE0djQ1LjRoLTY0LjJsNC4yIDQ2LjVoNjB2NDUuM0gxNTQuNG0yIDIyLjhIMjAybDMuMiAzNi4zIDUwLjggMTMuNnY0Ny40bC05My4yLTI2Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIiBkPSJNMzY5LjYgMTc2LjNIMjU1Ljh2NDUuNGgxMDkuNm0tNC4xIDQ2LjVIMjU1Ljh2NDUuNGg1NmwtNS4zIDU5LTUwLjcgMTMuNnY0Ny4ybDkzLTI1LjgiLz4KPC9zdmc+Cg==);
  --jp-icon-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1icmFuZDQganAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNGRkYiIGQ9Ik0yLjIgMi4yaDE3LjV2MTcuNUgyLjJ6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzNGNTFCNSIgZD0iTTIuMiAyLjJ2MTcuNWgxNy41bC4xLTE3LjVIMi4yem0xMi4xIDIuMmMxLjIgMCAyLjIgMSAyLjIgMi4ycy0xIDIuMi0yLjIgMi4yLTIuMi0xLTIuMi0yLjIgMS0yLjIgMi4yLTIuMnpNNC40IDE3LjZsMy4zLTguOCAzLjMgNi42IDIuMi0zLjIgNC40IDUuNEg0LjR6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-info: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUwLjk3OCA1MC45NzgiPgoJPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KCQk8cGF0aCBkPSJNNDMuNTIsNy40NThDMzguNzExLDIuNjQ4LDMyLjMwNywwLDI1LjQ4OSwwQzE4LjY3LDAsMTIuMjY2LDIuNjQ4LDcuNDU4LDcuNDU4CgkJCWMtOS45NDMsOS45NDEtOS45NDMsMjYuMTE5LDAsMzYuMDYyYzQuODA5LDQuODA5LDExLjIxMiw3LjQ1NiwxOC4wMzEsNy40NThjMCwwLDAuMDAxLDAsMC4wMDIsMAoJCQljNi44MTYsMCwxMy4yMjEtMi42NDgsMTguMDI5LTcuNDU4YzQuODA5LTQuODA5LDcuNDU3LTExLjIxMiw3LjQ1Ny0xOC4wM0M1MC45NzcsMTguNjcsNDguMzI4LDEyLjI2Niw0My41Miw3LjQ1OHoKCQkJIE00Mi4xMDYsNDIuMTA1Yy00LjQzMiw0LjQzMS0xMC4zMzIsNi44NzItMTYuNjE1LDYuODcyaC0wLjAwMmMtNi4yODUtMC4wMDEtMTIuMTg3LTIuNDQxLTE2LjYxNy02Ljg3MgoJCQljLTkuMTYyLTkuMTYzLTkuMTYyLTI0LjA3MSwwLTMzLjIzM0MxMy4zMDMsNC40NCwxOS4yMDQsMiwyNS40ODksMmM2LjI4NCwwLDEyLjE4NiwyLjQ0LDE2LjYxNyw2Ljg3MgoJCQljNC40MzEsNC40MzEsNi44NzEsMTAuMzMyLDYuODcxLDE2LjYxN0M0OC45NzcsMzEuNzcyLDQ2LjUzNiwzNy42NzUsNDIuMTA2LDQyLjEwNXoiLz4KCQk8cGF0aCBkPSJNMjMuNTc4LDMyLjIxOGMtMC4wMjMtMS43MzQsMC4xNDMtMy4wNTksMC40OTYtMy45NzJjMC4zNTMtMC45MTMsMS4xMS0xLjk5NywyLjI3Mi0zLjI1MwoJCQljMC40NjgtMC41MzYsMC45MjMtMS4wNjIsMS4zNjctMS41NzVjMC42MjYtMC43NTMsMS4xMDQtMS40NzgsMS40MzYtMi4xNzVjMC4zMzEtMC43MDcsMC40OTUtMS41NDEsMC40OTUtMi41CgkJCWMwLTEuMDk2LTAuMjYtMi4wODgtMC43NzktMi45NzljLTAuNTY1LTAuODc5LTEuNTAxLTEuMzM2LTIuODA2LTEuMzY5Yy0xLjgwMiwwLjA1Ny0yLjk4NSwwLjY2Ny0zLjU1LDEuODMyCgkJCWMtMC4zMDEsMC41MzUtMC41MDMsMS4xNDEtMC42MDcsMS44MTRjLTAuMTM5LDAuNzA3LTAuMjA3LDEuNDMyLTAuMjA3LDIuMTc0aC0yLjkzN2MtMC4wOTEtMi4yMDgsMC40MDctNC4xMTQsMS40OTMtNS43MTkKCQkJYzEuMDYyLTEuNjQsMi44NTUtMi40ODEsNS4zNzgtMi41MjdjMi4xNiwwLjAyMywzLjg3NCwwLjYwOCw1LjE0MSwxLjc1OGMxLjI3OCwxLjE2LDEuOTI5LDIuNzY0LDEuOTUsNC44MTEKCQkJYzAsMS4xNDItMC4xMzcsMi4xMTEtMC40MSwyLjkxMWMtMC4zMDksMC44NDUtMC43MzEsMS41OTMtMS4yNjgsMi4yNDNjLTAuNDkyLDAuNjUtMS4wNjgsMS4zMTgtMS43MywyLjAwMgoJCQljLTAuNjUsMC42OTctMS4zMTMsMS40NzktMS45ODcsMi4zNDZjLTAuMjM5LDAuMzc3LTAuNDI5LDAuNzc3LTAuNTY1LDEuMTk5Yy0wLjE2LDAuOTU5LTAuMjE3LDEuOTUxLTAuMTcxLDIuOTc5CgkJCUMyNi41ODksMzIuMjE4LDIzLjU3OCwzMi4yMTgsMjMuNTc4LDMyLjIxOHogTTIzLjU3OCwzOC4yMnYtMy40ODRoMy4wNzZ2My40ODRIMjMuNTc4eiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-inspector: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaW5zcGVjdG9yLWljb24tY29sb3IganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0tNSAxNEg0di00aDExdjR6bTAtNUg0VjloMTF2NHptNSA1aC00VjloNHY5eiIvPgo8L3N2Zz4K);
  --jp-icon-json: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtanNvbi1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0Y5QTgyNSI+CiAgICA8cGF0aCBkPSJNMjAuMiAxMS44Yy0xLjYgMC0xLjcuNS0xLjcgMSAwIC40LjEuOS4xIDEuMy4xLjUuMS45LjEgMS4zIDAgMS43LTEuNCAyLjMtMy41IDIuM2gtLjl2LTEuOWguNWMxLjEgMCAxLjQgMCAxLjQtLjggMC0uMyAwLS42LS4xLTEgMC0uNC0uMS0uOC0uMS0xLjIgMC0xLjMgMC0xLjggMS4zLTItMS4zLS4yLTEuMy0uNy0xLjMtMiAwLS40LjEtLjguMS0xLjIuMS0uNC4xLS43LjEtMSAwLS44LS40LS43LTEuNC0uOGgtLjVWNC4xaC45YzIuMiAwIDMuNS43IDMuNSAyLjMgMCAuNC0uMS45LS4xIDEuMy0uMS41LS4xLjktLjEgMS4zIDAgLjUuMiAxIDEuNyAxdjEuOHpNMS44IDEwLjFjMS42IDAgMS43LS41IDEuNy0xIDAtLjQtLjEtLjktLjEtMS4zLS4xLS41LS4xLS45LS4xLTEuMyAwLTEuNiAxLjQtMi4zIDMuNS0yLjNoLjl2MS45aC0uNWMtMSAwLTEuNCAwLTEuNC44IDAgLjMgMCAuNi4xIDEgMCAuMi4xLjYuMSAxIDAgMS4zIDAgMS44LTEuMyAyQzYgMTEuMiA2IDExLjcgNiAxM2MwIC40LS4xLjgtLjEgMS4yLS4xLjMtLjEuNy0uMSAxIDAgLjguMy44IDEuNC44aC41djEuOWgtLjljLTIuMSAwLTMuNS0uNi0zLjUtMi4zIDAtLjQuMS0uOS4xLTEuMy4xLS41LjEtLjkuMS0xLjMgMC0uNS0uMi0xLTEuNy0xdi0xLjl6Ii8+CiAgICA8Y2lyY2xlIGN4PSIxMSIgY3k9IjEzLjgiIHI9IjIuMSIvPgogICAgPGNpcmNsZSBjeD0iMTEiIGN5PSI4LjIiIHI9IjIuMSIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-julia: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDMyNSAzMDAiPgogIDxnIGNsYXNzPSJqcC1icmFuZDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjY2IzYzMzIj4KICAgIDxwYXRoIGQ9Ik0gMTUwLjg5ODQzOCAyMjUgQyAxNTAuODk4NDM4IDI2Ni40MjE4NzUgMTE3LjMyMDMxMiAzMDAgNzUuODk4NDM4IDMwMCBDIDM0LjQ3NjU2MiAzMDAgMC44OTg0MzggMjY2LjQyMTg3NSAwLjg5ODQzOCAyMjUgQyAwLjg5ODQzOCAxODMuNTc4MTI1IDM0LjQ3NjU2MiAxNTAgNzUuODk4NDM4IDE1MCBDIDExNy4zMjAzMTIgMTUwIDE1MC44OTg0MzggMTgzLjU3ODEyNSAxNTAuODk4NDM4IDIyNSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzM4OTgyNiI+CiAgICA8cGF0aCBkPSJNIDIzNy41IDc1IEMgMjM3LjUgMTE2LjQyMTg3NSAyMDMuOTIxODc1IDE1MCAxNjIuNSAxNTAgQyAxMjEuMDc4MTI1IDE1MCA4Ny41IDExNi40MjE4NzUgODcuNSA3NSBDIDg3LjUgMzMuNTc4MTI1IDEyMS4wNzgxMjUgMCAxNjIuNSAwIEMgMjAzLjkyMTg3NSAwIDIzNy41IDMzLjU3ODEyNSAyMzcuNSA3NSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzk1NThiMiI+CiAgICA8cGF0aCBkPSJNIDMyNC4xMDE1NjIgMjI1IEMgMzI0LjEwMTU2MiAyNjYuNDIxODc1IDI5MC41MjM0MzggMzAwIDI0OS4xMDE1NjIgMzAwIEMgMjA3LjY3OTY4OCAzMDAgMTc0LjEwMTU2MiAyNjYuNDIxODc1IDE3NC4xMDE1NjIgMjI1IEMgMTc0LjEwMTU2MiAxODMuNTc4MTI1IDIwNy42Nzk2ODggMTUwIDI0OS4xMDE1NjIgMTUwIEMgMjkwLjUyMzQzOCAxNTAgMzI0LjEwMTU2MiAxODMuNTc4MTI1IDMyNC4xMDE1NjIgMjI1Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-jupyter-favicon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUyIiBoZWlnaHQ9IjE2NSIgdmlld0JveD0iMCAwIDE1MiAxNjUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgPGcgY2xhc3M9ImpwLWp1cHl0ZXItaWNvbi1jb2xvciIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA3ODk0NywgMTEwLjU4MjkyNykiIGQ9Ik03NS45NDIyODQyLDI5LjU4MDQ1NjEgQzQzLjMwMjM5NDcsMjkuNTgwNDU2MSAxNC43OTY3ODMyLDE3LjY1MzQ2MzQgMCwwIEM1LjUxMDgzMjExLDE1Ljg0MDY4MjkgMTUuNzgxNTM4OSwyOS41NjY3NzMyIDI5LjM5MDQ5NDcsMzkuMjc4NDE3MSBDNDIuOTk5Nyw0OC45ODk4NTM3IDU5LjI3MzcsNTQuMjA2NzgwNSA3NS45NjA1Nzg5LDU0LjIwNjc4MDUgQzkyLjY0NzQ1NzksNTQuMjA2NzgwNSAxMDguOTIxNDU4LDQ4Ljk4OTg1MzcgMTIyLjUzMDY2MywzOS4yNzg0MTcxIEMxMzYuMTM5NDUzLDI5LjU2Njc3MzIgMTQ2LjQxMDI4NCwxNS44NDA2ODI5IDE1MS45MjExNTgsMCBDMTM3LjA4Nzg2OCwxNy42NTM0NjM0IDEwOC41ODI1ODksMjkuNTgwNDU2MSA3NS45NDIyODQyLDI5LjU4MDQ1NjEgTDc1Ljk0MjI4NDIsMjkuNTgwNDU2MSBaIiAvPgogICAgPHBhdGggdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMzczNjgsIDAuNzA0ODc4KSIgZD0iTTc1Ljk3ODQ1NzksMjQuNjI2NDA3MyBDMTA4LjYxODc2MywyNC42MjY0MDczIDEzNy4xMjQ0NTgsMzYuNTUzNDQxNSAxNTEuOTIxMTU4LDU0LjIwNjc4MDUgQzE0Ni40MTAyODQsMzguMzY2MjIyIDEzNi4xMzk0NTMsMjQuNjQwMTMxNyAxMjIuNTMwNjYzLDE0LjkyODQ4NzggQzEwOC45MjE0NTgsNS4yMTY4NDM5IDkyLjY0NzQ1NzksMCA3NS45NjA1Nzg5LDAgQzU5LjI3MzcsMCA0Mi45OTk3LDUuMjE2ODQzOSAyOS4zOTA0OTQ3LDE0LjkyODQ4NzggQzE1Ljc4MTUzODksMjQuNjQwMTMxNyA1LjUxMDgzMjExLDM4LjM2NjIyMiAwLDU0LjIwNjc4MDUgQzE0LjgzMzA4MTYsMzYuNTg5OTI5MyA0My4zMzg1Njg0LDI0LjYyNjQwNzMgNzUuOTc4NDU3OSwyNC42MjY0MDczIEw3NS45Nzg0NTc5LDI0LjYyNjQwNzMgWiIgLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-jupyter: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzkiIGhlaWdodD0iNTEiIHZpZXdCb3g9IjAgMCAzOSA1MSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTYzOCAtMjI4MSkiPgogICAgIDxnIGNsYXNzPSJqcC1qdXB5dGVyLWljb24tY29sb3IiIGZpbGw9IiNGMzc3MjYiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5Ljc0IDIzMTEuOTgpIiBkPSJNIDE4LjI2NDYgNy4xMzQxMUMgMTAuNDE0NSA3LjEzNDExIDMuNTU4NzIgNC4yNTc2IDAgMEMgMS4zMjUzOSAzLjgyMDQgMy43OTU1NiA3LjEzMDgxIDcuMDY4NiA5LjQ3MzAzQyAxMC4zNDE3IDExLjgxNTIgMTQuMjU1NyAxMy4wNzM0IDE4LjI2OSAxMy4wNzM0QyAyMi4yODIzIDEzLjA3MzQgMjYuMTk2MyAxMS44MTUyIDI5LjQ2OTQgOS40NzMwM0MgMzIuNzQyNCA3LjEzMDgxIDM1LjIxMjYgMy44MjA0IDM2LjUzOCAwQyAzMi45NzA1IDQuMjU3NiAyNi4xMTQ4IDcuMTM0MTEgMTguMjY0NiA3LjEzNDExWiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5LjczIDIyODUuNDgpIiBkPSJNIDE4LjI3MzMgNS45MzkzMUMgMjYuMTIzNSA1LjkzOTMxIDMyLjk3OTMgOC44MTU4MyAzNi41MzggMTMuMDczNEMgMzUuMjEyNiA5LjI1MzAzIDMyLjc0MjQgNS45NDI2MiAyOS40Njk0IDMuNjAwNEMgMjYuMTk2MyAxLjI1ODE4IDIyLjI4MjMgMCAxOC4yNjkgMEMgMTQuMjU1NyAwIDEwLjM0MTcgMS4yNTgxOCA3LjA2ODYgMy42MDA0QyAzLjc5NTU2IDUuOTQyNjIgMS4zMjUzOSA5LjI1MzAzIDAgMTMuMDczNEMgMy41Njc0NSA4LjgyNDYzIDEwLjQyMzIgNS45MzkzMSAxOC4yNzMzIDUuOTM5MzFaIi8+CiAgICA8L2c+CiAgICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjY5LjMgMjI4MS4zMSkiIGQ9Ik0gNS44OTM1MyAyLjg0NEMgNS45MTg4OSAzLjQzMTY1IDUuNzcwODUgNC4wMTM2NyA1LjQ2ODE1IDQuNTE2NDVDIDUuMTY1NDUgNS4wMTkyMiA0LjcyMTY4IDUuNDIwMTUgNC4xOTI5OSA1LjY2ODUxQyAzLjY2NDMgNS45MTY4OCAzLjA3NDQ0IDYuMDAxNTEgMi40OTgwNSA1LjkxMTcxQyAxLjkyMTY2IDUuODIxOSAxLjM4NDYzIDUuNTYxNyAwLjk1NDg5OCA1LjE2NDAxQyAwLjUyNTE3IDQuNzY2MzMgMC4yMjIwNTYgNC4yNDkwMyAwLjA4MzkwMzcgMy42Nzc1N0MgLTAuMDU0MjQ4MyAzLjEwNjExIC0wLjAyMTIzIDIuNTA2MTcgMC4xNzg3ODEgMS45NTM2NEMgMC4zNzg3OTMgMS40MDExIDAuNzM2ODA5IDAuOTIwODE3IDEuMjA3NTQgMC41NzM1MzhDIDEuNjc4MjYgMC4yMjYyNTkgMi4yNDA1NSAwLjAyNzU5MTkgMi44MjMyNiAwLjAwMjY3MjI5QyAzLjYwMzg5IC0wLjAzMDcxMTUgNC4zNjU3MyAwLjI0OTc4OSA0Ljk0MTQyIDAuNzgyNTUxQyA1LjUxNzExIDEuMzE1MzEgNS44NTk1NiAyLjA1Njc2IDUuODkzNTMgMi44NDRaIi8+CiAgICAgIDxwYXRoIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MzkuOCAyMzIzLjgxKSIgZD0iTSA3LjQyNzg5IDMuNTgzMzhDIDcuNDYwMDggNC4zMjQzIDcuMjczNTUgNS4wNTgxOSA2Ljg5MTkzIDUuNjkyMTNDIDYuNTEwMzEgNi4zMjYwNyA1Ljk1MDc1IDYuODMxNTYgNS4yODQxMSA3LjE0NDZDIDQuNjE3NDcgNy40NTc2MyAzLjg3MzcxIDcuNTY0MTQgMy4xNDcwMiA3LjQ1MDYzQyAyLjQyMDMyIDcuMzM3MTIgMS43NDMzNiA3LjAwODcgMS4yMDE4NCA2LjUwNjk1QyAwLjY2MDMyOCA2LjAwNTIgMC4yNzg2MSA1LjM1MjY4IDAuMTA1MDE3IDQuNjMyMDJDIC0wLjA2ODU3NTcgMy45MTEzNSAtMC4wMjYyMzYxIDMuMTU0OTQgMC4yMjY2NzUgMi40NTg1NkMgMC40Nzk1ODcgMS43NjIxNyAwLjkzMTY5NyAxLjE1NzEzIDEuNTI1NzYgMC43MjAwMzNDIDIuMTE5ODMgMC4yODI5MzUgMi44MjkxNCAwLjAzMzQzOTUgMy41NjM4OSAwLjAwMzEzMzQ0QyA0LjU0NjY3IC0wLjAzNzQwMzMgNS41MDUyOSAwLjMxNjcwNiA2LjIyOTYxIDAuOTg3ODM1QyA2Ljk1MzkzIDEuNjU4OTYgNy4zODQ4NCAyLjU5MjM1IDcuNDI3ODkgMy41ODMzOEwgNy40Mjc4OSAzLjU4MzM4WiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM4LjM2IDIyODYuMDYpIiBkPSJNIDIuMjc0NzEgNC4zOTYyOUMgMS44NDM2MyA0LjQxNTA4IDEuNDE2NzEgNC4zMDQ0NSAxLjA0Nzk5IDQuMDc4NDNDIDAuNjc5MjY4IDMuODUyNCAwLjM4NTMyOCAzLjUyMTE0IDAuMjAzMzcxIDMuMTI2NTZDIDAuMDIxNDEzNiAyLjczMTk4IC0wLjA0MDM3OTggMi4yOTE4MyAwLjAyNTgxMTYgMS44NjE4MUMgMC4wOTIwMDMxIDEuNDMxOCAwLjI4MzIwNCAxLjAzMTI2IDAuNTc1MjEzIDAuNzEwODgzQyAwLjg2NzIyMiAwLjM5MDUxIDEuMjQ2OTEgMC4xNjQ3MDggMS42NjYyMiAwLjA2MjA1OTJDIDIuMDg1NTMgLTAuMDQwNTg5NyAyLjUyNTYxIC0wLjAxNTQ3MTQgMi45MzA3NiAwLjEzNDIzNUMgMy4zMzU5MSAwLjI4Mzk0MSAzLjY4NzkyIDAuNTUxNTA1IDMuOTQyMjIgMC45MDMwNkMgNC4xOTY1MiAxLjI1NDYyIDQuMzQxNjkgMS42NzQzNiA0LjM1OTM1IDIuMTA5MTZDIDQuMzgyOTkgMi42OTEwNyA0LjE3Njc4IDMuMjU4NjkgMy43ODU5NyAzLjY4NzQ2QyAzLjM5NTE2IDQuMTE2MjQgMi44NTE2NiA0LjM3MTE2IDIuMjc0NzEgNC4zOTYyOUwgMi4yNzQ3MSA0LjM5NjI5WiIvPgogICAgPC9nPgogIDwvZz4+Cjwvc3ZnPgo=);
  --jp-icon-jupyterlab-wordmark: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIHZpZXdCb3g9IjAgMCAxODYwLjggNDc1Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0RTRFNEUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4MC4xMzY0MDEsIDY0LjI3MTQ5MykiPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDU4Ljg3NTU2NikiPgogICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA4NzYwMywgMC4xNDAyOTQpIj4KICAgICAgICA8cGF0aCBkPSJNLTQyNi45LDE2OS44YzAsNDguNy0zLjcsNjQuNy0xMy42LDc2LjRjLTEwLjgsMTAtMjUsMTUuNS0zOS43LDE1LjVsMy43LDI5IGMyMi44LDAuMyw0NC44LTcuOSw2MS45LTIzLjFjMTcuOC0xOC41LDI0LTQ0LjEsMjQtODMuM1YwSC00Mjd2MTcwLjFMLTQyNi45LDE2OS44TC00MjYuOSwxNjkuOHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU1LjA0NTI5NiwgNTYuODM3MTA0KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTYyNDUzLCAxLjc5OTg0MikiPgogICAgICAgIDxwYXRoIGQ9Ik0tMzEyLDE0OGMwLDIxLDAsMzkuNSwxLjcsNTUuNGgtMzEuOGwtMi4xLTMzLjNoLTAuOGMtNi43LDExLjYtMTYuNCwyMS4zLTI4LDI3LjkgYy0xMS42LDYuNi0yNC44LDEwLTM4LjIsOS44Yy0zMS40LDAtNjktMTcuNy02OS04OVYwaDM2LjR2MTEyLjdjMCwzOC43LDExLjYsNjQuNyw0NC42LDY0LjdjMTAuMy0wLjIsMjAuNC0zLjUsMjguOS05LjQgYzguNS01LjksMTUuMS0xNC4zLDE4LjktMjMuOWMyLjItNi4xLDMuMy0xMi41LDMuMy0xOC45VjAuMmgzNi40VjE0OEgtMzEyTC0zMTIsMTQ4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOTAuMDEzMzIyLCA1My40Nzk2MzgpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS43MDY0NTgsIDAuMjMxNDI1KSI+CiAgICAgICAgPHBhdGggZD0iTS00NzguNiw3MS40YzAtMjYtMC44LTQ3LTEuNy02Ni43aDMyLjdsMS43LDM0LjhoMC44YzcuMS0xMi41LDE3LjUtMjIuOCwzMC4xLTI5LjcgYzEyLjUtNywyNi43LTEwLjMsNDEtOS44YzQ4LjMsMCw4NC43LDQxLjcsODQuNywxMDMuM2MwLDczLjEtNDMuNywxMDkuMi05MSwxMDkuMmMtMTIuMSwwLjUtMjQuMi0yLjItMzUtNy44IGMtMTAuOC01LjYtMTkuOS0xMy45LTI2LjYtMjQuMmgtMC44VjI5MWgtMzZ2LTIyMEwtNDc4LjYsNzEuNEwtNDc4LjYsNzEuNHogTS00NDIuNiwxMjUuNmMwLjEsNS4xLDAuNiwxMC4xLDEuNywxNS4xIGMzLDEyLjMsOS45LDIzLjMsMTkuOCwzMS4xYzkuOSw3LjgsMjIuMSwxMi4xLDM0LjcsMTIuMWMzOC41LDAsNjAuNy0zMS45LDYwLjctNzguNWMwLTQwLjctMjEuMS03NS42LTU5LjUtNzUuNiBjLTEyLjksMC40LTI1LjMsNS4xLTM1LjMsMTMuNGMtOS45LDguMy0xNi45LDE5LjctMTkuNiwzMi40Yy0xLjUsNC45LTIuMywxMC0yLjUsMTUuMVYxMjUuNkwtNDQyLjYsMTI1LjZMLTQ0Mi42LDEyNS42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MDYuNzQwNzI2LCA1Ni44MzcxMDQpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC43NTEyMjYsIDEuOTg5Mjk5KSI+CiAgICAgICAgPHBhdGggZD0iTS00NDAuOCwwbDQzLjcsMTIwLjFjNC41LDEzLjQsOS41LDI5LjQsMTIuOCw0MS43aDAuOGMzLjctMTIuMiw3LjktMjcuNywxMi44LTQyLjQgbDM5LjctMTE5LjJoMzguNUwtMzQ2LjksMTQ1Yy0yNiw2OS43LTQzLjcsMTA1LjQtNjguNiwxMjcuMmMtMTIuNSwxMS43LTI3LjksMjAtNDQuNiwyMy45bC05LjEtMzEuMSBjMTEuNy0zLjksMjIuNS0xMC4xLDMxLjgtMTguMWMxMy4yLTExLjEsMjMuNy0yNS4yLDMwLjYtNDEuMmMxLjUtMi44LDIuNS01LjcsMi45LTguOGMtMC4zLTMuMy0xLjItNi42LTIuNS05LjdMLTQ4MC4yLDAuMSBoMzkuN0wtNDQwLjgsMEwtNDQwLjgsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODIyLjc0ODEwNCwgMC4wMDAwMDApIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS40NjQwNTAsIDAuMzc4OTE0KSI+CiAgICAgICAgPHBhdGggZD0iTS00MTMuNywwdjU4LjNoNTJ2MjguMmgtNTJWMTk2YzAsMjUsNywzOS41LDI3LjMsMzkuNWM3LjEsMC4xLDE0LjItMC43LDIxLjEtMi41IGwxLjcsMjcuN2MtMTAuMywzLjctMjEuMyw1LjQtMzIuMiw1Yy03LjMsMC40LTE0LjYtMC43LTIxLjMtMy40Yy02LjgtMi43LTEyLjktNi44LTE3LjktMTIuMWMtMTAuMy0xMC45LTE0LjEtMjktMTQuMS01Mi45IFY4Ni41aC0zMVY1OC4zaDMxVjkuNkwtNDEzLjcsMEwtNDEzLjcsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTc0LjQzMzI4NiwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuOTkwMDM0LCAwLjYxMDMzOSkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDQ1LjgsMTEzYzAuOCw1MCwzMi4yLDcwLjYsNjguNiw3MC42YzE5LDAuNiwzNy45LTMsNTUuMy0xMC41bDYuMiwyNi40IGMtMjAuOSw4LjktNDMuNSwxMy4xLTY2LjIsMTIuNmMtNjEuNSwwLTk4LjMtNDEuMi05OC4zLTEwMi41Qy00ODAuMiw0OC4yLTQ0NC43LDAtMzg2LjUsMGM2NS4yLDAsODIuNyw1OC4zLDgyLjcsOTUuNyBjLTAuMSw1LjgtMC41LDExLjUtMS4yLDE3LjJoLTE0MC42SC00NDUuOEwtNDQ1LjgsMTEzeiBNLTMzOS4yLDg2LjZjMC40LTIzLjUtOS41LTYwLjEtNTAuNC02MC4xIGMtMzYuOCwwLTUyLjgsMzQuNC01NS43LDYwLjFILTMzOS4yTC0zMzkuMiw4Ni42TC0zMzkuMiw4Ni42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAxLjk2MTA1OCwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuMTc5NjQwLCAwLjcwNTA2OCkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDc4LjYsNjhjMC0yMy45LTAuNC00NC41LTEuNy02My40aDMxLjhsMS4yLDM5LjloMS43YzkuMS0yNy4zLDMxLTQ0LjUsNTUuMy00NC41IGMzLjUtMC4xLDcsMC40LDEwLjMsMS4ydjM0LjhjLTQuMS0wLjktOC4yLTEuMy0xMi40LTEuMmMtMjUuNiwwLTQzLjcsMTkuNy00OC43LDQ3LjRjLTEsNS43LTEuNiwxMS41LTEuNywxNy4ydjEwOC4zaC0zNlY2OCBMLTQ3OC42LDY4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMCIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCBkPSJNMTM1Mi4zLDMyNi4yaDM3VjI4aC0zN1YzMjYuMnogTTE2MDQuOCwzMjYuMmMtMi41LTEzLjktMy40LTMxLjEtMy40LTQ4Ljd2LTc2IGMwLTQwLjctMTUuMS04My4xLTc3LjMtODMuMWMtMjUuNiwwLTUwLDcuMS02Ni44LDE4LjFsOC40LDI0LjRjMTQuMy05LjIsMzQtMTUuMSw1My0xNS4xYzQxLjYsMCw0Ni4yLDMwLjIsNDYuMiw0N3Y0LjIgYy03OC42LTAuNC0xMjIuMywyNi41LTEyMi4zLDc1LjZjMCwyOS40LDIxLDU4LjQsNjIuMiw1OC40YzI5LDAsNTAuOS0xNC4zLDYyLjItMzAuMmgxLjNsMi45LDI1LjZIMTYwNC44eiBNMTU2NS43LDI1Ny43IGMwLDMuOC0wLjgsOC0yLjEsMTEuOGMtNS45LDE3LjItMjIuNywzNC00OS4yLDM0Yy0xOC45LDAtMzQuOS0xMS4zLTM0LjktMzUuM2MwLTM5LjUsNDUuOC00Ni42LDg2LjItNDUuOFYyNTcuN3ogTTE2OTguNSwzMjYuMiBsMS43LTMzLjZoMS4zYzE1LjEsMjYuOSwzOC43LDM4LjIsNjguMSwzOC4yYzQ1LjQsMCw5MS4yLTM2LjEsOTEuMi0xMDguOGMwLjQtNjEuNy0zNS4zLTEwMy43LTg1LjctMTAzLjcgYy0zMi44LDAtNTYuMywxNC43LTY5LjMsMzcuNGgtMC44VjI4aC0zNi42djI0NS43YzAsMTguMS0wLjgsMzguNi0xLjcsNTIuNUgxNjk4LjV6IE0xNzA0LjgsMjA4LjJjMC01LjksMS4zLTEwLjksMi4xLTE1LjEgYzcuNi0yOC4xLDMxLjEtNDUuNCw1Ni4zLTQ1LjRjMzkuNSwwLDYwLjUsMzQuOSw2MC41LDc1LjZjMCw0Ni42LTIzLjEsNzguMS02MS44LDc4LjFjLTI2LjksMC00OC4zLTE3LjYtNTUuNS00My4zIGMtMC44LTQuMi0xLjctOC44LTEuNy0xMy40VjIwOC4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzYxNjE2MSIgZD0iTTE1IDlIOXY2aDZWOXptLTIgNGgtMnYtMmgydjJ6bTgtMlY5aC0yVjdjMC0xLjEtLjktMi0yLTJoLTJWM2gtMnYyaC0yVjNIOXYySDdjLTEuMSAwLTIgLjktMiAydjJIM3YyaDJ2MkgzdjJoMnYyYzAgMS4xLjkgMiAyIDJoMnYyaDJ2LTJoMnYyaDJ2LTJoMmMxLjEgMCAyLS45IDItMnYtMmgydi0yaC0ydi0yaDJ6bS00IDZIN1Y3aDEwdjEweiIvPgo8L3N2Zz4K);
  --jp-icon-keyboard: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMTdjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY3YzAtMS4xLS45LTItMi0yem0tOSAzaDJ2MmgtMlY4em0wIDNoMnYyaC0ydi0yek04IDhoMnYySDhWOHptMCAzaDJ2Mkg4di0yem0tMSAySDV2LTJoMnYyem0wLTNINVY4aDJ2MnptOSA3SDh2LTJoOHYyem0wLTRoLTJ2LTJoMnYyem0wLTNoLTJWOGgydjJ6bTMgM2gtMnYtMmgydjJ6bTAtM2gtMlY4aDJ2MnoiLz4KPC9zdmc+Cg==);
  --jp-icon-launch: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yNiwyOEg2YTIuMDAyNywyLjAwMjcsMCwwLDEtMi0yVjZBMi4wMDI3LDIuMDAyNywwLDAsMSw2LDRIMTZWNkg2VjI2SDI2VjE2aDJWMjZBMi4wMDI3LDIuMDAyNywwLDAsMSwyNiwyOFoiLz4KICAgIDxwb2x5Z29uIHBvaW50cz0iMjAgMiAyMCA0IDI2LjU4NiA0IDE4IDEyLjU4NiAxOS40MTQgMTQgMjggNS40MTQgMjggMTIgMzAgMTIgMzAgMiAyMCAyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-launcher: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkgMTlINVY1aDdWM0g1YTIgMiAwIDAwLTIgMnYxNGEyIDIgMCAwMDIgMmgxNGMxLjEgMCAyLS45IDItMnYtN2gtMnY3ek0xNCAzdjJoMy41OWwtOS44MyA5LjgzIDEuNDEgMS40MUwxOSA2LjQxVjEwaDJWM2gtN3oiLz4KPC9zdmc+Cg==);
  --jp-icon-line-form: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGZpbGw9IndoaXRlIiBkPSJNNS44OCA0LjEyTDEzLjc2IDEybC03Ljg4IDcuODhMOCAyMmwxMC0xMEw4IDJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-link: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMuOSAxMmMwLTEuNzEgMS4zOS0zLjEgMy4xLTMuMWg0VjdIN2MtMi43NiAwLTUgMi4yNC01IDVzMi4yNCA1IDUgNWg0di0xLjlIN2MtMS43MSAwLTMuMS0xLjM5LTMuMS0zLjF6TTggMTNoOHYtMkg4djJ6bTktNmgtNHYxLjloNGMxLjcxIDAgMy4xIDEuMzkgMy4xIDMuMXMtMS4zOSAzLjEtMy4xIDMuMWgtNFYxN2g0YzIuNzYgMCA1LTIuMjQgNS01cy0yLjI0LTUtNS01eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xOSA1djE0SDVWNWgxNG0xLjEtMkgzLjljLS41IDAtLjkuNC0uOS45djE2LjJjMCAuNC40LjkuOS45aDE2LjJjLjQgMCAuOS0uNS45LS45VjMuOWMwLS41LS41LS45LS45LS45ek0xMSA3aDZ2MmgtNlY3em0wIDRoNnYyaC02di0yem0wIDRoNnYyaC02ek03IDdoMnYySDd6bTAgNGgydjJIN3ptMCA0aDJ2Mkg3eiIvPgo8L3N2Zz4K);
  --jp-icon-markdown: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjN0IxRkEyIiBkPSJNNSAxNC45aDEybC02LjEgNnptOS40LTYuOGMwLTEuMy0uMS0yLjktLjEtNC41LS40IDEuNC0uOSAyLjktMS4zIDQuM2wtMS4zIDQuM2gtMkw4LjUgNy45Yy0uNC0xLjMtLjctMi45LTEtNC4zLS4xIDEuNi0uMSAzLjItLjIgNC42TDcgMTIuNEg0LjhsLjctMTFoMy4zTDEwIDVjLjQgMS4yLjcgMi43IDEgMy45LjMtMS4yLjctMi42IDEtMy45bDEuMi0zLjdoMy4zbC42IDExaC0yLjRsLS4zLTQuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-move-down: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMTIuNDcxIDcuNTI4OTlDMTIuNzYzMiA3LjIzNjg0IDEyLjc2MzIgNi43NjMxNiAxMi40NzEgNi40NzEwMVY2LjQ3MTAxQzEyLjE3OSA2LjE3OTA1IDExLjcwNTcgNi4xNzg4NCAxMS40MTM1IDYuNDcwNTRMNy43NSAxMC4xMjc1VjEuNzVDNy43NSAxLjMzNTc5IDcuNDE0MjEgMSA3IDFWMUM2LjU4NTc5IDEgNi4yNSAxLjMzNTc5IDYuMjUgMS43NVYxMC4xMjc1TDIuNTk3MjYgNi40NjgyMkMyLjMwMzM4IDYuMTczODEgMS44MjY0MSA2LjE3MzU5IDEuNTMyMjYgNi40Njc3NFY2LjQ2Nzc0QzEuMjM4MyA2Ljc2MTcgMS4yMzgzIDcuMjM4MyAxLjUzMjI2IDcuNTMyMjZMNi4yOTI4OSAxMi4yOTI5QzYuNjgzNDIgMTIuNjgzNCA3LjMxNjU4IDEyLjY4MzQgNy43MDcxMSAxMi4yOTI5TDEyLjQ3MSA3LjUyODk5WiIgZmlsbD0iIzYxNjE2MSIvPgo8L3N2Zz4K);
  --jp-icon-move-up: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMS41Mjg5OSA2LjQ3MTAxQzEuMjM2ODQgNi43NjMxNiAxLjIzNjg0IDcuMjM2ODQgMS41Mjg5OSA3LjUyODk5VjcuNTI4OTlDMS44MjA5NSA3LjgyMDk1IDIuMjk0MjYgNy44MjExNiAyLjU4NjQ5IDcuNTI5NDZMNi4yNSAzLjg3MjVWMTIuMjVDNi4yNSAxMi42NjQyIDYuNTg1NzkgMTMgNyAxM1YxM0M3LjQxNDIxIDEzIDcuNzUgMTIuNjY0MiA3Ljc1IDEyLjI1VjMuODcyNUwxMS40MDI3IDcuNTMxNzhDMTEuNjk2NiA3LjgyNjE5IDEyLjE3MzYgNy44MjY0MSAxMi40Njc3IDcuNTMyMjZWNy41MzIyNkMxMi43NjE3IDcuMjM4MyAxMi43NjE3IDYuNzYxNyAxMi40Njc3IDYuNDY3NzRMNy43MDcxMSAxLjcwNzExQzcuMzE2NTggMS4zMTY1OCA2LjY4MzQyIDEuMzE2NTggNi4yOTI4OSAxLjcwNzExTDEuNTI4OTkgNi40NzEwMVoiIGZpbGw9IiM2MTYxNjEiLz4KPC9zdmc+Cg==);
  --jp-icon-new-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwIDZoLThsLTItMkg0Yy0xLjExIDAtMS45OS44OS0xLjk5IDJMMiAxOGMwIDEuMTEuODkgMiAyIDJoMTZjMS4xMSAwIDItLjg5IDItMlY4YzAtMS4xMS0uODktMi0yLTJ6bS0xIDhoLTN2M2gtMnYtM2gtM3YtMmgzVjloMnYzaDN2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-not-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI1IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMTkgMTcuMTg0NCAyLjk2OTY4IDE0LjMwMzIgMS44NjA5NCAxMS40NDA5WiIvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24yIiBzdHJva2U9IiMzMzMzMzMiIHN0cm9rZS13aWR0aD0iMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOS4zMTU5MiA5LjMyMDMxKSIgZD0iTTcuMzY4NDIgMEwwIDcuMzY0NzkiLz4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkuMzE1OTIgMTYuNjgzNikgc2NhbGUoMSAtMSkiIGQ9Ik03LjM2ODQyIDBMMCA3LjM2NDc5Ii8+Cjwvc3ZnPgo=);
  --jp-icon-notebook: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtbm90ZWJvb2staWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNFRjZDMDAiPgogICAgPHBhdGggZD0iTTE4LjcgMy4zdjE1LjRIMy4zVjMuM2gxNS40bTEuNS0xLjVIMS44djE4LjNoMTguM2wuMS0xOC4zeiIvPgogICAgPHBhdGggZD0iTTE2LjUgMTYuNWwtNS40LTQuMy01LjYgNC4zdi0xMWgxMXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-numbering: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTQgMTlINlYxOS41SDVWMjAuNUg2VjIxSDRWMjJIN1YxOEg0VjE5Wk01IDEwSDZWNkg0VjdINVYxMFpNNCAxM0g1LjhMNCAxNS4xVjE2SDdWMTVINS4yTDcgMTIuOVYxMkg0VjEzWk05IDdWOUgyM1Y3SDlaTTkgMjFIMjNWMTlIOVYyMVpNOSAxNUgyM1YxM0g5VjE1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-offline-bolt: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDIuMDJjLTUuNTEgMC05Ljk4IDQuNDctOS45OCA5Ljk4czQuNDcgOS45OCA5Ljk4IDkuOTggOS45OC00LjQ3IDkuOTgtOS45OFMxNy41MSAyLjAyIDEyIDIuMDJ6TTExLjQ4IDIwdi02LjI2SDhMMTMgNHY2LjI2aDMuMzVMMTEuNDggMjB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-palette: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE4IDEzVjIwSDRWNkg5LjAyQzkuMDcgNS4yOSA5LjI0IDQuNjIgOS41IDRINEMyLjkgNCAyIDQuOSAyIDZWMjBDMiAyMS4xIDIuOSAyMiA0IDIySDE4QzE5LjEgMjIgMjAgMjEuMSAyMCAyMFYxNUwxOCAxM1pNMTkuMyA4Ljg5QzE5Ljc0IDguMTkgMjAgNy4zOCAyMCA2LjVDMjAgNC4wMSAxNy45OSAyIDE1LjUgMkMxMy4wMSAyIDExIDQuMDEgMTEgNi41QzExIDguOTkgMTMuMDEgMTEgMTUuNDkgMTFDMTYuMzcgMTEgMTcuMTkgMTAuNzQgMTcuODggMTAuM0wyMSAxMy40MkwyMi40MiAxMkwxOS4zIDguODlaTTE1LjUgOUMxNC4xMiA5IDEzIDcuODggMTMgNi41QzEzIDUuMTIgMTQuMTIgNCAxNS41IDRDMTYuODggNCAxOCA1LjEyIDE4IDYuNUMxOCA3Ljg4IDE2Ljg4IDkgMTUuNSA5WiIvPgogICAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDZIOS4wMTg5NEM5LjAwNjM5IDYuMTY1MDIgOSA2LjMzMTc2IDkgNi41QzkgOC44MTU3NyAxMC4yMTEgMTAuODQ4NyAxMi4wMzQzIDEySDlWMTRIMTZWMTIuOTgxMUMxNi41NzAzIDEyLjkzNzcgMTcuMTIgMTIuODIwNyAxNy42Mzk2IDEyLjYzOTZMMTggMTNWMjBINFY2Wk04IDhINlYxMEg4VjhaTTYgMTJIOFYxNEg2VjEyWk04IDE2SDZWMThIOFYxNlpNOSAxNkgxNlYxOEg5VjE2WiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-paste: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE5IDJoLTQuMThDMTQuNC44NCAxMy4zIDAgMTIgMGMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNmMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptNyAxOEg1VjRoMnYzaDEwVjRoMnYxNnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-pdf: url(data:image/svg+xml;base64,PHN2ZwogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMiIgd2lkdGg9IjE2Ij4KICAgIDxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDQ1KSIgY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0ZGMkEyQSIKICAgICAgIGQ9Im0gMjIuMzQ0MzY5LC0zLjAxNjM2NDIgaCA1LjYzODYwNCB2IDEuNTc5MjQzMyBoIC0zLjU0OTIyNyB2IDEuNTA4NjkyOTkgaCAzLjMzNzU3NiBWIDEuNjUwODE1NCBoIC0zLjMzNzU3NiB2IDMuNDM1MjYxMyBoIC0yLjA4OTM3NyB6IG0gLTcuMTM2NDQ0LDEuNTc5MjQzMyB2IDQuOTQzOTU0MyBoIDAuNzQ4OTIgcSAxLjI4MDc2MSwwIDEuOTUzNzAzLC0wLjYzNDk1MzUgMC42NzgzNjksLTAuNjM0OTUzNSAwLjY3ODM2OSwtMS44NDUxNjQxIDAsLTEuMjA0NzgzNTUgLTAuNjcyOTQyLC0xLjgzNDMxMDExIC0wLjY3Mjk0MiwtMC42Mjk1MjY1OSAtMS45NTkxMywtMC42Mjk1MjY1OSB6IG0gLTIuMDg5Mzc3LC0xLjU3OTI0MzMgaCAyLjIwMzM0MyBxIDEuODQ1MTY0LDAgMi43NDYwMzksMC4yNjU5MjA3IDAuOTA2MzAxLDAuMjYwNDkzNyAxLjU1MjEwOCwwLjg5MDAyMDMgMC41Njk4MywwLjU0ODEyMjMgMC44NDY2MDUsMS4yNjQ0ODAwNiAwLjI3Njc3NCwwLjcxNjM1NzgxIDAuMjc2Nzc0LDEuNjIyNjU4OTQgMCwwLjkxNzE1NTEgLTAuMjc2Nzc0LDEuNjM4OTM5OSAtMC4yNzY3NzUsMC43MTYzNTc4IC0wLjg0NjYwNSwxLjI2NDQ4IC0wLjY1MTIzNCwwLjYyOTUyNjYgLTEuNTYyOTYyLDAuODk1NDQ3MyAtMC45MTE3MjgsMC4yNjA0OTM3IC0yLjczNTE4NSwwLjI2MDQ5MzcgaCAtMi4yMDMzNDMgeiBtIC04LjE0NTg1NjUsMCBoIDMuNDY3ODIzIHEgMS41NDY2ODE2LDAgMi4zNzE1Nzg1LDAuNjg5MjIzIDAuODMwMzI0LDAuNjgzNzk2MSAwLjgzMDMyNCwxLjk1MzcwMzE0IDAsMS4yNzUzMzM5NyAtMC44MzAzMjQsMS45NjQ1NTcwNiBRIDkuOTg3MTk2MSwyLjI3NDkxNSA4LjQ0MDUxNDUsMi4yNzQ5MTUgSCA3LjA2MjA2ODQgViA1LjA4NjA3NjcgSCA0Ljk3MjY5MTUgWiBtIDIuMDg5Mzc2OSwxLjUxNDExOTkgdiAyLjI2MzAzOTQzIGggMS4xNTU5NDEgcSAwLjYwNzgxODgsMCAwLjkzODg2MjksLTAuMjkzMDU1NDcgMC4zMzEwNDQxLC0wLjI5ODQ4MjQxIDAuMzMxMDQ0MSwtMC44NDExNzc3MiAwLC0wLjU0MjY5NTMxIC0wLjMzMTA0NDEsLTAuODM1NzUwNzQgLTAuMzMxMDQ0MSwtMC4yOTMwNTU1IC0wLjkzODg2MjksLTAuMjkzMDU1NSB6IgovPgo8L3N2Zz4K);
  --jp-icon-python: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iLTEwIC0xMCAxMzEuMTYxMzYxNjk0MzM1OTQgMTMyLjM4ODk5OTkzODk2NDg0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzA2OTk4IiBkPSJNIDU0LjkxODc4NSw5LjE5Mjc0MjFlLTQgQyA1MC4zMzUxMzIsMC4wMjIyMTcyNyA0NS45NTc4NDYsMC40MTMxMzY5NyA0Mi4xMDYyODUsMS4wOTQ2NjkzIDMwLjc2MDA2OSwzLjA5OTE3MzEgMjguNzAwMDM2LDcuMjk0NzcxNCAyOC43MDAwMzUsMTUuMDMyMTY5IHYgMTAuMjE4NzUgaCAyNi44MTI1IHYgMy40MDYyNSBoIC0yNi44MTI1IC0xMC4wNjI1IGMgLTcuNzkyNDU5LDAgLTE0LjYxNTc1ODgsNC42ODM3MTcgLTE2Ljc0OTk5OTgsMTMuNTkzNzUgLTIuNDYxODE5OTgsMTAuMjEyOTY2IC0yLjU3MTAxNTA4LDE2LjU4NjAyMyAwLDI3LjI1IDEuOTA1OTI4Myw3LjkzNzg1MiA2LjQ1NzU0MzIsMTMuNTkzNzQ4IDE0LjI0OTk5OTgsMTMuNTkzNzUgaCA5LjIxODc1IHYgLTEyLjI1IGMgMCwtOC44NDk5MDIgNy42NTcxNDQsLTE2LjY1NjI0OCAxNi43NSwtMTYuNjU2MjUgaCAyNi43ODEyNSBjIDcuNDU0OTUxLDAgMTMuNDA2MjUzLC02LjEzODE2NCAxMy40MDYyNSwtMTMuNjI1IHYgLTI1LjUzMTI1IGMgMCwtNy4yNjYzMzg2IC02LjEyOTk4LC0xMi43MjQ3NzcxIC0xMy40MDYyNSwtMTMuOTM3NDk5NyBDIDY0LjI4MTU0OCwwLjMyNzk0Mzk3IDU5LjUwMjQzOCwtMC4wMjAzNzkwMyA1NC45MTg3ODUsOS4xOTI3NDIxZS00IFogbSAtMTQuNSw4LjIxODc1MDEyNTc5IGMgMi43Njk1NDcsMCA1LjAzMTI1LDIuMjk4NjQ1NiA1LjAzMTI1LDUuMTI0OTk5NiAtMmUtNiwyLjgxNjMzNiAtMi4yNjE3MDMsNS4wOTM3NSAtNS4wMzEyNSw1LjA5Mzc1IC0yLjc3OTQ3NiwtMWUtNiAtNS4wMzEyNSwtMi4yNzc0MTUgLTUuMDMxMjUsLTUuMDkzNzUgLTEwZS03LC0yLjgyNjM1MyAyLjI1MTc3NCwtNS4xMjQ5OTk2IDUuMDMxMjUsLTUuMTI0OTk5NiB6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2ZmZDQzYiIgZD0ibSA4NS42Mzc1MzUsMjguNjU3MTY5IHYgMTEuOTA2MjUgYyAwLDkuMjMwNzU1IC03LjgyNTg5NSwxNi45OTk5OTkgLTE2Ljc1LDE3IGggLTI2Ljc4MTI1IGMgLTcuMzM1ODMzLDAgLTEzLjQwNjI0OSw2LjI3ODQ4MyAtMTMuNDA2MjUsMTMuNjI1IHYgMjUuNTMxMjQ3IGMgMCw3LjI2NjM0NCA2LjMxODU4OCwxMS41NDAzMjQgMTMuNDA2MjUsMTMuNjI1MDA0IDguNDg3MzMxLDIuNDk1NjEgMTYuNjI2MjM3LDIuOTQ2NjMgMjYuNzgxMjUsMCA2Ljc1MDE1NSwtMS45NTQzOSAxMy40MDYyNTMsLTUuODg3NjEgMTMuNDA2MjUsLTEzLjYyNTAwNCBWIDg2LjUwMDkxOSBoIC0yNi43ODEyNSB2IC0zLjQwNjI1IGggMjYuNzgxMjUgMTMuNDA2MjU0IGMgNy43OTI0NjEsMCAxMC42OTYyNTEsLTUuNDM1NDA4IDEzLjQwNjI0MSwtMTMuNTkzNzUgMi43OTkzMywtOC4zOTg4ODYgMi42ODAyMiwtMTYuNDc1Nzc2IDAsLTI3LjI1IC0xLjkyNTc4LC03Ljc1NzQ0MSAtNS42MDM4NywtMTMuNTkzNzUgLTEzLjQwNjI0MSwtMTMuNTkzNzUgeiBtIC0xNS4wNjI1LDY0LjY1NjI1IGMgMi43Nzk0NzgsM2UtNiA1LjAzMTI1LDIuMjc3NDE3IDUuMDMxMjUsNS4wOTM3NDcgLTJlLTYsMi44MjYzNTQgLTIuMjUxNzc1LDUuMTI1MDA0IC01LjAzMTI1LDUuMTI1MDA0IC0yLjc2OTU1LDAgLTUuMDMxMjUsLTIuMjk4NjUgLTUuMDMxMjUsLTUuMTI1MDA0IDJlLTYsLTIuODE2MzMgMi4yNjE2OTcsLTUuMDkzNzQ3IDUuMDMxMjUsLTUuMDkzNzQ3IHoiLz4KPC9zdmc+Cg==);
  --jp-icon-r-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjE5NkYzIiBkPSJNNC40IDIuNWMxLjItLjEgMi45LS4zIDQuOS0uMyAyLjUgMCA0LjEuNCA1LjIgMS4zIDEgLjcgMS41IDEuOSAxLjUgMy41IDAgMi0xLjQgMy41LTIuOSA0LjEgMS4yLjQgMS43IDEuNiAyLjIgMyAuNiAxLjkgMSAzLjkgMS4zIDQuNmgtMy44Yy0uMy0uNC0uOC0xLjctMS4yLTMuN3MtMS4yLTIuNi0yLjYtMi42aC0uOXY2LjRINC40VjIuNXptMy43IDYuOWgxLjRjMS45IDAgMi45LS45IDIuOS0yLjNzLTEtMi4zLTIuOC0yLjNjLS43IDAtMS4zIDAtMS42LjJ2NC41aC4xdi0uMXoiLz4KPC9zdmc+Cg==);
  --jp-icon-react: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMTUwIDE1MCA1NDEuOSAyOTUuMyI+CiAgPGcgY2xhc3M9ImpwLWljb24tYnJhbmQyIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxREFGQiI+CiAgICA8cGF0aCBkPSJNNjY2LjMgMjk2LjVjMC0zMi41LTQwLjctNjMuMy0xMDMuMS04Mi40IDE0LjQtNjMuNiA4LTExNC4yLTIwLjItMTMwLjQtNi41LTMuOC0xNC4xLTUuNi0yMi40LTUuNnYyMi4zYzQuNiAwIDguMy45IDExLjQgMi42IDEzLjYgNy44IDE5LjUgMzcuNSAxNC45IDc1LjctMS4xIDkuNC0yLjkgMTkuMy01LjEgMjkuNC0xOS42LTQuOC00MS04LjUtNjMuNS0xMC45LTEzLjUtMTguNS0yNy41LTM1LjMtNDEuNi01MCAzMi42LTMwLjMgNjMuMi00Ni45IDg0LTQ2LjlWNzhjLTI3LjUgMC02My41IDE5LjYtOTkuOSA1My42LTM2LjQtMzMuOC03Mi40LTUzLjItOTkuOS01My4ydjIyLjNjMjAuNyAwIDUxLjQgMTYuNSA4NCA0Ni42LTE0IDE0LjctMjggMzEuNC00MS4zIDQ5LjktMjIuNiAyLjQtNDQgNi4xLTYzLjYgMTEtMi4zLTEwLTQtMTkuNy01LjItMjktNC43LTM4LjIgMS4xLTY3LjkgMTQuNi03NS44IDMtMS44IDYuOS0yLjYgMTEuNS0yLjZWNzguNWMtOC40IDAtMTYgMS44LTIyLjYgNS42LTI4LjEgMTYuMi0zNC40IDY2LjctMTkuOSAxMzAuMS02Mi4yIDE5LjItMTAyLjcgNDkuOS0xMDIuNyA4Mi4zIDAgMzIuNSA0MC43IDYzLjMgMTAzLjEgODIuNC0xNC40IDYzLjYtOCAxMTQuMiAyMC4yIDEzMC40IDYuNSAzLjggMTQuMSA1LjYgMjIuNSA1LjYgMjcuNSAwIDYzLjUtMTkuNiA5OS45LTUzLjYgMzYuNCAzMy44IDcyLjQgNTMuMiA5OS45IDUzLjIgOC40IDAgMTYtMS44IDIyLjYtNS42IDI4LjEtMTYuMiAzNC40LTY2LjcgMTkuOS0xMzAuMSA2Mi0xOS4xIDEwMi41LTQ5LjkgMTAyLjUtODIuM3ptLTEzMC4yLTY2LjdjLTMuNyAxMi45LTguMyAyNi4yLTEzLjUgMzkuNS00LjEtOC04LjQtMTYtMTMuMS0yNC00LjYtOC05LjUtMTUuOC0xNC40LTIzLjQgMTQuMiAyLjEgMjcuOSA0LjcgNDEgNy45em0tNDUuOCAxMDYuNWMtNy44IDEzLjUtMTUuOCAyNi4zLTI0LjEgMzguMi0xNC45IDEuMy0zMCAyLTQ1LjIgMi0xNS4xIDAtMzAuMi0uNy00NS0xLjktOC4zLTExLjktMTYuNC0yNC42LTI0LjItMzgtNy42LTEzLjEtMTQuNS0yNi40LTIwLjgtMzkuOCA2LjItMTMuNCAxMy4yLTI2LjggMjAuNy0zOS45IDcuOC0xMy41IDE1LjgtMjYuMyAyNC4xLTM4LjIgMTQuOS0xLjMgMzAtMiA0NS4yLTIgMTUuMSAwIDMwLjIuNyA0NSAxLjkgOC4zIDExLjkgMTYuNCAyNC42IDI0LjIgMzggNy42IDEzLjEgMTQuNSAyNi40IDIwLjggMzkuOC02LjMgMTMuNC0xMy4yIDI2LjgtMjAuNyAzOS45em0zMi4zLTEzYzUuNCAxMy40IDEwIDI2LjggMTMuOCAzOS44LTEzLjEgMy4yLTI2LjkgNS45LTQxLjIgOCA0LjktNy43IDkuOC0xNS42IDE0LjQtMjMuNyA0LjYtOCA4LjktMTYuMSAxMy0yNC4xek00MjEuMiA0MzBjLTkuMy05LjYtMTguNi0yMC4zLTI3LjgtMzIgOSAuNCAxOC4yLjcgMjcuNS43IDkuNCAwIDE4LjctLjIgMjcuOC0uNy05IDExLjctMTguMyAyMi40LTI3LjUgMzJ6bS03NC40LTU4LjljLTE0LjItMi4xLTI3LjktNC43LTQxLTcuOSAzLjctMTIuOSA4LjMtMjYuMiAxMy41LTM5LjUgNC4xIDggOC40IDE2IDEzLjEgMjQgNC43IDggOS41IDE1LjggMTQuNCAyMy40ek00MjAuNyAxNjNjOS4zIDkuNiAxOC42IDIwLjMgMjcuOCAzMi05LS40LTE4LjItLjctMjcuNS0uNy05LjQgMC0xOC43LjItMjcuOC43IDktMTEuNyAxOC4zLTIyLjQgMjcuNS0zMnptLTc0IDU4LjljLTQuOSA3LjctOS44IDE1LjYtMTQuNCAyMy43LTQuNiA4LTguOSAxNi0xMyAyNC01LjQtMTMuNC0xMC0yNi44LTEzLjgtMzkuOCAxMy4xLTMuMSAyNi45LTUuOCA0MS4yLTcuOXptLTkwLjUgMTI1LjJjLTM1LjQtMTUuMS01OC4zLTM0LjktNTguMy01MC42IDAtMTUuNyAyMi45LTM1LjYgNTguMy01MC42IDguNi0zLjcgMTgtNyAyNy43LTEwLjEgNS43IDE5LjYgMTMuMiA0MCAyMi41IDYwLjktOS4yIDIwLjgtMTYuNiA0MS4xLTIyLjIgNjAuNi05LjktMy4xLTE5LjMtNi41LTI4LTEwLjJ6TTMxMCA0OTBjLTEzLjYtNy44LTE5LjUtMzcuNS0xNC45LTc1LjcgMS4xLTkuNCAyLjktMTkuMyA1LjEtMjkuNCAxOS42IDQuOCA0MSA4LjUgNjMuNSAxMC45IDEzLjUgMTguNSAyNy41IDM1LjMgNDEuNiA1MC0zMi42IDMwLjMtNjMuMiA0Ni45LTg0IDQ2LjktNC41LS4xLTguMy0xLTExLjMtMi43em0yMzcuMi03Ni4yYzQuNyAzOC4yLTEuMSA2Ny45LTE0LjYgNzUuOC0zIDEuOC02LjkgMi42LTExLjUgMi42LTIwLjcgMC01MS40LTE2LjUtODQtNDYuNiAxNC0xNC43IDI4LTMxLjQgNDEuMy00OS45IDIyLjYtMi40IDQ0LTYuMSA2My42LTExIDIuMyAxMC4xIDQuMSAxOS44IDUuMiAyOS4xem0zOC41LTY2LjdjLTguNiAzLjctMTggNy0yNy43IDEwLjEtNS43LTE5LjYtMTMuMi00MC0yMi41LTYwLjkgOS4yLTIwLjggMTYuNi00MS4xIDIyLjItNjAuNiA5LjkgMy4xIDE5LjMgNi41IDI4LjEgMTAuMiAzNS40IDE1LjEgNTguMyAzNC45IDU4LjMgNTAuNi0uMSAxNS43LTIzIDM1LjYtNTguNCA1MC42ek0zMjAuOCA3OC40eiIvPgogICAgPGNpcmNsZSBjeD0iNDIwLjkiIGN5PSIyOTYuNSIgcj0iNDUuNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-redo: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE4LjQgMTAuNkMxNi41NSA4Ljk5IDE0LjE1IDggMTEuNSA4Yy00LjY1IDAtOC41OCAzLjAzLTkuOTYgNy4yMkwzLjkgMTZjMS4wNS0zLjE5IDQuMDUtNS41IDcuNi01LjUgMS45NSAwIDMuNzMuNzIgNS4xMiAxLjg4TDEzIDE2aDlWN2wtMy42IDMuNnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-refresh: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTkgMTMuNWMtMi40OSAwLTQuNS0yLjAxLTQuNS00LjVTNi41MSA0LjUgOSA0LjVjMS4yNCAwIDIuMzYuNTIgMy4xNyAxLjMzTDEwIDhoNVYzbC0xLjc2IDEuNzZDMTIuMTUgMy42OCAxMC42NiAzIDkgMyA1LjY5IDMgMy4wMSA1LjY5IDMuMDEgOVM1LjY5IDE1IDkgMTVjMi45NyAwIDUuNDMtMi4xNiA1LjktNWgtMS41MmMtLjQ2IDItMi4yNCAzLjUtNC4zOCAzLjV6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-regex: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiBmaWxsPSIjRkZGIj4KICAgIDxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjUuNSIgY3k9IjE0LjUiIHI9IjEuNSIvPgogICAgPHJlY3QgeD0iMTIiIHk9IjQiIGNsYXNzPSJzdDIiIHdpZHRoPSIxIiBoZWlnaHQ9IjgiLz4KICAgIDxyZWN0IHg9IjguNSIgeT0iNy41IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg2NiAtMC41IDAuNSAwLjg2NiAtMi4zMjU1IDcuMzIxOSkiIGNsYXNzPSJzdDIiIHdpZHRoPSI4IiBoZWlnaHQ9IjEiLz4KICAgIDxyZWN0IHg9IjEyIiB5PSI0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjUgLTAuODY2IDAuODY2IDAuNSAtMC42Nzc5IDE0LjgyNTIpIiBjbGFzcz0ic3QyIiB3aWR0aD0iMSIgaGVpZ2h0PSI4Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-run: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTggNXYxNGwxMS03eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-running: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMjU2IDhDMTE5IDggOCAxMTkgOCAyNTZzMTExIDI0OCAyNDggMjQ4IDI0OC0xMTEgMjQ4LTI0OFMzOTMgOCAyNTYgOHptOTYgMzI4YzAgOC44LTcuMiAxNi0xNiAxNkgxNzZjLTguOCAwLTE2LTcuMi0xNi0xNlYxNzZjMC04LjggNy4yLTE2IDE2LTE2aDE2MGM4LjggMCAxNiA3LjIgMTYgMTZ2MTYweiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-save: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE3IDNINWMtMS4xMSAwLTIgLjktMiAydjE0YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjdsLTQtNHptLTUgMTZjLTEuNjYgMC0zLTEuMzQtMy0zczEuMzQtMyAzLTMgMyAxLjM0IDMgMy0xLjM0IDMtMyAzem0zLTEwSDVWNWgxMHY0eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-search: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjEsMTAuOWgtMC43bC0wLjItMC4yYzAuOC0wLjksMS4zLTIuMiwxLjMtMy41YzAtMy0yLjQtNS40LTUuNC01LjRTMS44LDQuMiwxLjgsNy4xczIuNCw1LjQsNS40LDUuNCBjMS4zLDAsMi41LTAuNSwzLjUtMS4zbDAuMiwwLjJ2MC43bDQuMSw0LjFsMS4yLTEuMkwxMi4xLDEwLjl6IE03LjEsMTAuOWMtMi4xLDAtMy43LTEuNy0zLjctMy43czEuNy0zLjcsMy43LTMuN3MzLjcsMS43LDMuNywzLjcgUzkuMiwxMC45LDcuMSwxMC45eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-settings: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuNDMgMTIuOThjLjA0LS4zMi4wNy0uNjQuMDctLjk4cy0uMDMtLjY2LS4wNy0uOThsMi4xMS0xLjY1Yy4xOS0uMTUuMjQtLjQyLjEyLS42NGwtMi0zLjQ2Yy0uMTItLjIyLS4zOS0uMy0uNjEtLjIybC0yLjQ5IDFjLS41Mi0uNC0xLjA4LS43My0xLjY5LS45OGwtLjM4LTIuNjVBLjQ4OC40ODggMCAwMDE0IDJoLTRjLS4yNSAwLS40Ni4xOC0uNDkuNDJsLS4zOCAyLjY1Yy0uNjEuMjUtMS4xNy41OS0xLjY5Ljk4bC0yLjQ5LTFjLS4yMy0uMDktLjQ5IDAtLjYxLjIybC0yIDMuNDZjLS4xMy4yMi0uMDcuNDkuMTIuNjRsMi4xMSAxLjY1Yy0uMDQuMzItLjA3LjY1LS4wNy45OHMuMDMuNjYuMDcuOThsLTIuMTEgMS42NWMtLjE5LjE1LS4yNC40Mi0uMTIuNjRsMiAzLjQ2Yy4xMi4yMi4zOS4zLjYxLjIybDIuNDktMWMuNTIuNCAxLjA4LjczIDEuNjkuOThsLjM4IDIuNjVjLjAzLjI0LjI0LjQyLjQ5LjQyaDRjLjI1IDAgLjQ2LS4xOC40OS0uNDJsLjM4LTIuNjVjLjYxLS4yNSAxLjE3LS41OSAxLjY5LS45OGwyLjQ5IDFjLjIzLjA5LjQ5IDAgLjYxLS4yMmwyLTMuNDZjLjEyLS4yMi4wNy0uNDktLjEyLS42NGwtMi4xMS0xLjY1ek0xMiAxNS41Yy0xLjkzIDAtMy41LTEuNTctMy41LTMuNXMxLjU3LTMuNSAzLjUtMy41IDMuNSAxLjU3IDMuNSAzLjUtMS41NyAzLjUtMy41IDMuNXoiLz4KPC9zdmc+Cg==);
  --jp-icon-share: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTSAxOCAyIEMgMTYuMzU0OTkgMiAxNSAzLjM1NDk5MDQgMTUgNSBDIDE1IDUuMTkwOTUyOSAxNS4wMjE3OTEgNS4zNzcxMjI0IDE1LjA1NjY0MSA1LjU1ODU5MzggTCA3LjkyMTg3NSA5LjcyMDcwMzEgQyA3LjM5ODUzOTkgOS4yNzc4NTM5IDYuNzMyMDc3MSA5IDYgOSBDIDQuMzU0OTkwNCA5IDMgMTAuMzU0OTkgMyAxMiBDIDMgMTMuNjQ1MDEgNC4zNTQ5OTA0IDE1IDYgMTUgQyA2LjczMjA3NzEgMTUgNy4zOTg1Mzk5IDE0LjcyMjE0NiA3LjkyMTg3NSAxNC4yNzkyOTcgTCAxNS4wNTY2NDEgMTguNDM5NDUzIEMgMTUuMDIxNTU1IDE4LjYyMTUxNCAxNSAxOC44MDgzODYgMTUgMTkgQyAxNSAyMC42NDUwMSAxNi4zNTQ5OSAyMiAxOCAyMiBDIDE5LjY0NTAxIDIyIDIxIDIwLjY0NTAxIDIxIDE5IEMgMjEgMTcuMzU0OTkgMTkuNjQ1MDEgMTYgMTggMTYgQyAxNy4yNjc0OCAxNiAxNi42MDE1OTMgMTYuMjc5MzI4IDE2LjA3ODEyNSAxNi43MjI2NTYgTCA4Ljk0MzM1OTQgMTIuNTU4NTk0IEMgOC45NzgyMDk1IDEyLjM3NzEyMiA5IDEyLjE5MDk1MyA5IDEyIEMgOSAxMS44MDkwNDcgOC45NzgyMDk1IDExLjYyMjg3OCA4Ljk0MzM1OTQgMTEuNDQxNDA2IEwgMTYuMDc4MTI1IDcuMjc5Mjk2OSBDIDE2LjYwMTQ2IDcuNzIyMTQ2MSAxNy4yNjc5MjMgOCAxOCA4IEMgMTkuNjQ1MDEgOCAyMSA2LjY0NTAwOTYgMjEgNSBDIDIxIDMuMzU0OTkwNCAxOS42NDUwMSAyIDE4IDIgeiBNIDE4IDQgQyAxOC41NjQxMjkgNCAxOSA0LjQzNTg3MDYgMTkgNSBDIDE5IDUuNTY0MTI5NCAxOC41NjQxMjkgNiAxOCA2IEMgMTcuNDM1ODcxIDYgMTcgNS41NjQxMjk0IDE3IDUgQyAxNyA0LjQzNTg3MDYgMTcuNDM1ODcxIDQgMTggNCB6IE0gNiAxMSBDIDYuNTY0MTI5NCAxMSA3IDExLjQzNTg3MSA3IDEyIEMgNyAxMi41NjQxMjkgNi41NjQxMjk0IDEzIDYgMTMgQyA1LjQzNTg3MDYgMTMgNSAxMi41NjQxMjkgNSAxMiBDIDUgMTEuNDM1ODcxIDUuNDM1ODcwNiAxMSA2IDExIHogTSAxOCAxOCBDIDE4LjU2NDEyOSAxOCAxOSAxOC40MzU4NzEgMTkgMTkgQyAxOSAxOS41NjQxMjkgMTguNTY0MTI5IDIwIDE4IDIwIEMgMTcuNDM1ODcxIDIwIDE3IDE5LjU2NDEyOSAxNyAxOSBDIDE3IDE4LjQzNTg3MSAxNy40MzU4NzEgMTggMTggMTggeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-spreadsheet: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNENBRjUwIiBkPSJNMi4yIDIuMnYxNy42aDE3LjZWMi4ySDIuMnptMTUuNCA3LjdoLTUuNVY0LjRoNS41djUuNXpNOS45IDQuNHY1LjVINC40VjQuNGg1LjV6bS01LjUgNy43aDUuNXY1LjVINC40di01LjV6bTcuNyA1LjV2LTUuNWg1LjV2NS41aC01LjV6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-stop: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tab: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDNWNWgxMHY0aDh2MTB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-table-rows: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMSw4SDNWNGgxOFY4eiBNMjEsMTBIM3Y0aDE4VjEweiBNMjEsMTZIM3Y0aDE4VjE2eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-tag: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCA0MyAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTI4LjgzMzIgMTIuMzM0TDMyLjk5OTggMTYuNTAwN0wzNy4xNjY1IDEyLjMzNEgyOC44MzMyWiIvPgoJCTxwYXRoIGQ9Ik0xNi4yMDk1IDIxLjYxMDRDMTUuNjg3MyAyMi4xMjk5IDE0Ljg0NDMgMjIuMTI5OSAxNC4zMjQ4IDIxLjYxMDRMNi45ODI5IDE0LjcyNDVDNi41NzI0IDE0LjMzOTQgNi4wODMxMyAxMy42MDk4IDYuMDQ3ODYgMTMuMDQ4MkM1Ljk1MzQ3IDExLjUyODggNi4wMjAwMiA4LjYxOTQ0IDYuMDY2MjEgNy4wNzY5NUM2LjA4MjgxIDYuNTE0NzcgNi41NTU0OCA2LjA0MzQ3IDcuMTE4MDQgNi4wMzA1NUM5LjA4ODYzIDUuOTg0NzMgMTMuMjYzOCA1LjkzNTc5IDEzLjY1MTggNi4zMjQyNUwyMS43MzY5IDEzLjYzOUMyMi4yNTYgMTQuMTU4NSAyMS43ODUxIDE1LjQ3MjQgMjEuMjYyIDE1Ljk5NDZMMTYuMjA5NSAyMS42MTA0Wk05Ljc3NTg1IDguMjY1QzkuMzM1NTEgNy44MjU2NiA4LjYyMzUxIDcuODI1NjYgOC4xODI4IDguMjY1QzcuNzQzNDYgOC43MDU3MSA3Ljc0MzQ2IDkuNDE3MzMgOC4xODI4IDkuODU2NjdDOC42MjM4MiAxMC4yOTY0IDkuMzM1ODIgMTAuMjk2NCA5Ljc3NTg1IDkuODU2NjdDMTAuMjE1NiA5LjQxNzMzIDEwLjIxNTYgOC43MDUzMyA5Ljc3NTg1IDguMjY1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-terminal: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiA+CiAgICA8cmVjdCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1iYWNrZ3JvdW5kLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyIDIpIiBmaWxsPSIjMzMzMzMzIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUtaW52ZXJzZSIgZD0iTTUuMDU2NjQgOC43NjE3MkM1LjA1NjY0IDguNTk3NjYgNS4wMzEyNSA4LjQ1MzEyIDQuOTgwNDcgOC4zMjgxMkM0LjkzMzU5IDguMTk5MjIgNC44NTU0NyA4LjA4MjAzIDQuNzQ2MDkgNy45NzY1NkM0LjY0MDYyIDcuODcxMDkgNC41IDcuNzc1MzkgNC4zMjQyMiA3LjY4OTQ1QzQuMTUyMzQgNy41OTk2MSAzLjk0MzM2IDcuNTExNzIgMy42OTcyNyA3LjQyNTc4QzMuMzAyNzMgNy4yODUxNiAyLjk0MzM2IDcuMTM2NzIgMi42MTkxNCA2Ljk4MDQ3QzIuMjk0OTIgNi44MjQyMiAyLjAxNzU4IDYuNjQyNTggMS43ODcxMSA2LjQzNTU1QzEuNTYwNTUgNi4yMjg1MiAxLjM4NDc3IDUuOTg4MjggMS4yNTk3NyA1LjcxNDg0QzEuMTM0NzcgNS40Mzc1IDEuMDcyMjcgNS4xMDkzOCAxLjA3MjI3IDQuNzMwNDdDMS4wNzIyNyA0LjM5ODQ0IDEuMTI4OTEgNC4wOTU3IDEuMjQyMTkgMy44MjIyN0MxLjM1NTQ3IDMuNTQ0OTIgMS41MTU2MiAzLjMwNDY5IDEuNzIyNjYgMy4xMDE1NkMxLjkyOTY5IDIuODk4NDQgMi4xNzk2OSAyLjczNDM3IDIuNDcyNjYgMi42MDkzOEMyLjc2NTYyIDIuNDg0MzggMy4wOTE4IDIuNDA0MyAzLjQ1MTE3IDIuMzY5MTRWMS4xMDkzOEg0LjM4ODY3VjIuMzgwODZDNC43NDAyMyAyLjQyNzczIDUuMDU2NjQgMi41MjM0NCA1LjMzNzg5IDIuNjY3OTdDNS42MTkxNCAyLjgxMjUgNS44NTc0MiAzLjAwMTk1IDYuMDUyNzMgMy4yMzYzM0M2LjI1MTk1IDMuNDY2OCA2LjQwNDMgMy43NDAyMyA2LjUwOTc3IDQuMDU2NjRDNi42MTkxNCA0LjM2OTE0IDYuNjczODMgNC43MjA3IDYuNjczODMgNS4xMTEzM0g1LjA0NDkyQzUuMDQ0OTIgNC42Mzg2NyA0LjkzNzUgNC4yODEyNSA0LjcyMjY2IDQuMDM5MDZDNC41MDc4MSAzLjc5Mjk3IDQuMjE2OCAzLjY2OTkyIDMuODQ5NjEgMy42Njk5MkMzLjY1MDM5IDMuNjY5OTIgMy40NzY1NiAzLjY5NzI3IDMuMzI4MTIgMy43NTE5NUMzLjE4MzU5IDMuODAyNzMgMy4wNjQ0NSAzLjg3Njk1IDIuOTcwNyAzLjk3NDYxQzIuODc2OTUgNC4wNjgzNiAyLjgwNjY0IDQuMTc5NjkgMi43NTk3NyA0LjMwODU5QzIuNzE2OCA0LjQzNzUgMi42OTUzMSA0LjU3ODEyIDIuNjk1MzEgNC43MzA0N0MyLjY5NTMxIDQuODgyODEgMi43MTY4IDUuMDE5NTMgMi43NTk3NyA1LjE0MDYyQzIuODA2NjQgNS4yNTc4MSAyLjg4MjgxIDUuMzY3MTkgMi45ODgyOCA1LjQ2ODc1QzMuMDk3NjYgNS41NzAzMSAzLjI0MDIzIDUuNjY3OTcgMy40MTYwMiA1Ljc2MTcyQzMuNTkxOCA1Ljg1MTU2IDMuODEwNTUgNS45NDMzNiA0LjA3MjI3IDYuMDM3MTFDNC40NjY4IDYuMTg1NTUgNC44MjQyMiA2LjMzOTg0IDUuMTQ0NTMgNi41QzUuNDY0ODQgNi42NTYyNSA1LjczODI4IDYuODM5ODQgNS45NjQ4NCA3LjA1MDc4QzYuMTk1MzEgNy4yNTc4MSA2LjM3MTA5IDcuNSA2LjQ5MjE5IDcuNzc3MzRDNi42MTcxOSA4LjA1MDc4IDYuNjc5NjkgOC4zNzUgNi42Nzk2OSA4Ljc1QzYuNjc5NjkgOS4wOTM3NSA2LjYyMzA1IDkuNDA0MyA2LjUwOTc3IDkuNjgxNjRDNi4zOTY0OCA5Ljk1NTA4IDYuMjM0MzggMTAuMTkxNCA2LjAyMzQ0IDEwLjM5MDZDNS44MTI1IDEwLjU4OTggNS41NTg1OSAxMC43NSA1LjI2MTcyIDEwLjg3MTFDNC45NjQ4NCAxMC45ODgzIDQuNjMyODEgMTEuMDY0NSA0LjI2NTYyIDExLjA5OTZWMTIuMjQ4SDMuMzMzOThWMTEuMDk5NkMzLjAwMTk1IDExLjA2ODQgMi42Nzk2OSAxMC45OTYxIDIuMzY3MTkgMTAuODgyOEMyLjA1NDY5IDEwLjc2NTYgMS43NzczNCAxMC41OTc3IDEuNTM1MTYgMTAuMzc4OUMxLjI5Njg4IDEwLjE2MDIgMS4xMDU0NyA5Ljg4NDc3IDAuOTYwOTM4IDkuNTUyNzNDMC44MTY0MDYgOS4yMTY4IDAuNzQ0MTQxIDguODE0NDUgMC43NDQxNDEgOC4zNDU3SDIuMzc4OTFDMi4zNzg5MSA4LjYyNjk1IDIuNDE5OTIgOC44NjMyOCAyLjUwMTk1IDkuMDU0NjlDMi41ODM5OCA5LjI0MjE5IDIuNjg5NDUgOS4zOTI1OCAyLjgxODM2IDkuNTA1ODZDMi45NTExNyA5LjYxNTIzIDMuMTAxNTYgOS42OTMzNiAzLjI2OTUzIDkuNzQwMjNDMy40Mzc1IDkuNzg3MTEgMy42MDkzOCA5LjgxMDU1IDMuNzg1MTYgOS44MTA1NUM0LjIwMzEyIDkuODEwNTUgNC41MTk1MyA5LjcxMjg5IDQuNzM0MzggOS41MTc1OEM0Ljk0OTIyIDkuMzIyMjcgNS4wNTY2NCA5LjA3MDMxIDUuMDU2NjQgOC43NjE3MlpNMTMuNDE4IDEyLjI3MTVIOC4wNzQyMlYxMUgxMy40MThWMTIuMjcxNVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuOTUyNjQgNikiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=);
  --jp-icon-text-editor: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtdGV4dC1lZGl0b3ItaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xNSAxNUgzdjJoMTJ2LTJ6bTAtOEgzdjJoMTJWN3pNMyAxM2gxOHYtMkgzdjJ6bTAgOGgxOHYtMkgzdjJ6TTMgM3YyaDE4VjNIM3oiLz4KPC9zdmc+Cg==);
  --jp-icon-toc: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik03LDVIMjFWN0g3VjVNNywxM1YxMUgyMVYxM0g3TTQsNC41QTEuNSwxLjUgMCAwLDEgNS41LDZBMS41LDEuNSAwIDAsMSA0LDcuNUExLjUsMS41IDAgMCwxIDIuNSw2QTEuNSwxLjUgMCAwLDEgNCw0LjVNNCwxMC41QTEuNSwxLjUgMCAwLDEgNS41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMy41QTEuNSwxLjUgMCAwLDEgMi41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMC41TTcsMTlWMTdIMjFWMTlIN000LDE2LjVBMS41LDEuNSAwIDAsMSA1LjUsMThBMS41LDEuNSAwIDAsMSA0LDE5LjVBMS41LDEuNSAwIDAsMSAyLjUsMThBMS41LDEuNSAwIDAsMSA0LDE2LjVaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tree-view: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMiAxMVYzaC03djNIOVYzSDJ2OGg3VjhoMnYxMGg0djNoN3YtOGgtN3YzaC0yVjhoMnYzeiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMiAxNy4xODQ0IDIuOTY5NjggMTQuMzAzMiAxLjg2MDk0IDExLjQ0MDlaIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiMzMzMzMzMiIHN0cm9rZT0iIzMzMzMzMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOCA5Ljg2NzE5KSIgZD0iTTIuODYwMTUgNC44NjUzNUwwLjcyNjU0OSAyLjk5OTU5TDAgMy42MzA0NUwyLjg2MDE1IDYuMTMxNTdMOCAwLjYzMDg3Mkw3LjI3ODU3IDBMMi44NjAxNSA0Ljg2NTM1WiIvPgo8L3N2Zz4K);
  --jp-icon-undo: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjUgOGMtMi42NSAwLTUuMDUuOTktNi45IDIuNkwyIDd2OWg5bC0zLjYyLTMuNjJjMS4zOS0xLjE2IDMuMTYtMS44OCA1LjEyLTEuODggMy41NCAwIDYuNTUgMi4zMSA3LjYgNS41bDIuMzctLjc4QzIxLjA4IDExLjAzIDE3LjE1IDggMTIuNSA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-user: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE2IDdhNCA0IDAgMTEtOCAwIDQgNCAwIDAxOCAwek0xMiAxNGE3IDcgMCAwMC03IDdoMTRhNyA3IDAgMDAtNy03eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-users: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDM2IDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogPGcgY2xhc3M9ImpwLWljb24zIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjczMjcgMCAwIDEuNzMyNyAtMy42MjgyIC4wOTk1NzcpIiBmaWxsPSIjNjE2MTYxIj4KICA8cGF0aCB0cmFuc2Zvcm09Im1hdHJpeCgxLjUsMCwwLDEuNSwwLC02KSIgZD0ibTEyLjE4NiA3LjUwOThjLTEuMDUzNSAwLTEuOTc1NyAwLjU2NjUtMi40Nzg1IDEuNDEwMiAwLjc1MDYxIDAuMzEyNzcgMS4zOTc0IDAuODI2NDggMS44NzMgMS40NzI3aDMuNDg2M2MwLTEuNTkyLTEuMjg4OS0yLjg4MjgtMi44ODA5LTIuODgyOHoiLz4KICA8cGF0aCBkPSJtMjAuNDY1IDIuMzg5NWEyLjE4ODUgMi4xODg1IDAgMCAxLTIuMTg4NCAyLjE4ODUgMi4xODg1IDIuMTg4NSAwIDAgMS0yLjE4ODUtMi4xODg1IDIuMTg4NSAyLjE4ODUgMCAwIDEgMi4xODg1LTIuMTg4NSAyLjE4ODUgMi4xODg1IDAgMCAxIDIuMTg4NCAyLjE4ODV6Ii8+CiAgPHBhdGggdHJhbnNmb3JtPSJtYXRyaXgoMS41LDAsMCwxLjUsMCwtNikiIGQ9Im0zLjU4OTggOC40MjE5Yy0xLjExMjYgMC0yLjAxMzcgMC45MDExMS0yLjAxMzcgMi4wMTM3aDIuODE0NWMwLjI2Nzk3LTAuMzczMDkgMC41OTA3LTAuNzA0MzUgMC45NTg5OC0wLjk3ODUyLTAuMzQ0MzMtMC42MTY4OC0xLjAwMzEtMS4wMzUyLTEuNzU5OC0xLjAzNTJ6Ii8+CiAgPHBhdGggZD0ibTYuOTE1NCA0LjYyM2ExLjUyOTQgMS41Mjk0IDAgMCAxLTEuNTI5NCAxLjUyOTQgMS41Mjk0IDEuNTI5NCAwIDAgMS0xLjUyOTQtMS41Mjk0IDEuNTI5NCAxLjUyOTQgMCAwIDEgMS41Mjk0LTEuNTI5NCAxLjUyOTQgMS41Mjk0IDAgMCAxIDEuNTI5NCAxLjUyOTR6Ii8+CiAgPHBhdGggZD0ibTYuMTM1IDEzLjUzNWMwLTMuMjM5MiAyLjYyNTktNS44NjUgNS44NjUtNS44NjUgMy4yMzkyIDAgNS44NjUgMi42MjU5IDUuODY1IDUuODY1eiIvPgogIDxjaXJjbGUgY3g9IjEyIiBjeT0iMy43Njg1IiByPSIyLjk2ODUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-vega: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbjEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjEyMTIxIj4KICAgIDxwYXRoIGQ9Ik0xMC42IDUuNGwyLjItMy4ySDIuMnY3LjNsNC02LjZ6Ii8+CiAgICA8cGF0aCBkPSJNMTUuOCAyLjJsLTQuNCA2LjZMNyA2LjNsLTQuOCA4djUuNWgxNy42VjIuMmgtNHptLTcgMTUuNEg1LjV2LTQuNGgzLjN2NC40em00LjQgMEg5LjhWOS44aDMuNHY3Ljh6bTQuNCAwaC0zLjRWNi41aDMuNHYxMS4xeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-word: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KIDxnIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzQxNDE0MSI+CiAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiA8L2c+CiA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSguNDMgLjA0MDEpIiBmaWxsPSIjZmZmIj4KICA8cGF0aCBkPSJtNC4xNCA4Ljc2cTAuMDY4Mi0xLjg5IDIuNDItMS44OSAxLjE2IDAgMS42OCAwLjQyIDAuNTY3IDAuNDEgMC41NjcgMS4xNnYzLjQ3cTAgMC40NjIgMC41MTQgMC40NjIgMC4xMDMgMCAwLjItMC4wMjMxdjAuNzE0cS0wLjM5OSAwLjEwMy0wLjY1MSAwLjEwMy0wLjQ1MiAwLTAuNjkzLTAuMjItMC4yMzEtMC4yLTAuMjg0LTAuNjYyLTAuOTU2IDAuODcyLTIgMC44NzItMC45MDMgMC0xLjQ3LTAuNDcyLTAuNTI1LTAuNDcyLTAuNTI1LTEuMjYgMC0wLjI2MiAwLjA0NTItMC40NzIgMC4wNTY3LTAuMjIgMC4xMTYtMC4zNzggMC4wNjgyLTAuMTY4IDAuMjMxLTAuMzA0IDAuMTU4LTAuMTQ3IDAuMjYyLTAuMjQyIDAuMTE2LTAuMDkxNCAwLjM2OC0wLjE2OCAwLjI2Mi0wLjA5MTQgMC4zOTktMC4xMjYgMC4xMzYtMC4wNDUyIDAuNDcyLTAuMTAzIDAuMzM2LTAuMDU3OCAwLjUwNC0wLjA3OTggMC4xNTgtMC4wMjMxIDAuNTY3LTAuMDc5OCAwLjU1Ni0wLjA2ODIgMC43NzctMC4yMjEgMC4yMi0wLjE1MiAwLjIyLTAuNDQxdi0wLjI1MnEwLTAuNDMtMC4zNTctMC42NjItMC4zMzYtMC4yMzEtMC45NzYtMC4yMzEtMC42NjIgMC0wLjk5OCAwLjI2Mi0wLjMzNiAwLjI1Mi0wLjM5OSAwLjc5OHptMS44OSAzLjY4cTAuNzg4IDAgMS4yNi0wLjQxIDAuNTA0LTAuNDIgMC41MDQtMC45MDN2LTEuMDVxLTAuMjg0IDAuMTM2LTAuODYxIDAuMjMxLTAuNTY3IDAuMDkxNC0wLjk4NyAwLjE1OC0wLjQyIDAuMDY4Mi0wLjc2NiAwLjMyNi0wLjMzNiAwLjI1Mi0wLjMzNiAwLjcwNHQwLjMwNCAwLjcwNCAwLjg2MSAwLjI1MnoiIHN0cm9rZS13aWR0aD0iMS4wNSIvPgogIDxwYXRoIGQ9Im0xMCA0LjU2aDAuOTQ1djMuMTVxMC42NTEtMC45NzYgMS44OS0wLjk3NiAxLjE2IDAgMS44OSAwLjg0IDAuNjgyIDAuODQgMC42ODIgMi4zMSAwIDEuNDctMC43MDQgMi40Mi0wLjcwNCAwLjg4Mi0xLjg5IDAuODgyLTEuMjYgMC0xLjg5LTEuMDJ2MC43NjZoLTAuODV6bTIuNjIgMy4wNHEtMC43NDYgMC0xLjE2IDAuNjQtMC40NTIgMC42My0wLjQ1MiAxLjY4IDAgMS4wNSAwLjQ1MiAxLjY4dDEuMTYgMC42M3EwLjc3NyAwIDEuMjYtMC42MyAwLjQ5NC0wLjY0IDAuNDk0LTEuNjggMC0xLjA1LTAuNDcyLTEuNjgtMC40NjItMC42NC0xLjI2LTAuNjR6IiBzdHJva2Utd2lkdGg9IjEuMDUiLz4KICA8cGF0aCBkPSJtMi43MyAxNS44IDEzLjYgMC4wMDgxYzAuMDA2OSAwIDAtMi42IDAtMi42IDAtMC4wMDc4LTEuMTUgMC0xLjE1IDAtMC4wMDY5IDAtMC4wMDgzIDEuNS0wLjAwODMgMS41LTJlLTMgLTAuMDAxNC0xMS4zLTAuMDAxNC0xMS4zLTAuMDAxNGwtMC4wMDU5Mi0xLjVjMC0wLjAwNzgtMS4xNyAwLjAwMTMtMS4xNyAwLjAwMTN6IiBzdHJva2Utd2lkdGg9Ii45NzUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-yaml: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1jb250cmFzdDIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjRDgxQjYwIj4KICAgIDxwYXRoIGQ9Ik03LjIgMTguNnYtNS40TDMgNS42aDMuM2wxLjQgMy4xYy4zLjkuNiAxLjYgMSAyLjUuMy0uOC42LTEuNiAxLTIuNWwxLjQtMy4xaDMuNGwtNC40IDcuNnY1LjVsLTIuOS0uMXoiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxNi41IiByPSIyLjEiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxMSIgcj0iMi4xIi8+CiAgPC9nPgo8L3N2Zz4K);
}

/* Icon CSS class declarations */

.jp-AddAboveIcon {
  background-image: var(--jp-icon-add-above);
}

.jp-AddBelowIcon {
  background-image: var(--jp-icon-add-below);
}

.jp-AddIcon {
  background-image: var(--jp-icon-add);
}

.jp-BellIcon {
  background-image: var(--jp-icon-bell);
}

.jp-BugDotIcon {
  background-image: var(--jp-icon-bug-dot);
}

.jp-BugIcon {
  background-image: var(--jp-icon-bug);
}

.jp-BuildIcon {
  background-image: var(--jp-icon-build);
}

.jp-CaretDownEmptyIcon {
  background-image: var(--jp-icon-caret-down-empty);
}

.jp-CaretDownEmptyThinIcon {
  background-image: var(--jp-icon-caret-down-empty-thin);
}

.jp-CaretDownIcon {
  background-image: var(--jp-icon-caret-down);
}

.jp-CaretLeftIcon {
  background-image: var(--jp-icon-caret-left);
}

.jp-CaretRightIcon {
  background-image: var(--jp-icon-caret-right);
}

.jp-CaretUpEmptyThinIcon {
  background-image: var(--jp-icon-caret-up-empty-thin);
}

.jp-CaretUpIcon {
  background-image: var(--jp-icon-caret-up);
}

.jp-CaseSensitiveIcon {
  background-image: var(--jp-icon-case-sensitive);
}

.jp-CheckIcon {
  background-image: var(--jp-icon-check);
}

.jp-CircleEmptyIcon {
  background-image: var(--jp-icon-circle-empty);
}

.jp-CircleIcon {
  background-image: var(--jp-icon-circle);
}

.jp-ClearIcon {
  background-image: var(--jp-icon-clear);
}

.jp-CloseIcon {
  background-image: var(--jp-icon-close);
}

.jp-CodeCheckIcon {
  background-image: var(--jp-icon-code-check);
}

.jp-CodeIcon {
  background-image: var(--jp-icon-code);
}

.jp-CollapseAllIcon {
  background-image: var(--jp-icon-collapse-all);
}

.jp-ConsoleIcon {
  background-image: var(--jp-icon-console);
}

.jp-CopyIcon {
  background-image: var(--jp-icon-copy);
}

.jp-CopyrightIcon {
  background-image: var(--jp-icon-copyright);
}

.jp-CutIcon {
  background-image: var(--jp-icon-cut);
}

.jp-DeleteIcon {
  background-image: var(--jp-icon-delete);
}

.jp-DownloadIcon {
  background-image: var(--jp-icon-download);
}

.jp-DuplicateIcon {
  background-image: var(--jp-icon-duplicate);
}

.jp-EditIcon {
  background-image: var(--jp-icon-edit);
}

.jp-EllipsesIcon {
  background-image: var(--jp-icon-ellipses);
}

.jp-ErrorIcon {
  background-image: var(--jp-icon-error);
}

.jp-ExpandAllIcon {
  background-image: var(--jp-icon-expand-all);
}

.jp-ExtensionIcon {
  background-image: var(--jp-icon-extension);
}

.jp-FastForwardIcon {
  background-image: var(--jp-icon-fast-forward);
}

.jp-FileIcon {
  background-image: var(--jp-icon-file);
}

.jp-FileUploadIcon {
  background-image: var(--jp-icon-file-upload);
}

.jp-FilterDotIcon {
  background-image: var(--jp-icon-filter-dot);
}

.jp-FilterIcon {
  background-image: var(--jp-icon-filter);
}

.jp-FilterListIcon {
  background-image: var(--jp-icon-filter-list);
}

.jp-FolderFavoriteIcon {
  background-image: var(--jp-icon-folder-favorite);
}

.jp-FolderIcon {
  background-image: var(--jp-icon-folder);
}

.jp-HomeIcon {
  background-image: var(--jp-icon-home);
}

.jp-Html5Icon {
  background-image: var(--jp-icon-html5);
}

.jp-ImageIcon {
  background-image: var(--jp-icon-image);
}

.jp-InfoIcon {
  background-image: var(--jp-icon-info);
}

.jp-InspectorIcon {
  background-image: var(--jp-icon-inspector);
}

.jp-JsonIcon {
  background-image: var(--jp-icon-json);
}

.jp-JuliaIcon {
  background-image: var(--jp-icon-julia);
}

.jp-JupyterFaviconIcon {
  background-image: var(--jp-icon-jupyter-favicon);
}

.jp-JupyterIcon {
  background-image: var(--jp-icon-jupyter);
}

.jp-JupyterlabWordmarkIcon {
  background-image: var(--jp-icon-jupyterlab-wordmark);
}

.jp-KernelIcon {
  background-image: var(--jp-icon-kernel);
}

.jp-KeyboardIcon {
  background-image: var(--jp-icon-keyboard);
}

.jp-LaunchIcon {
  background-image: var(--jp-icon-launch);
}

.jp-LauncherIcon {
  background-image: var(--jp-icon-launcher);
}

.jp-LineFormIcon {
  background-image: var(--jp-icon-line-form);
}

.jp-LinkIcon {
  background-image: var(--jp-icon-link);
}

.jp-ListIcon {
  background-image: var(--jp-icon-list);
}

.jp-MarkdownIcon {
  background-image: var(--jp-icon-markdown);
}

.jp-MoveDownIcon {
  background-image: var(--jp-icon-move-down);
}

.jp-MoveUpIcon {
  background-image: var(--jp-icon-move-up);
}

.jp-NewFolderIcon {
  background-image: var(--jp-icon-new-folder);
}

.jp-NotTrustedIcon {
  background-image: var(--jp-icon-not-trusted);
}

.jp-NotebookIcon {
  background-image: var(--jp-icon-notebook);
}

.jp-NumberingIcon {
  background-image: var(--jp-icon-numbering);
}

.jp-OfflineBoltIcon {
  background-image: var(--jp-icon-offline-bolt);
}

.jp-PaletteIcon {
  background-image: var(--jp-icon-palette);
}

.jp-PasteIcon {
  background-image: var(--jp-icon-paste);
}

.jp-PdfIcon {
  background-image: var(--jp-icon-pdf);
}

.jp-PythonIcon {
  background-image: var(--jp-icon-python);
}

.jp-RKernelIcon {
  background-image: var(--jp-icon-r-kernel);
}

.jp-ReactIcon {
  background-image: var(--jp-icon-react);
}

.jp-RedoIcon {
  background-image: var(--jp-icon-redo);
}

.jp-RefreshIcon {
  background-image: var(--jp-icon-refresh);
}

.jp-RegexIcon {
  background-image: var(--jp-icon-regex);
}

.jp-RunIcon {
  background-image: var(--jp-icon-run);
}

.jp-RunningIcon {
  background-image: var(--jp-icon-running);
}

.jp-SaveIcon {
  background-image: var(--jp-icon-save);
}

.jp-SearchIcon {
  background-image: var(--jp-icon-search);
}

.jp-SettingsIcon {
  background-image: var(--jp-icon-settings);
}

.jp-ShareIcon {
  background-image: var(--jp-icon-share);
}

.jp-SpreadsheetIcon {
  background-image: var(--jp-icon-spreadsheet);
}

.jp-StopIcon {
  background-image: var(--jp-icon-stop);
}

.jp-TabIcon {
  background-image: var(--jp-icon-tab);
}

.jp-TableRowsIcon {
  background-image: var(--jp-icon-table-rows);
}

.jp-TagIcon {
  background-image: var(--jp-icon-tag);
}

.jp-TerminalIcon {
  background-image: var(--jp-icon-terminal);
}

.jp-TextEditorIcon {
  background-image: var(--jp-icon-text-editor);
}

.jp-TocIcon {
  background-image: var(--jp-icon-toc);
}

.jp-TreeViewIcon {
  background-image: var(--jp-icon-tree-view);
}

.jp-TrustedIcon {
  background-image: var(--jp-icon-trusted);
}

.jp-UndoIcon {
  background-image: var(--jp-icon-undo);
}

.jp-UserIcon {
  background-image: var(--jp-icon-user);
}

.jp-UsersIcon {
  background-image: var(--jp-icon-users);
}

.jp-VegaIcon {
  background-image: var(--jp-icon-vega);
}

.jp-WordIcon {
  background-image: var(--jp-icon-word);
}

.jp-YamlIcon {
  background-image: var(--jp-icon-yaml);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

.jp-Icon,
.jp-MaterialIcon {
  background-position: center;
  background-repeat: no-repeat;
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-cover {
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
}

/**
 * (DEPRECATED) Support for specific CSS icon sizes
 */

.jp-Icon-16 {
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-18 {
  background-size: 18px;
  min-width: 18px;
  min-height: 18px;
}

.jp-Icon-20 {
  background-size: 20px;
  min-width: 20px;
  min-height: 20px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.lm-TabBar .lm-TabBar-addButton {
  align-items: center;
  display: flex;
  padding: 4px;
  padding-bottom: 5px;
  margin-right: 1px;
  background-color: var(--jp-layout-color2);
}

.lm-TabBar .lm-TabBar-addButton:hover {
  background-color: var(--jp-layout-color1);
}

.lm-DockPanel-tabBar .lm-TabBar-tab {
  width: var(--jp-private-horizontal-tab-width);
}

.lm-DockPanel-tabBar .lm-TabBar-content {
  flex: unset;
}

.lm-DockPanel-tabBar[data-orientation='horizontal'] {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for icons as inline SVG HTMLElements
 */

/* recolor the primary elements of an icon */
.jp-icon0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-accent0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-accent1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-accent2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-accent3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-accent4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-accent0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-accent1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-accent2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-accent3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-accent4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-none[fill] {
  fill: none;
}

.jp-icon-none[stroke] {
  stroke: none;
}

/* brand icon colors. Same for light and dark */
.jp-icon-brand0[fill] {
  fill: var(--jp-brand-color0);
}

.jp-icon-brand1[fill] {
  fill: var(--jp-brand-color1);
}

.jp-icon-brand2[fill] {
  fill: var(--jp-brand-color2);
}

.jp-icon-brand3[fill] {
  fill: var(--jp-brand-color3);
}

.jp-icon-brand4[fill] {
  fill: var(--jp-brand-color4);
}

.jp-icon-brand0[stroke] {
  stroke: var(--jp-brand-color0);
}

.jp-icon-brand1[stroke] {
  stroke: var(--jp-brand-color1);
}

.jp-icon-brand2[stroke] {
  stroke: var(--jp-brand-color2);
}

.jp-icon-brand3[stroke] {
  stroke: var(--jp-brand-color3);
}

.jp-icon-brand4[stroke] {
  stroke: var(--jp-brand-color4);
}

/* warn icon colors. Same for light and dark */
.jp-icon-warn0[fill] {
  fill: var(--jp-warn-color0);
}

.jp-icon-warn1[fill] {
  fill: var(--jp-warn-color1);
}

.jp-icon-warn2[fill] {
  fill: var(--jp-warn-color2);
}

.jp-icon-warn3[fill] {
  fill: var(--jp-warn-color3);
}

.jp-icon-warn0[stroke] {
  stroke: var(--jp-warn-color0);
}

.jp-icon-warn1[stroke] {
  stroke: var(--jp-warn-color1);
}

.jp-icon-warn2[stroke] {
  stroke: var(--jp-warn-color2);
}

.jp-icon-warn3[stroke] {
  stroke: var(--jp-warn-color3);
}

/* icon colors that contrast well with each other and most backgrounds */
.jp-icon-contrast0[fill] {
  fill: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[fill] {
  fill: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[fill] {
  fill: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[fill] {
  fill: var(--jp-icon-contrast-color3);
}

.jp-icon-contrast0[stroke] {
  stroke: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[stroke] {
  stroke: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[stroke] {
  stroke: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[stroke] {
  stroke: var(--jp-icon-contrast-color3);
}

.jp-icon-dot[fill] {
  fill: var(--jp-warn-color0);
}

.jp-jupyter-icon-color[fill] {
  fill: var(--jp-jupyter-icon-color, var(--jp-warn-color0));
}

.jp-notebook-icon-color[fill] {
  fill: var(--jp-notebook-icon-color, var(--jp-warn-color0));
}

.jp-json-icon-color[fill] {
  fill: var(--jp-json-icon-color, var(--jp-warn-color1));
}

.jp-console-icon-color[fill] {
  fill: var(--jp-console-icon-color, white);
}

.jp-console-icon-background-color[fill] {
  fill: var(--jp-console-icon-background-color, var(--jp-brand-color1));
}

.jp-terminal-icon-color[fill] {
  fill: var(--jp-terminal-icon-color, var(--jp-layout-color2));
}

.jp-terminal-icon-background-color[fill] {
  fill: var(
    --jp-terminal-icon-background-color,
    var(--jp-inverse-layout-color2)
  );
}

.jp-text-editor-icon-color[fill] {
  fill: var(--jp-text-editor-icon-color, var(--jp-inverse-layout-color3));
}

.jp-inspector-icon-color[fill] {
  fill: var(--jp-inspector-icon-color, var(--jp-inverse-layout-color3));
}

/* CSS for icons in selected filebrowser listing items */
.jp-DirListing-item.jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

.jp-DirListing-item.jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* stylelint-disable selector-max-class, selector-max-compound-selectors */

/**
* TODO: come up with non css-hack solution for showing the busy icon on top
*  of the close icon
* CSS for complex behavior of close icon of tabs in the main area tabbar
*/
.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon3[fill] {
  fill: none;
}

.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon-busy[fill] {
  fill: var(--jp-inverse-layout-color3);
}

/* stylelint-enable selector-max-class, selector-max-compound-selectors */

/* CSS for icons in status bar */
#jp-main-statusbar .jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

#jp-main-statusbar .jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* special handling for splash icon CSS. While the theme CSS reloads during
   splash, the splash icon can loose theming. To prevent that, we set a
   default for its color variable */
:root {
  --jp-warn-color0: var(--md-orange-700);
}

/* not sure what to do with this one, used in filebrowser listing */
.jp-DragIcon {
  margin-right: 4px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for alt colors for icons as inline SVG HTMLElements
 */

/* alt recolor the primary elements of an icon */
.jp-icon-alt .jp-icon0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-alt .jp-icon0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* alt recolor the accent elements of an icon */
.jp-icon-alt .jp-icon-accent0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-alt .jp-icon-accent0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-icon-hoverShow:not(:hover) .jp-icon-hoverShow-content {
  display: none !important;
}

/**
 * Support for hover colors for icons as inline SVG HTMLElements
 */

/**
 * regular colors
 */

/* recolor the primary elements of an icon */
.jp-icon-hover :hover .jp-icon0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-hover :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-hover :hover .jp-icon-none-hover[fill] {
  fill: none;
}

.jp-icon-hover :hover .jp-icon-none-hover[stroke] {
  stroke: none;
}

/**
 * inverse colors
 */

/* inverse recolor the primary elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* inverse recolor the accent elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-IFrame {
  width: 100%;
  height: 100%;
}

.jp-IFrame > iframe {
  border: none;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-IFrame {
  position: relative;
}

body.lm-mod-override-cursor .jp-IFrame::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-HoverBox {
  position: fixed;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FormGroup-content fieldset {
  border: none;
  padding: 0;
  min-width: 0;
  width: 100%;
}

/* stylelint-disable selector-max-type */

.jp-FormGroup-content fieldset .jp-inputFieldWrapper input,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper select,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper textarea {
  font-size: var(--jp-content-font-size2);
  border-color: var(--jp-input-border-color);
  border-style: solid;
  border-radius: var(--jp-border-radius);
  border-width: 1px;
  padding: 6px 8px;
  background: none;
  color: var(--jp-ui-font-color0);
  height: inherit;
}

.jp-FormGroup-content fieldset input[type='checkbox'] {
  position: relative;
  top: 2px;
  margin-left: 0;
}

.jp-FormGroup-content button.jp-mod-styled {
  cursor: pointer;
}

.jp-FormGroup-content .checkbox label {
  cursor: pointer;
  font-size: var(--jp-content-font-size1);
}

.jp-FormGroup-content .jp-root > fieldset > legend {
  display: none;
}

.jp-FormGroup-content .jp-root > fieldset > p {
  display: none;
}

/** copy of `input.jp-mod-styled:focus` style */
.jp-FormGroup-content fieldset input:focus,
.jp-FormGroup-content fieldset select:focus {
  -moz-outline-radius: unset;
  outline: var(--jp-border-width) solid var(--md-blue-500);
  outline-offset: -1px;
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-FormGroup-content fieldset input:hover:not(:focus),
.jp-FormGroup-content fieldset select:hover:not(:focus) {
  background-color: var(--jp-border-color2);
}

/* stylelint-enable selector-max-type */

.jp-FormGroup-content .checkbox .field-description {
  /* Disable default description field for checkbox:
   because other widgets do not have description fields,
   we add descriptions to each widget on the field level.
  */
  display: none;
}

.jp-FormGroup-content #root__description {
  display: none;
}

.jp-FormGroup-content .jp-modifiedIndicator {
  width: 5px;
  background-color: var(--jp-brand-color2);
  margin-top: 0;
  margin-left: calc(var(--jp-private-settingeditor-modifier-indent) * -1);
  flex-shrink: 0;
}

.jp-FormGroup-content .jp-modifiedIndicator.jp-errorIndicator {
  background-color: var(--jp-error-color0);
  margin-right: 0.5em;
}

/* RJSF ARRAY style */

.jp-arrayFieldWrapper legend {
  font-size: var(--jp-content-font-size2);
  color: var(--jp-ui-font-color0);
  flex-basis: 100%;
  padding: 4px 0;
  font-weight: var(--jp-content-heading-font-weight);
  border-bottom: 1px solid var(--jp-border-color2);
}

.jp-arrayFieldWrapper .field-description {
  padding: 4px 0;
  white-space: pre-wrap;
}

.jp-arrayFieldWrapper .array-item {
  width: 100%;
  border: 1px solid var(--jp-border-color2);
  border-radius: 4px;
  margin: 4px;
}

.jp-ArrayOperations {
  display: flex;
  margin-left: 8px;
}

.jp-ArrayOperationsButton {
  margin: 2px;
}

.jp-ArrayOperationsButton .jp-icon3[fill] {
  fill: var(--jp-ui-font-color0);
}

button.jp-ArrayOperationsButton.jp-mod-styled:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

/* RJSF form validation error */

.jp-FormGroup-content .validationErrors {
  color: var(--jp-error-color0);
}

/* Hide panel level error as duplicated the field level error */
.jp-FormGroup-content .panel.errors {
  display: none;
}

/* RJSF normal content (settings-editor) */

.jp-FormGroup-contentNormal {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-FormGroup-contentItem {
  margin-left: 7px;
  color: var(--jp-ui-font-color0);
}

.jp-FormGroup-contentNormal .jp-FormGroup-description {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-default {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-fieldLabel {
  font-size: var(--jp-content-font-size1);
  font-weight: normal;
  min-width: 120px;
}

.jp-FormGroup-contentNormal fieldset:not(:first-child) {
  margin-left: 7px;
}

.jp-FormGroup-contentNormal .field-array-of-string .array-item {
  /* Display `jp-ArrayOperations` buttons side-by-side with content except
    for small screens where flex-wrap will place them one below the other.
  */
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-objectFieldWrapper .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

/* RJSF compact content (metadata-form) */

.jp-FormGroup-content.jp-FormGroup-contentCompact {
  width: 100%;
}

.jp-FormGroup-contentCompact .form-group {
  display: flex;
  padding: 0.5em 0.2em 0.5em 0;
}

.jp-FormGroup-contentCompact
  .jp-FormGroup-compactTitle
  .jp-FormGroup-description {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color2);
}

.jp-FormGroup-contentCompact .jp-FormGroup-fieldLabel {
  padding-bottom: 0.3em;
}

.jp-FormGroup-contentCompact .jp-inputFieldWrapper .form-control {
  width: 100%;
  box-sizing: border-box;
}

.jp-FormGroup-contentCompact .jp-arrayFieldWrapper .jp-FormGroup-compactTitle {
  padding-bottom: 7px;
}

.jp-FormGroup-contentCompact
  .jp-objectFieldWrapper
  .jp-objectFieldWrapper
  .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

.jp-FormGroup-contentCompact ul.error-detail {
  margin-block-start: 0.5em;
  margin-block-end: 0.5em;
  padding-inline-start: 1em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-SidePanel {
  display: flex;
  flex-direction: column;
  min-width: var(--jp-sidebar-min-width);
  overflow-y: auto;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);
  font-size: var(--jp-ui-font-size1);
}

.jp-SidePanel-header {
  flex: 0 0 auto;
  display: flex;
  border-bottom: var(--jp-border-width) solid var(--jp-border-color2);
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin: 0;
  padding: 2px;
  text-transform: uppercase;
}

.jp-SidePanel-toolbar {
  flex: 0 0 auto;
}

.jp-SidePanel-content {
  flex: 1 1 auto;
}

.jp-SidePanel-toolbar,
.jp-AccordionPanel-toolbar {
  height: var(--jp-private-toolbar-height);
}

.jp-SidePanel-toolbar.jp-Toolbar-micro {
  display: none;
}

.lm-AccordionPanel .jp-AccordionPanel-title {
  box-sizing: border-box;
  line-height: 25px;
  margin: 0;
  display: flex;
  align-items: center;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  font-size: var(--jp-ui-font-size0);
}

.jp-AccordionPanel-title {
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  text-transform: uppercase;
}

.lm-AccordionPanel[data-orientation='horizontal'] > .jp-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleLabel {
  user-select: none;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleCollapser {
  transform: rotate(-90deg);
  margin: auto 0;
  height: 16px;
}

.jp-AccordionPanel-title.lm-mod-expanded .lm-AccordionPanel-titleCollapser {
  transform: rotate(0deg);
}

.lm-AccordionPanel .jp-AccordionPanel-toolbar {
  background: none;
  box-shadow: none;
  border: none;
  margin-left: auto;
}

.lm-AccordionPanel .lm-SplitPanel-handle:hover {
  background: var(--jp-layout-color3);
}

.jp-text-truncated {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Spinner {
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-layout-color0);
  outline: none;
}

.jp-SpinnerContent {
  font-size: 10px;
  margin: 50px auto;
  text-indent: -9999em;
  width: 3em;
  height: 3em;
  border-radius: 50%;
  background: var(--jp-brand-color3);
  background: linear-gradient(
    to right,
    #f37626 10%,
    rgba(255, 255, 255, 0) 42%
  );
  position: relative;
  animation: load3 1s infinite linear, fadeIn 1s;
}

.jp-SpinnerContent::before {
  width: 50%;
  height: 50%;
  background: #f37626;
  border-radius: 100% 0 0;
  position: absolute;
  top: 0;
  left: 0;
  content: '';
}

.jp-SpinnerContent::after {
  background: var(--jp-layout-color0);
  width: 75%;
  height: 75%;
  border-radius: 50%;
  content: '';
  margin: auto;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes load3 {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

button.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: none;
  box-sizing: border-box;
  text-align: center;
  line-height: 32px;
  height: 32px;
  padding: 0 12px;
  letter-spacing: 0.8px;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input.jp-mod-styled {
  background: var(--jp-input-background);
  height: 28px;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color1);
  padding-left: 7px;
  padding-right: 7px;
  font-size: var(--jp-ui-font-size2);
  color: var(--jp-ui-font-color0);
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input[type='checkbox'].jp-mod-styled {
  appearance: checkbox;
  -webkit-appearance: checkbox;
  -moz-appearance: checkbox;
  height: auto;
}

input.jp-mod-styled:focus {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-select-wrapper {
  display: flex;
  position: relative;
  flex-direction: column;
  padding: 1px;
  background-color: var(--jp-layout-color1);
  box-sizing: border-box;
  margin-bottom: 12px;
}

.jp-select-wrapper:not(.multiple) {
  height: 28px;
}

.jp-select-wrapper.jp-mod-focused select.jp-mod-styled {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-input-active-background);
}

select.jp-mod-styled:hover {
  cursor: pointer;
  color: var(--jp-ui-font-color0);
  background-color: var(--jp-input-hover-background);
  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.5);
}

select.jp-mod-styled {
  flex: 1 1 auto;
  width: 100%;
  font-size: var(--jp-ui-font-size2);
  background: var(--jp-input-background);
  color: var(--jp-ui-font-color0);
  padding: 0 25px 0 8px;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

select.jp-mod-styled:not([multiple]) {
  height: 32px;
}

select.jp-mod-styled[multiple] {
  max-height: 200px;
  overflow-y: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-switch {
  display: flex;
  align-items: center;
  padding-left: 4px;
  padding-right: 4px;
  font-size: var(--jp-ui-font-size1);
  background-color: transparent;
  color: var(--jp-ui-font-color1);
  border: none;
  height: 20px;
}

.jp-switch:hover {
  background-color: var(--jp-layout-color2);
}

.jp-switch-label {
  margin-right: 5px;
  font-family: var(--jp-ui-font-family);
}

.jp-switch-track {
  cursor: pointer;
  background-color: var(--jp-switch-color, var(--jp-border-color1));
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 34px;
  height: 16px;
  width: 35px;
  position: relative;
}

.jp-switch-track::before {
  content: '';
  position: absolute;
  height: 10px;
  width: 10px;
  margin: 3px;
  left: 0;
  background-color: var(--jp-ui-inverse-font-color1);
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 50%;
}

.jp-switch[aria-checked='true'] .jp-switch-track {
  background-color: var(--jp-switch-true-position-color, var(--jp-warn-color0));
}

.jp-switch[aria-checked='true'] .jp-switch-track::before {
  /* track width (35) - margins (3 + 3) - thumb width (10) */
  left: 19px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toolbar-height: calc(
    28px + var(--jp-border-width)
  ); /* leave 28px for content */
}

.jp-Toolbar {
  color: var(--jp-ui-font-color1);
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: 2px;
  z-index: 8;
  overflow-x: hidden;
}

/* Toolbar items */

.jp-Toolbar > .jp-Toolbar-item.jp-Toolbar-spacer {
  flex-grow: 1;
  flex-shrink: 1;
}

.jp-Toolbar-item.jp-Toolbar-kernelStatus {
  display: inline-block;
  width: 32px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 16px;
}

.jp-Toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  display: flex;
  padding-left: 1px;
  padding-right: 1px;
  font-size: var(--jp-ui-font-size1);
  line-height: var(--jp-private-toolbar-height);
  height: 100%;
}

/* Toolbar buttons */

/* This is the div we use to wrap the react component into a Widget */
div.jp-ToolbarButton {
  color: transparent;
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0;
  margin: 0;
}

button.jp-ToolbarButtonComponent {
  background: var(--jp-layout-color1);
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0 6px;
  margin: 0;
  height: 24px;
  border-radius: var(--jp-border-radius);
  display: flex;
  align-items: center;
  text-align: center;
  font-size: 14px;
  min-width: unset;
  min-height: unset;
}

button.jp-ToolbarButtonComponent:disabled {
  opacity: 0.4;
}

button.jp-ToolbarButtonComponent > span {
  padding: 0;
  flex: 0 0 auto;
}

button.jp-ToolbarButtonComponent .jp-ToolbarButtonComponent-label {
  font-size: var(--jp-ui-font-size1);
  line-height: 100%;
  padding-left: 2px;
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar.jp-Toolbar-micro {
  padding: 0;
  min-height: 0;
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar {
  border: none;
  box-shadow: none;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-WindowedPanel-outer {
  position: relative;
  overflow-y: auto;
}

.jp-WindowedPanel-inner {
  position: relative;
}

.jp-WindowedPanel-window {
  position: absolute;
  left: 0;
  right: 0;
  overflow: visible;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* Sibling imports */

body {
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
}

/* Disable native link decoration styles everywhere outside of dialog boxes */
a {
  text-decoration: unset;
  color: unset;
}

a:hover {
  text-decoration: unset;
  color: unset;
}

/* Accessibility for links inside dialog box text */
.jp-Dialog-content a {
  text-decoration: revert;
  color: var(--jp-content-link-color);
}

.jp-Dialog-content a:hover {
  text-decoration: revert;
}

/* Styles for ui-components */
.jp-Button {
  color: var(--jp-ui-font-color2);
  border-radius: var(--jp-border-radius);
  padding: 0 12px;
  font-size: var(--jp-ui-font-size1);

  /* Copy from blueprint 3 */
  display: inline-flex;
  flex-direction: row;
  border: none;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  text-align: left;
  vertical-align: middle;
  min-height: 30px;
  min-width: 30px;
}

.jp-Button:disabled {
  cursor: not-allowed;
}

.jp-Button:empty {
  padding: 0 !important;
}

.jp-Button.jp-mod-small {
  min-height: 24px;
  min-width: 24px;
  font-size: 12px;
  padding: 0 7px;
}

/* Use our own theme for hover styles */
.jp-Button.jp-mod-minimal:hover {
  background-color: var(--jp-layout-color2);
}

.jp-Button.jp-mod-minimal {
  background: none;
}

.jp-InputGroup {
  display: block;
  position: relative;
}

.jp-InputGroup input {
  box-sizing: border-box;
  border: none;
  border-radius: 0;
  background-color: transparent;
  color: var(--jp-ui-font-color0);
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
  padding-bottom: 0;
  padding-top: 0;
  padding-left: 10px;
  padding-right: 28px;
  position: relative;
  width: 100%;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  font-size: 14px;
  font-weight: 400;
  height: 30px;
  line-height: 30px;
  outline: none;
  vertical-align: middle;
}

.jp-InputGroup input:focus {
  box-shadow: inset 0 0 0 var(--jp-border-width)
      var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-InputGroup input:disabled {
  cursor: not-allowed;
  resize: block;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input:disabled ~ span {
  cursor: not-allowed;
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input::placeholder,
input::placeholder {
  color: var(--jp-ui-font-color2);
}

.jp-InputGroupAction {
  position: absolute;
  bottom: 1px;
  right: 0;
  padding: 6px;
}

.jp-HTMLSelect.jp-DefaultStyle select {
  background-color: initial;
  border: none;
  border-radius: 0;
  box-shadow: none;
  color: var(--jp-ui-font-color0);
  display: block;
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  height: 24px;
  line-height: 14px;
  padding: 0 25px 0 10px;
  text-align: left;
  -moz-appearance: none;
  -webkit-appearance: none;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
  cursor: not-allowed;
  resize: block;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled ~ span {
  cursor: not-allowed;
}

/* Use our own theme for hover and option styles */
/* stylelint-disable-next-line selector-max-type */
.jp-HTMLSelect.jp-DefaultStyle select:hover,
.jp-HTMLSelect.jp-DefaultStyle select > option {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color0);
}

select {
  box-sizing: border-box;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-StatusBar-Widget {
  display: flex;
  align-items: center;
  background: var(--jp-layout-color2);
  min-height: var(--jp-statusbar-height);
  justify-content: space-between;
  padding: 0 10px;
}

.jp-StatusBar-Left {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-StatusBar-Middle {
  display: flex;
  align-items: center;
}

.jp-StatusBar-Right {
  display: flex;
  align-items: center;
  flex-direction: row-reverse;
}

.jp-StatusBar-Item {
  max-height: var(--jp-statusbar-height);
  margin: 0 2px;
  height: var(--jp-statusbar-height);
  white-space: nowrap;
  text-overflow: ellipsis;
  color: var(--jp-ui-font-color1);
  padding: 0 6px;
}

.jp-mod-highlighted:hover {
  background-color: var(--jp-layout-color3);
}

.jp-mod-clicked {
  background-color: var(--jp-brand-color1);
}

.jp-mod-clicked:hover {
  background-color: var(--jp-brand-color0);
}

.jp-mod-clicked .jp-StatusBar-TextItem {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-StatusBar-HoverItem {
  box-shadow: '0px 4px 4px rgba(0, 0, 0, 0.25)';
}

.jp-StatusBar-TextItem {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  line-height: 24px;
  color: var(--jp-ui-font-color1);
}

.jp-StatusBar-GroupItem {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-Statusbar-ProgressCircle svg {
  display: block;
  margin: 0 auto;
  width: 16px;
  height: 24px;
  align-self: normal;
}

.jp-Statusbar-ProgressCircle path {
  fill: var(--jp-inverse-layout-color3);
}

.jp-Statusbar-ProgressBar-progress-bar {
  height: 10px;
  width: 100px;
  border: solid 0.25px var(--jp-brand-color2);
  border-radius: 3px;
  overflow: hidden;
  align-self: center;
}

.jp-Statusbar-ProgressBar-progress-bar > div {
  background-color: var(--jp-brand-color2);
  background-image: linear-gradient(
    -45deg,
    rgba(255, 255, 255, 0.2) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0.2) 75%,
    transparent 75%,
    transparent
  );
  background-size: 40px 40px;
  float: left;
  width: 0%;
  height: 100%;
  font-size: 12px;
  line-height: 14px;
  color: #fff;
  text-align: center;
  animation: jp-Statusbar-ExecutionTime-progress-bar 2s linear infinite;
}

.jp-Statusbar-ProgressBar-progress-bar p {
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
  font-size: var(--jp-ui-font-size1);
  line-height: 10px;
  width: 100px;
}

@keyframes jp-Statusbar-ExecutionTime-progress-bar {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 40px 40px;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-commandpalette-search-height: 28px;
}

/*-----------------------------------------------------------------------------
| Overall styles
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  padding-bottom: 0;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Modal variant
|----------------------------------------------------------------------------*/

.jp-ModalCommandPalette {
  position: absolute;
  z-index: 10000;
  top: 38px;
  left: 30%;
  margin: 0;
  padding: 4px;
  width: 40%;
  box-shadow: var(--jp-elevation-z4);
  border-radius: 4px;
  background: var(--jp-layout-color0);
}

.jp-ModalCommandPalette .lm-CommandPalette {
  max-height: 40vh;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-close-icon::after {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-header {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-item {
  margin-left: 4px;
  margin-right: 4px;
}

.jp-ModalCommandPalette
  .lm-CommandPalette
  .lm-CommandPalette-item.lm-mod-disabled {
  display: none;
}

/*-----------------------------------------------------------------------------
| Search
|----------------------------------------------------------------------------*/

.lm-CommandPalette-search {
  padding: 4px;
  background-color: var(--jp-layout-color1);
  z-index: 2;
}

.lm-CommandPalette-wrapper {
  overflow: overlay;
  padding: 0 9px;
  background-color: var(--jp-input-active-background);
  height: 30px;
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
}

.lm-CommandPalette.lm-mod-focused .lm-CommandPalette-wrapper {
  box-shadow: inset 0 0 0 1px var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-SearchIconGroup {
  color: white;
  background-color: var(--jp-brand-color1);
  position: absolute;
  top: 4px;
  right: 4px;
  padding: 5px 5px 1px;
}

.jp-SearchIconGroup svg {
  height: 20px;
  width: 20px;
}

.jp-SearchIconGroup .jp-icon3[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-input {
  background: transparent;
  width: calc(100% - 18px);
  float: left;
  border: none;
  outline: none;
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  line-height: var(--jp-private-commandpalette-search-height);
}

.lm-CommandPalette-input::-webkit-input-placeholder,
.lm-CommandPalette-input::-moz-placeholder,
.lm-CommandPalette-input:-ms-input-placeholder {
  color: var(--jp-ui-font-color2);
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Results
|----------------------------------------------------------------------------*/

.lm-CommandPalette-header:first-child {
  margin-top: 0;
}

.lm-CommandPalette-header {
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin-top: 8px;
  padding: 8px 0 8px 12px;
  text-transform: uppercase;
}

.lm-CommandPalette-header.lm-mod-active {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-header > mark {
  background-color: transparent;
  font-weight: bold;
  color: var(--jp-ui-font-color1);
}

.lm-CommandPalette-item {
  padding: 4px 12px 4px 4px;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  font-weight: 400;
  display: flex;
}

.lm-CommandPalette-item.lm-mod-disabled {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item.lm-mod-active {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item.lm-mod-active .lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-inverse-font-color0);
}

.lm-CommandPalette-item.lm-mod-active .jp-icon-selectable[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-item.lm-mod-active:hover:not(.lm-mod-disabled) {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item:hover:not(.lm-mod-active):not(.lm-mod-disabled) {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-itemContent {
  overflow: hidden;
}

.lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.lm-CommandPalette-item.lm-mod-disabled mark {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item .lm-CommandPalette-itemIcon {
  margin: 0 4px 0 0;
  position: relative;
  width: 16px;
  top: 2px;
  flex: 0 0 auto;
}

.lm-CommandPalette-item.lm-mod-disabled .lm-CommandPalette-itemIcon {
  opacity: 0.6;
}

.lm-CommandPalette-item .lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemCaption {
  display: none;
}

.lm-CommandPalette-content {
  background-color: var(--jp-layout-color1);
}

.lm-CommandPalette-content:empty::after {
  content: 'No results';
  margin: auto;
  margin-top: 20px;
  width: 100px;
  display: block;
  font-size: var(--jp-ui-font-size2);
  font-family: var(--jp-ui-font-family);
  font-weight: lighter;
}

.lm-CommandPalette-emptyMessage {
  text-align: center;
  margin-top: 24px;
  line-height: 1.32;
  padding: 0 8px;
  color: var(--jp-content-font-color3);
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Dialog {
  position: absolute;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  top: 0;
  left: 0;
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-dialog-background);
}

.jp-Dialog-content {
  display: flex;
  flex-direction: column;
  margin-left: auto;
  margin-right: auto;
  background: var(--jp-layout-color1);
  padding: 24px 24px 12px;
  min-width: 300px;
  min-height: 150px;
  max-width: 1000px;
  max-height: 500px;
  box-sizing: border-box;
  box-shadow: var(--jp-elevation-z20);
  word-wrap: break-word;
  border-radius: var(--jp-border-radius);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color1);
  resize: both;
}

.jp-Dialog-content.jp-Dialog-content-small {
  max-width: 500px;
}

.jp-Dialog-button {
  overflow: visible;
}

button.jp-Dialog-button:focus {
  outline: 1px solid var(--jp-brand-color1);
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button:focus::-moz-focus-inner {
  border: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus {
  outline: 1px solid var(--jp-accept-color-normal, var(--jp-brand-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus {
  outline: 1px solid var(--jp-warn-color-normal, var(--jp-error-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline: 1px solid var(--jp-reject-color-normal, var(--md-grey-600));
}

button.jp-Dialog-close-button {
  padding: 0;
  height: 100%;
  min-width: unset;
  min-height: unset;
}

.jp-Dialog-header {
  display: flex;
  justify-content: space-between;
  flex: 0 0 auto;
  padding-bottom: 12px;
  font-size: var(--jp-ui-font-size3);
  font-weight: 400;
  color: var(--jp-ui-font-color1);
}

.jp-Dialog-body {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  font-size: var(--jp-ui-font-size1);
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

.jp-Dialog-footer {
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
  align-items: center;
  flex: 0 0 auto;
  margin-left: -12px;
  margin-right: -12px;
  padding: 12px;
}

.jp-Dialog-checkbox {
  padding-right: 5px;
}

.jp-Dialog-checkbox > input:focus-visible {
  outline: 1px solid var(--jp-input-active-border-color);
  outline-offset: 1px;
}

.jp-Dialog-spacer {
  flex: 1 1 auto;
}

.jp-Dialog-title {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.jp-Dialog-body > .jp-select-wrapper {
  width: 100%;
}

.jp-Dialog-body > button {
  padding: 0 16px;
}

.jp-Dialog-body > label {
  line-height: 1.4;
  color: var(--jp-ui-font-color0);
}

.jp-Dialog-button.jp-mod-styled:not(:last-child) {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Input-Boolean-Dialog {
  flex-direction: row-reverse;
  align-items: end;
  width: 100%;
}

.jp-Input-Boolean-Dialog > label {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MainAreaWidget > :focus {
  outline: none;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error {
  padding: 6px;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error > pre {
  width: auto;
  padding: 10px;
  background: var(--jp-error-color3);
  border: var(--jp-border-width) solid var(--jp-error-color1);
  border-radius: var(--jp-border-radius);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  white-space: pre-wrap;
  word-wrap: break-word;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/**
 * google-material-color v1.2.6
 * https://github.com/danlevan/google-material-color
 */
:root {
  --md-red-50: #ffebee;
  --md-red-100: #ffcdd2;
  --md-red-200: #ef9a9a;
  --md-red-300: #e57373;
  --md-red-400: #ef5350;
  --md-red-500: #f44336;
  --md-red-600: #e53935;
  --md-red-700: #d32f2f;
  --md-red-800: #c62828;
  --md-red-900: #b71c1c;
  --md-red-A100: #ff8a80;
  --md-red-A200: #ff5252;
  --md-red-A400: #ff1744;
  --md-red-A700: #d50000;
  --md-pink-50: #fce4ec;
  --md-pink-100: #f8bbd0;
  --md-pink-200: #f48fb1;
  --md-pink-300: #f06292;
  --md-pink-400: #ec407a;
  --md-pink-500: #e91e63;
  --md-pink-600: #d81b60;
  --md-pink-700: #c2185b;
  --md-pink-800: #ad1457;
  --md-pink-900: #880e4f;
  --md-pink-A100: #ff80ab;
  --md-pink-A200: #ff4081;
  --md-pink-A400: #f50057;
  --md-pink-A700: #c51162;
  --md-purple-50: #f3e5f5;
  --md-purple-100: #e1bee7;
  --md-purple-200: #ce93d8;
  --md-purple-300: #ba68c8;
  --md-purple-400: #ab47bc;
  --md-purple-500: #9c27b0;
  --md-purple-600: #8e24aa;
  --md-purple-700: #7b1fa2;
  --md-purple-800: #6a1b9a;
  --md-purple-900: #4a148c;
  --md-purple-A100: #ea80fc;
  --md-purple-A200: #e040fb;
  --md-purple-A400: #d500f9;
  --md-purple-A700: #a0f;
  --md-deep-purple-50: #ede7f6;
  --md-deep-purple-100: #d1c4e9;
  --md-deep-purple-200: #b39ddb;
  --md-deep-purple-300: #9575cd;
  --md-deep-purple-400: #7e57c2;
  --md-deep-purple-500: #673ab7;
  --md-deep-purple-600: #5e35b1;
  --md-deep-purple-700: #512da8;
  --md-deep-purple-800: #4527a0;
  --md-deep-purple-900: #311b92;
  --md-deep-purple-A100: #b388ff;
  --md-deep-purple-A200: #7c4dff;
  --md-deep-purple-A400: #651fff;
  --md-deep-purple-A700: #6200ea;
  --md-indigo-50: #e8eaf6;
  --md-indigo-100: #c5cae9;
  --md-indigo-200: #9fa8da;
  --md-indigo-300: #7986cb;
  --md-indigo-400: #5c6bc0;
  --md-indigo-500: #3f51b5;
  --md-indigo-600: #3949ab;
  --md-indigo-700: #303f9f;
  --md-indigo-800: #283593;
  --md-indigo-900: #1a237e;
  --md-indigo-A100: #8c9eff;
  --md-indigo-A200: #536dfe;
  --md-indigo-A400: #3d5afe;
  --md-indigo-A700: #304ffe;
  --md-blue-50: #e3f2fd;
  --md-blue-100: #bbdefb;
  --md-blue-200: #90caf9;
  --md-blue-300: #64b5f6;
  --md-blue-400: #42a5f5;
  --md-blue-500: #2196f3;
  --md-blue-600: #1e88e5;
  --md-blue-700: #1976d2;
  --md-blue-800: #1565c0;
  --md-blue-900: #0d47a1;
  --md-blue-A100: #82b1ff;
  --md-blue-A200: #448aff;
  --md-blue-A400: #2979ff;
  --md-blue-A700: #2962ff;
  --md-light-blue-50: #e1f5fe;
  --md-light-blue-100: #b3e5fc;
  --md-light-blue-200: #81d4fa;
  --md-light-blue-300: #4fc3f7;
  --md-light-blue-400: #29b6f6;
  --md-light-blue-500: #03a9f4;
  --md-light-blue-600: #039be5;
  --md-light-blue-700: #0288d1;
  --md-light-blue-800: #0277bd;
  --md-light-blue-900: #01579b;
  --md-light-blue-A100: #80d8ff;
  --md-light-blue-A200: #40c4ff;
  --md-light-blue-A400: #00b0ff;
  --md-light-blue-A700: #0091ea;
  --md-cyan-50: #e0f7fa;
  --md-cyan-100: #b2ebf2;
  --md-cyan-200: #80deea;
  --md-cyan-300: #4dd0e1;
  --md-cyan-400: #26c6da;
  --md-cyan-500: #00bcd4;
  --md-cyan-600: #00acc1;
  --md-cyan-700: #0097a7;
  --md-cyan-800: #00838f;
  --md-cyan-900: #006064;
  --md-cyan-A100: #84ffff;
  --md-cyan-A200: #18ffff;
  --md-cyan-A400: #00e5ff;
  --md-cyan-A700: #00b8d4;
  --md-teal-50: #e0f2f1;
  --md-teal-100: #b2dfdb;
  --md-teal-200: #80cbc4;
  --md-teal-300: #4db6ac;
  --md-teal-400: #26a69a;
  --md-teal-500: #009688;
  --md-teal-600: #00897b;
  --md-teal-700: #00796b;
  --md-teal-800: #00695c;
  --md-teal-900: #004d40;
  --md-teal-A100: #a7ffeb;
  --md-teal-A200: #64ffda;
  --md-teal-A400: #1de9b6;
  --md-teal-A700: #00bfa5;
  --md-green-50: #e8f5e9;
  --md-green-100: #c8e6c9;
  --md-green-200: #a5d6a7;
  --md-green-300: #81c784;
  --md-green-400: #66bb6a;
  --md-green-500: #4caf50;
  --md-green-600: #43a047;
  --md-green-700: #388e3c;
  --md-green-800: #2e7d32;
  --md-green-900: #1b5e20;
  --md-green-A100: #b9f6ca;
  --md-green-A200: #69f0ae;
  --md-green-A400: #00e676;
  --md-green-A700: #00c853;
  --md-light-green-50: #f1f8e9;
  --md-light-green-100: #dcedc8;
  --md-light-green-200: #c5e1a5;
  --md-light-green-300: #aed581;
  --md-light-green-400: #9ccc65;
  --md-light-green-500: #8bc34a;
  --md-light-green-600: #7cb342;
  --md-light-green-700: #689f38;
  --md-light-green-800: #558b2f;
  --md-light-green-900: #33691e;
  --md-light-green-A100: #ccff90;
  --md-light-green-A200: #b2ff59;
  --md-light-green-A400: #76ff03;
  --md-light-green-A700: #64dd17;
  --md-lime-50: #f9fbe7;
  --md-lime-100: #f0f4c3;
  --md-lime-200: #e6ee9c;
  --md-lime-300: #dce775;
  --md-lime-400: #d4e157;
  --md-lime-500: #cddc39;
  --md-lime-600: #c0ca33;
  --md-lime-700: #afb42b;
  --md-lime-800: #9e9d24;
  --md-lime-900: #827717;
  --md-lime-A100: #f4ff81;
  --md-lime-A200: #eeff41;
  --md-lime-A400: #c6ff00;
  --md-lime-A700: #aeea00;
  --md-yellow-50: #fffde7;
  --md-yellow-100: #fff9c4;
  --md-yellow-200: #fff59d;
  --md-yellow-300: #fff176;
  --md-yellow-400: #ffee58;
  --md-yellow-500: #ffeb3b;
  --md-yellow-600: #fdd835;
  --md-yellow-700: #fbc02d;
  --md-yellow-800: #f9a825;
  --md-yellow-900: #f57f17;
  --md-yellow-A100: #ffff8d;
  --md-yellow-A200: #ff0;
  --md-yellow-A400: #ffea00;
  --md-yellow-A700: #ffd600;
  --md-amber-50: #fff8e1;
  --md-amber-100: #ffecb3;
  --md-amber-200: #ffe082;
  --md-amber-300: #ffd54f;
  --md-amber-400: #ffca28;
  --md-amber-500: #ffc107;
  --md-amber-600: #ffb300;
  --md-amber-700: #ffa000;
  --md-amber-800: #ff8f00;
  --md-amber-900: #ff6f00;
  --md-amber-A100: #ffe57f;
  --md-amber-A200: #ffd740;
  --md-amber-A400: #ffc400;
  --md-amber-A700: #ffab00;
  --md-orange-50: #fff3e0;
  --md-orange-100: #ffe0b2;
  --md-orange-200: #ffcc80;
  --md-orange-300: #ffb74d;
  --md-orange-400: #ffa726;
  --md-orange-500: #ff9800;
  --md-orange-600: #fb8c00;
  --md-orange-700: #f57c00;
  --md-orange-800: #ef6c00;
  --md-orange-900: #e65100;
  --md-orange-A100: #ffd180;
  --md-orange-A200: #ffab40;
  --md-orange-A400: #ff9100;
  --md-orange-A700: #ff6d00;
  --md-deep-orange-50: #fbe9e7;
  --md-deep-orange-100: #ffccbc;
  --md-deep-orange-200: #ffab91;
  --md-deep-orange-300: #ff8a65;
  --md-deep-orange-400: #ff7043;
  --md-deep-orange-500: #ff5722;
  --md-deep-orange-600: #f4511e;
  --md-deep-orange-700: #e64a19;
  --md-deep-orange-800: #d84315;
  --md-deep-orange-900: #bf360c;
  --md-deep-orange-A100: #ff9e80;
  --md-deep-orange-A200: #ff6e40;
  --md-deep-orange-A400: #ff3d00;
  --md-deep-orange-A700: #dd2c00;
  --md-brown-50: #efebe9;
  --md-brown-100: #d7ccc8;
  --md-brown-200: #bcaaa4;
  --md-brown-300: #a1887f;
  --md-brown-400: #8d6e63;
  --md-brown-500: #795548;
  --md-brown-600: #6d4c41;
  --md-brown-700: #5d4037;
  --md-brown-800: #4e342e;
  --md-brown-900: #3e2723;
  --md-grey-50: #fafafa;
  --md-grey-100: #f5f5f5;
  --md-grey-200: #eee;
  --md-grey-300: #e0e0e0;
  --md-grey-400: #bdbdbd;
  --md-grey-500: #9e9e9e;
  --md-grey-600: #757575;
  --md-grey-700: #616161;
  --md-grey-800: #424242;
  --md-grey-900: #212121;
  --md-blue-grey-50: #eceff1;
  --md-blue-grey-100: #cfd8dc;
  --md-blue-grey-200: #b0bec5;
  --md-blue-grey-300: #90a4ae;
  --md-blue-grey-400: #78909c;
  --md-blue-grey-500: #607d8b;
  --md-blue-grey-600: #546e7a;
  --md-blue-grey-700: #455a64;
  --md-blue-grey-800: #37474f;
  --md-blue-grey-900: #263238;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| RenderedText
|----------------------------------------------------------------------------*/

:root {
  /* This is the padding value to fill the gaps between lines containing spans with background color. */
  --jp-private-code-span-padding: calc(
    (var(--jp-code-line-height) - 1) * var(--jp-code-font-size) / 2
  );
}

.jp-RenderedText {
  text-align: left;
  padding-left: var(--jp-code-padding);
  line-height: var(--jp-code-line-height);
  font-family: var(--jp-code-font-family);
}

.jp-RenderedText pre,
.jp-RenderedJavaScript pre,
.jp-RenderedHTMLCommon pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
  border: none;
  margin: 0;
  padding: 0;
}

.jp-RenderedText pre a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* console foregrounds and backgrounds */
.jp-RenderedText pre .ansi-black-fg {
  color: #3e424d;
}

.jp-RenderedText pre .ansi-red-fg {
  color: #e75c58;
}

.jp-RenderedText pre .ansi-green-fg {
  color: #00a250;
}

.jp-RenderedText pre .ansi-yellow-fg {
  color: #ddb62b;
}

.jp-RenderedText pre .ansi-blue-fg {
  color: #208ffb;
}

.jp-RenderedText pre .ansi-magenta-fg {
  color: #d160c4;
}

.jp-RenderedText pre .ansi-cyan-fg {
  color: #60c6c8;
}

.jp-RenderedText pre .ansi-white-fg {
  color: #c5c1b4;
}

.jp-RenderedText pre .ansi-black-bg {
  background-color: #3e424d;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-bg {
  background-color: #e75c58;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-bg {
  background-color: #00a250;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-bg {
  background-color: #ddb62b;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-bg {
  background-color: #208ffb;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-bg {
  background-color: #d160c4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-bg {
  background-color: #60c6c8;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-bg {
  background-color: #c5c1b4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-black-intense-fg {
  color: #282c36;
}

.jp-RenderedText pre .ansi-red-intense-fg {
  color: #b22b31;
}

.jp-RenderedText pre .ansi-green-intense-fg {
  color: #007427;
}

.jp-RenderedText pre .ansi-yellow-intense-fg {
  color: #b27d12;
}

.jp-RenderedText pre .ansi-blue-intense-fg {
  color: #0065ca;
}

.jp-RenderedText pre .ansi-magenta-intense-fg {
  color: #a03196;
}

.jp-RenderedText pre .ansi-cyan-intense-fg {
  color: #258f8f;
}

.jp-RenderedText pre .ansi-white-intense-fg {
  color: #a1a6b2;
}

.jp-RenderedText pre .ansi-black-intense-bg {
  background-color: #282c36;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-intense-bg {
  background-color: #b22b31;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-intense-bg {
  background-color: #007427;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-intense-bg {
  background-color: #b27d12;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-intense-bg {
  background-color: #0065ca;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-intense-bg {
  background-color: #a03196;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-intense-bg {
  background-color: #258f8f;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-intense-bg {
  background-color: #a1a6b2;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-default-inverse-fg {
  color: var(--jp-ui-inverse-font-color0);
}

.jp-RenderedText pre .ansi-default-inverse-bg {
  background-color: var(--jp-inverse-layout-color0);
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-bold {
  font-weight: bold;
}

.jp-RenderedText pre .ansi-underline {
  text-decoration: underline;
}

.jp-RenderedText[data-mime-type='application/vnd.jupyter.stderr'] {
  background: var(--jp-rendermime-error-background);
  padding-top: var(--jp-code-padding);
}

/*-----------------------------------------------------------------------------
| RenderedLatex
|----------------------------------------------------------------------------*/

.jp-RenderedLatex {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);
}

/* Left-justify outputs.*/
.jp-OutputArea-output.jp-RenderedLatex {
  padding: var(--jp-code-padding);
  text-align: left;
}

/*-----------------------------------------------------------------------------
| RenderedHTML
|----------------------------------------------------------------------------*/

.jp-RenderedHTMLCommon {
  color: var(--jp-content-font-color1);
  font-family: var(--jp-content-font-family);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);

  /* Give a bit more R padding on Markdown text to keep line lengths reasonable */
  padding-right: 20px;
}

.jp-RenderedHTMLCommon em {
  font-style: italic;
}

.jp-RenderedHTMLCommon strong {
  font-weight: bold;
}

.jp-RenderedHTMLCommon u {
  text-decoration: underline;
}

.jp-RenderedHTMLCommon a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* Headings */

.jp-RenderedHTMLCommon h1,
.jp-RenderedHTMLCommon h2,
.jp-RenderedHTMLCommon h3,
.jp-RenderedHTMLCommon h4,
.jp-RenderedHTMLCommon h5,
.jp-RenderedHTMLCommon h6 {
  line-height: var(--jp-content-heading-line-height);
  font-weight: var(--jp-content-heading-font-weight);
  font-style: normal;
  margin: var(--jp-content-heading-margin-top) 0
    var(--jp-content-heading-margin-bottom) 0;
}

.jp-RenderedHTMLCommon h1:first-child,
.jp-RenderedHTMLCommon h2:first-child,
.jp-RenderedHTMLCommon h3:first-child,
.jp-RenderedHTMLCommon h4:first-child,
.jp-RenderedHTMLCommon h5:first-child,
.jp-RenderedHTMLCommon h6:first-child {
  margin-top: calc(0.5 * var(--jp-content-heading-margin-top));
}

.jp-RenderedHTMLCommon h1:last-child,
.jp-RenderedHTMLCommon h2:last-child,
.jp-RenderedHTMLCommon h3:last-child,
.jp-RenderedHTMLCommon h4:last-child,
.jp-RenderedHTMLCommon h5:last-child,
.jp-RenderedHTMLCommon h6:last-child {
  margin-bottom: calc(0.5 * var(--jp-content-heading-margin-bottom));
}

.jp-RenderedHTMLCommon h1 {
  font-size: var(--jp-content-font-size5);
}

.jp-RenderedHTMLCommon h2 {
  font-size: var(--jp-content-font-size4);
}

.jp-RenderedHTMLCommon h3 {
  font-size: var(--jp-content-font-size3);
}

.jp-RenderedHTMLCommon h4 {
  font-size: var(--jp-content-font-size2);
}

.jp-RenderedHTMLCommon h5 {
  font-size: var(--jp-content-font-size1);
}

.jp-RenderedHTMLCommon h6 {
  font-size: var(--jp-content-font-size0);
}

/* Lists */

/* stylelint-disable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon ul:not(.list-inline),
.jp-RenderedHTMLCommon ol:not(.list-inline) {
  padding-left: 2em;
}

.jp-RenderedHTMLCommon ul {
  list-style: disc;
}

.jp-RenderedHTMLCommon ul ul {
  list-style: square;
}

.jp-RenderedHTMLCommon ul ul ul {
  list-style: circle;
}

.jp-RenderedHTMLCommon ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol ol {
  list-style: upper-alpha;
}

.jp-RenderedHTMLCommon ol ol ol {
  list-style: lower-alpha;
}

.jp-RenderedHTMLCommon ol ol ol ol {
  list-style: lower-roman;
}

.jp-RenderedHTMLCommon ol ol ol ol ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol,
.jp-RenderedHTMLCommon ul {
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon ul ul,
.jp-RenderedHTMLCommon ul ol,
.jp-RenderedHTMLCommon ol ul,
.jp-RenderedHTMLCommon ol ol {
  margin-bottom: 0;
}

/* stylelint-enable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon hr {
  color: var(--jp-border-color2);
  background-color: var(--jp-border-color1);
  margin-top: 1em;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon > pre {
  margin: 1.5em 2em;
}

.jp-RenderedHTMLCommon pre,
.jp-RenderedHTMLCommon code {
  border: 0;
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  line-height: var(--jp-code-line-height);
  padding: 0;
  white-space: pre-wrap;
}

.jp-RenderedHTMLCommon :not(pre) > code {
  background-color: var(--jp-layout-color2);
  padding: 1px 5px;
}

/* Tables */

.jp-RenderedHTMLCommon table {
  border-collapse: collapse;
  border-spacing: 0;
  border: none;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  table-layout: fixed;
  margin-left: auto;
  margin-bottom: 1em;
  margin-right: auto;
}

.jp-RenderedHTMLCommon thead {
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  vertical-align: bottom;
}

.jp-RenderedHTMLCommon td,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon tr {
  vertical-align: middle;
  padding: 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}

.jp-RenderedMarkdown.jp-RenderedHTMLCommon td,
.jp-RenderedMarkdown.jp-RenderedHTMLCommon th {
  max-width: none;
}

:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon td,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon th,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon tr {
  text-align: right;
}

.jp-RenderedHTMLCommon th {
  font-weight: bold;
}

.jp-RenderedHTMLCommon tbody tr:nth-child(odd) {
  background: var(--jp-layout-color0);
}

.jp-RenderedHTMLCommon tbody tr:nth-child(even) {
  background: var(--jp-rendermime-table-row-background);
}

.jp-RenderedHTMLCommon tbody tr:hover {
  background: var(--jp-rendermime-table-row-hover-background);
}

.jp-RenderedHTMLCommon p {
  text-align: left;
  margin: 0;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon img {
  -moz-force-broken-image-icon: 1;
}

/* Restrict to direct children as other images could be nested in other content. */
.jp-RenderedHTMLCommon > img {
  display: block;
  margin-left: 0;
  margin-right: 0;
  margin-bottom: 1em;
}

/* Change color behind transparent images if they need it... */
[data-jp-theme-light='false'] .jp-RenderedImage img.jp-needs-light-background {
  background-color: var(--jp-inverse-layout-color1);
}

[data-jp-theme-light='true'] .jp-RenderedImage img.jp-needs-dark-background {
  background-color: var(--jp-inverse-layout-color1);
}

.jp-RenderedHTMLCommon img,
.jp-RenderedImage img,
.jp-RenderedHTMLCommon svg,
.jp-RenderedSVG svg {
  max-width: 100%;
  height: auto;
}

.jp-RenderedHTMLCommon img.jp-mod-unconfined,
.jp-RenderedImage img.jp-mod-unconfined,
.jp-RenderedHTMLCommon svg.jp-mod-unconfined,
.jp-RenderedSVG svg.jp-mod-unconfined {
  max-width: none;
}

.jp-RenderedHTMLCommon .alert {
  padding: var(--jp-notebook-padding);
  border: var(--jp-border-width) solid transparent;
  border-radius: var(--jp-border-radius);
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon .alert-info {
  color: var(--jp-info-color0);
  background-color: var(--jp-info-color3);
  border-color: var(--jp-info-color2);
}

.jp-RenderedHTMLCommon .alert-info hr {
  border-color: var(--jp-info-color3);
}

.jp-RenderedHTMLCommon .alert-info > p:last-child,
.jp-RenderedHTMLCommon .alert-info > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-warning {
  color: var(--jp-warn-color0);
  background-color: var(--jp-warn-color3);
  border-color: var(--jp-warn-color2);
}

.jp-RenderedHTMLCommon .alert-warning hr {
  border-color: var(--jp-warn-color3);
}

.jp-RenderedHTMLCommon .alert-warning > p:last-child,
.jp-RenderedHTMLCommon .alert-warning > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-success {
  color: var(--jp-success-color0);
  background-color: var(--jp-success-color3);
  border-color: var(--jp-success-color2);
}

.jp-RenderedHTMLCommon .alert-success hr {
  border-color: var(--jp-success-color3);
}

.jp-RenderedHTMLCommon .alert-success > p:last-child,
.jp-RenderedHTMLCommon .alert-success > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-danger {
  color: var(--jp-error-color0);
  background-color: var(--jp-error-color3);
  border-color: var(--jp-error-color2);
}

.jp-RenderedHTMLCommon .alert-danger hr {
  border-color: var(--jp-error-color3);
}

.jp-RenderedHTMLCommon .alert-danger > p:last-child,
.jp-RenderedHTMLCommon .alert-danger > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon blockquote {
  margin: 1em 2em;
  padding: 0 1em;
  border-left: 5px solid var(--jp-border-color2);
}

a.jp-InternalAnchorLink {
  visibility: hidden;
  margin-left: 8px;
  color: var(--md-blue-800);
}

h1:hover .jp-InternalAnchorLink,
h2:hover .jp-InternalAnchorLink,
h3:hover .jp-InternalAnchorLink,
h4:hover .jp-InternalAnchorLink,
h5:hover .jp-InternalAnchorLink,
h6:hover .jp-InternalAnchorLink {
  visibility: visible;
}

.jp-RenderedHTMLCommon kbd {
  background-color: var(--jp-rendermime-table-row-background);
  border: 1px solid var(--jp-border-color0);
  border-bottom-color: var(--jp-border-color2);
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.25);
  display: inline-block;
  font-size: var(--jp-ui-font-size0);
  line-height: 1em;
  padding: 0.2em 0.5em;
}

/* Most direct children of .jp-RenderedHTMLCommon have a margin-bottom of 1.0.
 * At the bottom of cells this is a bit too much as there is also spacing
 * between cells. Going all the way to 0 gets too tight between markdown and
 * code cells.
 */
.jp-RenderedHTMLCommon > *:last-child {
  margin-bottom: 0.5em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-cursor-backdrop {
  position: fixed;
  width: 200px;
  height: 200px;
  margin-top: -100px;
  margin-left: -100px;
  will-change: transform;
  z-index: 100;
}

.lm-mod-drag-image {
  will-change: transform;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-lineFormSearch {
  padding: 4px 12px;
  background-color: var(--jp-layout-color2);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
  font-size: var(--jp-ui-font-size1);
}

.jp-lineFormCaption {
  font-size: var(--jp-ui-font-size0);
  line-height: var(--jp-ui-font-size1);
  margin-top: 4px;
  color: var(--jp-ui-font-color0);
}

.jp-baseLineForm {
  border: none;
  border-radius: 0;
  position: absolute;
  background-size: 16px;
  background-repeat: no-repeat;
  background-position: center;
  outline: none;
}

.jp-lineFormButtonContainer {
  top: 4px;
  right: 8px;
  height: 24px;
  padding: 0 12px;
  width: 12px;
}

.jp-lineFormButtonIcon {
  top: 0;
  right: 0;
  background-color: var(--jp-brand-color1);
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  padding: 4px 6px;
}

.jp-lineFormButton {
  top: 0;
  right: 0;
  background-color: transparent;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
}

.jp-lineFormWrapper {
  overflow: hidden;
  padding: 0 8px;
  border: 1px solid var(--jp-border-color0);
  background-color: var(--jp-input-active-background);
  height: 22px;
}

.jp-lineFormWrapperFocusWithin {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-lineFormInput {
  background: transparent;
  width: 200px;
  height: 100%;
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  line-height: 28px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-JSONEditor {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.jp-JSONEditor-host {
  flex: 1 1 auto;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  background: var(--jp-layout-color0);
  min-height: 50px;
  padding: 1px;
}

.jp-JSONEditor.jp-mod-error .jp-JSONEditor-host {
  border-color: red;
  outline-color: red;
}

.jp-JSONEditor-header {
  display: flex;
  flex: 1 0 auto;
  padding: 0 0 0 12px;
}

.jp-JSONEditor-header label {
  flex: 0 0 auto;
}

.jp-JSONEditor-commitButton {
  height: 16px;
  width: 16px;
  background-size: 18px;
  background-repeat: no-repeat;
  background-position: center;
}

.jp-JSONEditor-host.jp-mod-focused {
  background-color: var(--jp-input-active-background);
  border: 1px solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

.jp-Editor.jp-mod-dropTarget {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
.jp-DocumentSearch-input {
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  font-size: var(--jp-ui-font-size1);
  background-color: var(--jp-layout-color0);
  font-family: var(--jp-ui-font-family);
  padding: 2px 1px;
  resize: none;
}

.jp-DocumentSearch-overlay {
  position: absolute;
  background-color: var(--jp-toolbar-background);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  border-left: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  top: 0;
  right: 0;
  z-index: 7;
  min-width: 405px;
  padding: 2px;
  font-size: var(--jp-ui-font-size1);

  --jp-private-document-search-button-height: 20px;
}

.jp-DocumentSearch-overlay button {
  background-color: var(--jp-toolbar-background);
  outline: 0;
}

.jp-DocumentSearch-overlay button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-overlay button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-overlay-row {
  display: flex;
  align-items: center;
  margin-bottom: 2px;
}

.jp-DocumentSearch-button-content {
  display: inline-block;
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-button-content svg {
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-input-wrapper {
  border: var(--jp-border-width) solid var(--jp-border-color0);
  display: flex;
  background-color: var(--jp-layout-color0);
  margin: 2px;
}

.jp-DocumentSearch-input-wrapper:focus-within {
  border-color: var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper {
  all: initial;
  overflow: hidden;
  display: inline-block;
  border: none;
  box-sizing: border-box;
}

.jp-DocumentSearch-toggle-wrapper {
  width: 14px;
  height: 14px;
}

.jp-DocumentSearch-button-wrapper {
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
}

.jp-DocumentSearch-toggle-wrapper:focus,
.jp-DocumentSearch-button-wrapper:focus {
  outline: var(--jp-border-width) solid
    var(--jp-cell-editor-active-border-color);
  outline-offset: -1px;
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper,
.jp-DocumentSearch-button-content:focus {
  outline: none;
}

.jp-DocumentSearch-toggle-placeholder {
  width: 5px;
}

.jp-DocumentSearch-input-button::before {
  display: block;
  padding-top: 100%;
}

.jp-DocumentSearch-input-button-off {
  opacity: var(--jp-search-toggle-off-opacity);
}

.jp-DocumentSearch-input-button-off:hover {
  opacity: var(--jp-search-toggle-hover-opacity);
}

.jp-DocumentSearch-input-button-on {
  opacity: var(--jp-search-toggle-on-opacity);
}

.jp-DocumentSearch-index-counter {
  padding-left: 10px;
  padding-right: 10px;
  user-select: none;
  min-width: 35px;
  display: inline-block;
}

.jp-DocumentSearch-up-down-wrapper {
  display: inline-block;
  padding-right: 2px;
  margin-left: auto;
  white-space: nowrap;
}

.jp-DocumentSearch-spacer {
  margin-left: auto;
}

.jp-DocumentSearch-up-down-wrapper button {
  outline: 0;
  border: none;
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
  vertical-align: middle;
  margin: 1px 5px 2px;
}

.jp-DocumentSearch-up-down-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-up-down-button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-filter-button {
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-filter-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled:hover {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-search-options {
  padding: 0 8px;
  margin-left: 3px;
  width: 100%;
  display: grid;
  justify-content: start;
  grid-template-columns: 1fr 1fr;
  align-items: center;
  justify-items: stretch;
}

.jp-DocumentSearch-search-filter-disabled {
  color: var(--jp-ui-font-color2);
}

.jp-DocumentSearch-search-filter {
  display: flex;
  align-items: center;
  user-select: none;
}

.jp-DocumentSearch-regex-error {
  color: var(--jp-error-color0);
}

.jp-DocumentSearch-replace-button-wrapper {
  overflow: hidden;
  display: inline-block;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color0);
  margin: auto 2px;
  padding: 1px 4px;
  height: calc(var(--jp-private-document-search-button-height) + 2px);
}

.jp-DocumentSearch-replace-button-wrapper:focus {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-replace-button {
  display: inline-block;
  text-align: center;
  cursor: pointer;
  box-sizing: border-box;
  color: var(--jp-ui-font-color1);

  /* height - 2 * (padding of wrapper) */
  line-height: calc(var(--jp-private-document-search-button-height) - 2px);
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-replace-button:focus {
  outline: none;
}

.jp-DocumentSearch-replace-wrapper-class {
  margin-left: 14px;
  display: flex;
}

.jp-DocumentSearch-replace-toggle {
  border: none;
  background-color: var(--jp-toolbar-background);
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-replace-toggle:hover {
  background-color: var(--jp-layout-color2);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.cm-editor {
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  border: 0;
  border-radius: 0;
  height: auto;

  /* Changed to auto to autogrow */
}

.cm-editor pre {
  padding: 0 var(--jp-code-padding);
}

.jp-CodeMirrorEditor[data-type='inline'] .cm-dialog {
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
}

.jp-CodeMirrorEditor {
  cursor: text;
}

/* When zoomed out 67% and 33% on a screen of 1440 width x 900 height */
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width1) solid
      var(--jp-editor-cursor-color);
  }
}

/* When zoomed out less than 33% */
@media screen and (min-width: 4320px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width2) solid
      var(--jp-editor-cursor-color);
  }
}

.cm-editor.jp-mod-readOnly .cm-cursor {
  display: none;
}

.jp-CollaboratorCursor {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: none;
  border-bottom: 3px solid;
  background-clip: content-box;
  margin-left: -5px;
  margin-right: -5px;
}

.cm-searching,
.cm-searching span {
  /* `.cm-searching span`: we need to override syntax highlighting */
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.cm-searching::selection,
.cm-searching span::selection {
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.jp-current-match > .cm-searching,
.jp-current-match > .cm-searching span,
.cm-searching > .jp-current-match,
.cm-searching > .jp-current-match span {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.jp-current-match > .cm-searching::selection,
.cm-searching > .jp-current-match::selection,
.jp-current-match > .cm-searching span::selection {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.cm-trailingspace {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAsElEQVQIHQGlAFr/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7+r3zKmT0/+pk9P/7+r3zAAAAAAAAAAABAAAAAAAAAAA6OPzM+/q9wAAAAAA6OPzMwAAAAAAAAAAAgAAAAAAAAAAGR8NiRQaCgAZIA0AGR8NiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQyoYJ/SY80UAAAAASUVORK5CYII=);
  background-position: center left;
  background-repeat: repeat-x;
}

.jp-CollaboratorCursor-hover {
  position: absolute;
  z-index: 1;
  transform: translateX(-50%);
  color: white;
  border-radius: 3px;
  padding-left: 4px;
  padding-right: 4px;
  padding-top: 1px;
  padding-bottom: 1px;
  text-align: center;
  font-size: var(--jp-ui-font-size1);
  white-space: nowrap;
}

.jp-CodeMirror-ruler {
  border-left: 1px dashed var(--jp-border-color2);
}

/* Styles for shared cursors (remote cursor locations and selected ranges) */
.jp-CodeMirrorEditor .cm-ySelectionCaret {
  position: relative;
  border-left: 1px solid black;
  margin-left: -1px;
  margin-right: -1px;
  box-sizing: border-box;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret > .cm-ySelectionInfo {
  white-space: nowrap;
  position: absolute;
  top: -1.15em;
  padding-bottom: 0.05em;
  left: -1px;
  font-size: 0.95em;
  font-family: var(--jp-ui-font-family);
  font-weight: bold;
  line-height: normal;
  user-select: none;
  color: white;
  padding-left: 2px;
  padding-right: 2px;
  z-index: 101;
  transition: opacity 0.3s ease-in-out;
}

.jp-CodeMirrorEditor .cm-ySelectionInfo {
  transition-delay: 0.7s;
  opacity: 0;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret:hover > .cm-ySelectionInfo {
  opacity: 1;
  transition-delay: 0s;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MimeDocument {
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-filebrowser-button-height: 28px;
  --jp-private-filebrowser-button-width: 48px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FileBrowser .jp-SidePanel-content {
  display: flex;
  flex-direction: column;
}

.jp-FileBrowser-toolbar.jp-Toolbar {
  flex-wrap: wrap;
  row-gap: 12px;
  border-bottom: none;
  height: auto;
  margin: 8px 12px 0;
  box-shadow: none;
  padding: 0;
  justify-content: flex-start;
}

.jp-FileBrowser-Panel {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
}

.jp-BreadCrumbs {
  flex: 0 0 auto;
  margin: 8px 12px;
}

.jp-BreadCrumbs-item {
  margin: 0 2px;
  padding: 0 2px;
  border-radius: var(--jp-border-radius);
  cursor: pointer;
}

.jp-BreadCrumbs-item:hover {
  background-color: var(--jp-layout-color2);
}

.jp-BreadCrumbs-item:first-child {
  margin-left: 0;
}

.jp-BreadCrumbs-item.jp-mod-dropTarget {
  background-color: var(--jp-brand-color2);
  opacity: 0.7;
}

/*-----------------------------------------------------------------------------
| Buttons
|----------------------------------------------------------------------------*/

.jp-FileBrowser-toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  padding-left: 0;
  padding-right: 2px;
  align-items: center;
  height: unset;
}

.jp-FileBrowser-toolbar > .jp-Toolbar-item .jp-ToolbarButtonComponent {
  width: 40px;
}

/*-----------------------------------------------------------------------------
| Other styles
|----------------------------------------------------------------------------*/

.jp-FileDialog.jp-mod-conflict input {
  color: var(--jp-error-color1);
}

.jp-FileDialog .jp-new-name-title {
  margin-top: 12px;
}

.jp-LastModified-hidden {
  display: none;
}

.jp-FileSize-hidden {
  display: none;
}

.jp-FileBrowser .lm-AccordionPanel > h3:first-child {
  display: none;
}

/*-----------------------------------------------------------------------------
| DirListing
|----------------------------------------------------------------------------*/

.jp-DirListing {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  outline: 0;
}

.jp-DirListing-header {
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  align-items: center;
  overflow: hidden;
  border-top: var(--jp-border-width) solid var(--jp-border-color2);
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
}

.jp-DirListing-headerItem {
  padding: 4px 12px 2px;
  font-weight: 500;
}

.jp-DirListing-headerItem:hover {
  background: var(--jp-layout-color2);
}

.jp-DirListing-headerItem.jp-id-name {
  flex: 1 0 84px;
}

.jp-DirListing-headerItem.jp-id-modified {
  flex: 0 0 112px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-DirListing-headerItem.jp-id-filesize {
  flex: 0 0 75px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-id-narrow {
  display: none;
  flex: 0 0 5px;
  padding: 4px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
  color: var(--jp-border-color2);
}

.jp-DirListing-narrow .jp-id-narrow {
  display: block;
}

.jp-DirListing-narrow .jp-id-modified,
.jp-DirListing-narrow .jp-DirListing-itemModified {
  display: none;
}

.jp-DirListing-headerItem.jp-mod-selected {
  font-weight: 600;
}

/* increase specificity to override bundled default */
.jp-DirListing-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  list-style-type: none;
  overflow: auto;
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-content mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.jp-DirListing-content .jp-DirListing-item.jp-mod-selected mark {
  color: var(--jp-ui-inverse-font-color0);
}

/* Style the directory listing content when a user drops a file to upload */
.jp-DirListing.jp-mod-native-drop .jp-DirListing-content {
  outline: 5px dashed rgba(128, 128, 128, 0.5);
  outline-offset: -10px;
  cursor: copy;
}

.jp-DirListing-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 4px 12px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-DirListing-checkboxWrapper {
  /* Increases hit area of checkbox. */
  padding: 4px;
}

.jp-DirListing-header
  .jp-DirListing-checkboxWrapper
  + .jp-DirListing-headerItem {
  padding-left: 4px;
}

.jp-DirListing-content .jp-DirListing-checkboxWrapper {
  position: relative;
  left: -4px;
  margin: -4px 0 -4px -8px;
}

.jp-DirListing-checkboxWrapper.jp-mod-visible {
  visibility: visible;
}

/* For devices that support hovering, hide checkboxes until hovered, selected...
*/
@media (hover: hover) {
  .jp-DirListing-checkboxWrapper {
    visibility: hidden;
  }

  .jp-DirListing-item:hover .jp-DirListing-checkboxWrapper,
  .jp-DirListing-item.jp-mod-selected .jp-DirListing-checkboxWrapper {
    visibility: visible;
  }
}

.jp-DirListing-item[data-is-dot] {
  opacity: 75%;
}

.jp-DirListing-item.jp-mod-selected {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.jp-DirListing-item.jp-mod-dropTarget {
  background: var(--jp-brand-color3);
}

.jp-DirListing-item:hover:not(.jp-mod-selected) {
  background: var(--jp-layout-color2);
}

.jp-DirListing-itemIcon {
  flex: 0 0 20px;
  margin-right: 4px;
}

.jp-DirListing-itemText {
  flex: 1 0 64px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  user-select: none;
}

.jp-DirListing-itemText:focus {
  outline-width: 2px;
  outline-color: var(--jp-inverse-layout-color1);
  outline-style: solid;
  outline-offset: 1px;
}

.jp-DirListing-item.jp-mod-selected .jp-DirListing-itemText:focus {
  outline-color: var(--jp-layout-color1);
}

.jp-DirListing-itemModified {
  flex: 0 0 125px;
  text-align: right;
}

.jp-DirListing-itemFileSize {
  flex: 0 0 90px;
  text-align: right;
}

.jp-DirListing-editor {
  flex: 1 0 64px;
  outline: none;
  border: none;
  color: var(--jp-ui-font-color1);
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-item.jp-mod-running .jp-DirListing-itemIcon::before {
  color: var(--jp-success-color1);
  content: '\25CF';
  font-size: 8px;
  position: absolute;
  left: -8px;
}

.jp-DirListing-item.jp-mod-running.jp-mod-selected
  .jp-DirListing-itemIcon::before {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-DirListing-item.lm-mod-drag-image,
.jp-DirListing-item.jp-mod-selected.lm-mod-drag-image {
  font-size: var(--jp-ui-font-size1);
  padding-left: 4px;
  margin-left: 4px;
  width: 160px;
  background-color: var(--jp-ui-inverse-font-color2);
  box-shadow: var(--jp-elevation-z2);
  border-radius: 0;
  color: var(--jp-ui-font-color1);
  transform: translateX(-40%) translateY(-58%);
}

.jp-Document {
  min-width: 120px;
  min-height: 120px;
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Main OutputArea
| OutputArea has a list of Outputs
|----------------------------------------------------------------------------*/

.jp-OutputArea {
  overflow-y: auto;
}

.jp-OutputArea-child {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-OutputPrompt {
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-outprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
  opacity: var(--jp-cell-prompt-opacity);

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-OutputArea-prompt {
  display: table-cell;
  vertical-align: top;
}

.jp-OutputArea-output {
  display: table-cell;
  width: 100%;
  height: auto;
  overflow: auto;
  user-select: text;
  -moz-user-select: text;
  -webkit-user-select: text;
  -ms-user-select: text;
}

.jp-OutputArea .jp-RenderedText {
  padding-left: 1ch;
}

/**
 * Prompt overlay.
 */

.jp-OutputArea-promptOverlay {
  position: absolute;
  top: 0;
  width: var(--jp-cell-prompt-width);
  height: 100%;
  opacity: 0.5;
}

.jp-OutputArea-promptOverlay:hover {
  background: var(--jp-layout-color2);
  box-shadow: inset 0 0 1px var(--jp-inverse-layout-color0);
  cursor: zoom-out;
}

.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay:hover {
  cursor: zoom-in;
}

/**
 * Isolated output.
 */
.jp-OutputArea-output.jp-mod-isolated {
  width: 100%;
  display: block;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated {
  position: relative;
}

body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/* pre */

.jp-OutputArea-output pre {
  border: none;
  margin: 0;
  padding: 0;
  overflow-x: auto;
  overflow-y: auto;
  word-break: break-all;
  word-wrap: break-word;
  white-space: pre-wrap;
}

/* tables */

.jp-OutputArea-output.jp-RenderedHTMLCommon table {
  margin-left: 0;
  margin-right: 0;
}

/* description lists */

.jp-OutputArea-output dl,
.jp-OutputArea-output dt,
.jp-OutputArea-output dd {
  display: block;
}

.jp-OutputArea-output dl {
  width: 100%;
  overflow: hidden;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dt {
  font-weight: bold;
  float: left;
  width: 20%;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dd {
  float: left;
  width: 80%;
  padding: 0;
  margin: 0;
}

.jp-TrimmedOutputs pre {
  background: var(--jp-layout-color3);
  font-size: calc(var(--jp-code-font-size) * 1.4);
  text-align: center;
  text-transform: uppercase;
}

/* Hide the gutter in case of
 *  - nested output areas (e.g. in the case of output widgets)
 *  - mirrored output areas
 */
.jp-OutputArea .jp-OutputArea .jp-OutputArea-prompt {
  display: none;
}

/* Hide empty lines in the output area, for instance due to cleared widgets */
.jp-OutputArea-prompt:empty {
  padding: 0;
  border: 0;
}

/*-----------------------------------------------------------------------------
| executeResult is added to any Output-result for the display of the object
| returned by a cell
|----------------------------------------------------------------------------*/

.jp-OutputArea-output.jp-OutputArea-executeResult {
  margin-left: 0;
  width: 100%;
}

/* Text output with the Out[] prompt needs a top padding to match the
 * alignment of the Out[] prompt itself.
 */
.jp-OutputArea-executeResult .jp-RenderedText.jp-OutputArea-output {
  padding-top: var(--jp-code-padding);
  border-top: var(--jp-border-width) solid transparent;
}

/*-----------------------------------------------------------------------------
| The Stdin output
|----------------------------------------------------------------------------*/

.jp-Stdin-prompt {
  color: var(--jp-content-font-color0);
  padding-right: var(--jp-code-padding);
  vertical-align: baseline;
  flex: 0 0 auto;
}

.jp-Stdin-input {
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  color: inherit;
  background-color: inherit;
  width: 42%;
  min-width: 200px;

  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;

  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0 0.25em;
  margin: 0 0.25em;
  flex: 0 0 70%;
}

.jp-Stdin-input::placeholder {
  opacity: 0;
}

.jp-Stdin-input:focus {
  box-shadow: none;
}

.jp-Stdin-input:focus::placeholder {
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Output Area View
|----------------------------------------------------------------------------*/

.jp-LinkedOutputView .jp-OutputArea {
  height: 100%;
  display: block;
}

.jp-LinkedOutputView .jp-OutputArea-output:only-child {
  height: 100%;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

@media print {
  .jp-OutputArea-child {
    break-inside: avoid-page;
  }
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-OutputPrompt {
    display: table-row;
    text-align: left;
  }

  .jp-OutputArea-child .jp-OutputArea-output {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }
}

/* Trimmed outputs warning */
.jp-TrimmedOutputs > a {
  margin: 10px;
  text-decoration: none;
  cursor: pointer;
}

.jp-TrimmedOutputs > a:hover {
  text-decoration: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Table of Contents
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toc-active-width: 4px;
}

.jp-TableOfContents {
  display: flex;
  flex-direction: column;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  height: 100%;
}

.jp-TableOfContents-placeholder {
  text-align: center;
}

.jp-TableOfContents-placeholderContent {
  color: var(--jp-content-font-color2);
  padding: 8px;
}

.jp-TableOfContents-placeholderContent > h3 {
  margin-bottom: var(--jp-content-heading-margin-bottom);
}

.jp-TableOfContents .jp-SidePanel-content {
  overflow-y: auto;
}

.jp-TableOfContents-tree {
  margin: 4px;
}

.jp-TableOfContents ol {
  list-style-type: none;
}

/* stylelint-disable-next-line selector-max-type */
.jp-TableOfContents li > ol {
  /* Align left border with triangle icon center */
  padding-left: 11px;
}

.jp-TableOfContents-content {
  /* left margin for the active heading indicator */
  margin: 0 0 0 var(--jp-private-toc-active-width);
  padding: 0;
  background-color: var(--jp-layout-color1);
}

.jp-tocItem {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-tocItem-heading {
  display: flex;
  cursor: pointer;
}

.jp-tocItem-heading:hover {
  background-color: var(--jp-layout-color2);
}

.jp-tocItem-content {
  display: block;
  padding: 4px 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow-x: hidden;
}

.jp-tocItem-collapser {
  height: 20px;
  margin: 2px 2px 0;
  padding: 0;
  background: none;
  border: none;
  cursor: pointer;
}

.jp-tocItem-collapser:hover {
  background-color: var(--jp-layout-color3);
}

/* Active heading indicator */

.jp-tocItem-heading::before {
  content: ' ';
  background: transparent;
  width: var(--jp-private-toc-active-width);
  height: 24px;
  position: absolute;
  left: 0;
  border-radius: var(--jp-border-radius);
}

.jp-tocItem-heading.jp-tocItem-active::before {
  background-color: var(--jp-brand-color1);
}

.jp-tocItem-heading:hover.jp-tocItem-active::before {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapser {
  flex: 0 0 var(--jp-cell-collapser-width);
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
  border-radius: var(--jp-border-radius);
  opacity: 1;
}

.jp-Collapser-child {
  display: block;
  width: 100%;
  box-sizing: border-box;

  /* height: 100% doesn't work because the height of its parent is computed from content */
  position: absolute;
  top: 0;
  bottom: 0;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Hiding collapsers in print mode.

Note: input and output wrappers have "display: block" propery in print mode.
*/

@media print {
  .jp-Collapser {
    display: none;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Header/Footer
|----------------------------------------------------------------------------*/

/* Hidden by zero height by default */
.jp-CellHeader,
.jp-CellFooter {
  height: 0;
  width: 100%;
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Input
|----------------------------------------------------------------------------*/

/* All input areas */
.jp-InputArea {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-InputArea-editor {
  display: table-cell;
  overflow: hidden;
  vertical-align: top;

  /* This is the non-active, default styling */
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  background: var(--jp-cell-editor-background);
}

.jp-InputPrompt {
  display: table-cell;
  vertical-align: top;
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-inprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  opacity: var(--jp-cell-prompt-opacity);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-InputArea-editor {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }

  .jp-InputPrompt {
    display: table-row;
    text-align: left;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Placeholder {
  display: table;
  table-layout: fixed;
  width: 100%;
}

.jp-Placeholder-prompt {
  display: table-cell;
  box-sizing: border-box;
}

.jp-Placeholder-content {
  display: table-cell;
  padding: 4px 6px;
  border: 1px solid transparent;
  border-radius: 0;
  background: none;
  box-sizing: border-box;
  cursor: pointer;
}

.jp-Placeholder-contentContainer {
  display: flex;
}

.jp-Placeholder-content:hover,
.jp-InputPlaceholder > .jp-Placeholder-content:hover {
  border-color: var(--jp-layout-color3);
}

.jp-Placeholder-content .jp-MoreHorizIcon {
  width: 32px;
  height: 16px;
  border: 1px solid transparent;
  border-radius: var(--jp-border-radius);
}

.jp-Placeholder-content .jp-MoreHorizIcon:hover {
  border: 1px solid var(--jp-border-color1);
  box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.25);
  background-color: var(--jp-layout-color0);
}

.jp-PlaceholderText {
  white-space: nowrap;
  overflow-x: hidden;
  color: var(--jp-inverse-layout-color3);
  font-family: var(--jp-code-font-family);
}

.jp-InputPlaceholder > .jp-Placeholder-content {
  border-color: var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Private CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-cell-scrolling-output-offset: 5px;
}

/*-----------------------------------------------------------------------------
| Cell
|----------------------------------------------------------------------------*/

.jp-Cell {
  padding: var(--jp-cell-padding);
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Common input/output
|----------------------------------------------------------------------------*/

.jp-Cell-inputWrapper,
.jp-Cell-outputWrapper {
  display: flex;
  flex-direction: row;
  padding: 0;
  margin: 0;

  /* Added to reveal the box-shadow on the input and output collapsers. */
  overflow: visible;
}

/* Only input/output areas inside cells */
.jp-Cell-inputArea,
.jp-Cell-outputArea {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Collapser
|----------------------------------------------------------------------------*/

/* Make the output collapser disappear when there is not output, but do so
 * in a manner that leaves it in the layout and preserves its width.
 */
.jp-Cell.jp-mod-noOutputs .jp-Cell-outputCollapser {
  border: none !important;
  background: transparent !important;
}

.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputCollapser {
  min-height: var(--jp-cell-collapser-min-height);
}

/*-----------------------------------------------------------------------------
| Output
|----------------------------------------------------------------------------*/

/* Put a space between input and output when there IS output */
.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputWrapper {
  margin-top: 5px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea {
  overflow-y: auto;
  max-height: 24em;
  margin-left: var(--jp-private-cell-scrolling-output-offset);
  resize: vertical;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea[style*='height'] {
  max-height: unset;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea::after {
  content: ' ';
  box-shadow: inset 0 0 6px 2px rgb(0 0 0 / 30%);
  width: 100%;
  height: 100%;
  position: sticky;
  bottom: 0;
  top: 0;
  margin-top: -50%;
  float: left;
  display: block;
  pointer-events: none;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-child {
  padding-top: 6px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-prompt {
  width: calc(
    var(--jp-cell-prompt-width) - var(--jp-private-cell-scrolling-output-offset)
  );
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay {
  left: calc(-1 * var(--jp-private-cell-scrolling-output-offset));
}

/*-----------------------------------------------------------------------------
| CodeCell
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| MarkdownCell
|----------------------------------------------------------------------------*/

.jp-MarkdownOutput {
  display: table-cell;
  width: 100%;
  margin-top: 0;
  margin-bottom: 0;
  padding-left: var(--jp-code-padding);
}

.jp-MarkdownOutput.jp-RenderedHTMLCommon {
  overflow: auto;
}

/* collapseHeadingButton (show always if hiddenCellsButton is _not_ shown) */
.jp-collapseHeadingButton {
  display: flex;
  min-height: var(--jp-cell-collapser-min-height);
  font-size: var(--jp-code-font-size);
  position: absolute;
  background-color: transparent;
  background-size: 25px;
  background-repeat: no-repeat;
  background-position-x: center;
  background-position-y: top;
  background-image: var(--jp-icon-caret-down);
  right: 0;
  top: 0;
  bottom: 0;
}

.jp-collapseHeadingButton.jp-mod-collapsed {
  background-image: var(--jp-icon-caret-right);
}

/*
 set the container font size to match that of content
 so that the nested collapse buttons have the right size
*/
.jp-MarkdownCell .jp-InputPrompt {
  font-size: var(--jp-content-font-size1);
}

/*
  Align collapseHeadingButton with cell top header
  The font sizes are identical to the ones in packages/rendermime/style/base.css
*/
.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='1'] {
  font-size: var(--jp-content-font-size5);
  background-position-y: calc(0.3 * var(--jp-content-font-size5));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='2'] {
  font-size: var(--jp-content-font-size4);
  background-position-y: calc(0.3 * var(--jp-content-font-size4));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='3'] {
  font-size: var(--jp-content-font-size3);
  background-position-y: calc(0.3 * var(--jp-content-font-size3));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='4'] {
  font-size: var(--jp-content-font-size2);
  background-position-y: calc(0.3 * var(--jp-content-font-size2));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='5'] {
  font-size: var(--jp-content-font-size1);
  background-position-y: top;
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='6'] {
  font-size: var(--jp-content-font-size0);
  background-position-y: top;
}

/* collapseHeadingButton (show only on (hover,active) if hiddenCellsButton is shown) */
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-collapseHeadingButton {
  display: none;
}

.jp-Notebook.jp-mod-showHiddenCellsButton
  :is(.jp-MarkdownCell:hover, .jp-mod-active)
  .jp-collapseHeadingButton {
  display: flex;
}

/* showHiddenCellsButton (only show if jp-mod-showHiddenCellsButton is set, which
is a consequence of the showHiddenCellsButton option in Notebook Settings)*/
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton {
  margin-left: calc(var(--jp-cell-prompt-width) + 2 * var(--jp-code-padding));
  margin-top: var(--jp-code-padding);
  border: 1px solid var(--jp-border-color2);
  background-color: var(--jp-border-color3) !important;
  color: var(--jp-content-font-color0) !important;
  display: flex;
}

.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton:hover {
  background-color: var(--jp-border-color2) !important;
}

.jp-showHiddenCellsButton {
  display: none;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Using block instead of flex to allow the use of the break-inside CSS property for
cell outputs.
*/

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-notebook-toolbar-padding: 2px 5px 2px 2px;
}

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-NotebookPanel-toolbar {
  padding: var(--jp-notebook-toolbar-padding);

  /* disable paint containment from lumino 2.0 default strict CSS containment */
  contain: style size !important;
}

.jp-Toolbar-item.jp-Notebook-toolbarCellType .jp-select-wrapper.jp-mod-focused {
  border: none;
  box-shadow: none;
}

.jp-Notebook-toolbarCellTypeDropdown select {
  height: 24px;
  font-size: var(--jp-ui-font-size1);
  line-height: 14px;
  border-radius: 0;
  display: block;
}

.jp-Notebook-toolbarCellTypeDropdown span {
  top: 5px !important;
}

.jp-Toolbar-responsive-popup {
  position: absolute;
  height: fit-content;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: flex-end;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: var(--jp-notebook-toolbar-padding);
  z-index: 1;
  right: 0;
  top: 0;
}

.jp-Toolbar > .jp-Toolbar-responsive-opener {
  margin-left: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-Notebook-ExecutionIndicator {
  position: relative;
  display: inline-block;
  height: 100%;
  z-index: 9997;
}

.jp-Notebook-ExecutionIndicator-tooltip {
  visibility: hidden;
  height: auto;
  width: max-content;
  width: -moz-max-content;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color1);
  text-align: justify;
  border-radius: 6px;
  padding: 0 5px;
  position: fixed;
  display: table;
}

.jp-Notebook-ExecutionIndicator-tooltip.up {
  transform: translateX(-50%) translateY(-100%) translateY(-32px);
}

.jp-Notebook-ExecutionIndicator-tooltip.down {
  transform: translateX(calc(-100% + 16px)) translateY(5px);
}

.jp-Notebook-ExecutionIndicator-tooltip.hidden {
  display: none;
}

.jp-Notebook-ExecutionIndicator:hover .jp-Notebook-ExecutionIndicator-tooltip {
  visibility: visible;
}

.jp-Notebook-ExecutionIndicator span {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  color: var(--jp-ui-font-color1);
  line-height: 24px;
  display: block;
}

.jp-Notebook-ExecutionIndicator-progress-bar {
  display: flex;
  justify-content: center;
  height: 100%;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*
 * Execution indicator
 */
.jp-tocItem-content::after {
  content: '';

  /* Must be identical to form a circle */
  width: 12px;
  height: 12px;
  background: none;
  border: none;
  position: absolute;
  right: 0;
}

.jp-tocItem-content[data-running='0']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background: none;
}

.jp-tocItem-content[data-running='1']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background-color: var(--jp-inverse-layout-color3);
}

.jp-tocItem-content[data-running='0'],
.jp-tocItem-content[data-running='1'] {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Notebook-footer {
  height: 27px;
  margin-left: calc(
    var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
      var(--jp-cell-padding)
  );
  width: calc(
    100% -
      (
        var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
          var(--jp-cell-padding) + var(--jp-cell-padding)
      )
  );
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  color: var(--jp-ui-font-color3);
  margin-top: 6px;
  background: none;
  cursor: pointer;
}

.jp-Notebook-footer:focus {
  border-color: var(--jp-cell-editor-active-border-color);
}

/* For devices that support hovering, hide footer until hover */
@media (hover: hover) {
  .jp-Notebook-footer {
    opacity: 0;
  }

  .jp-Notebook-footer:focus,
  .jp-Notebook-footer:hover {
    opacity: 1;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Imports
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-side-by-side-output-size: 1fr;
  --jp-side-by-side-resized-cell: var(--jp-side-by-side-output-size);
  --jp-private-notebook-dragImage-width: 304px;
  --jp-private-notebook-dragImage-height: 36px;
  --jp-private-notebook-selected-color: var(--md-blue-400);
  --jp-private-notebook-active-color: var(--md-green-400);
}

/*-----------------------------------------------------------------------------
| Notebook
|----------------------------------------------------------------------------*/

/* stylelint-disable selector-max-class */

.jp-NotebookPanel {
  display: block;
  height: 100%;
}

.jp-NotebookPanel.jp-Document {
  min-width: 240px;
  min-height: 120px;
}

.jp-Notebook {
  padding: var(--jp-notebook-padding);
  outline: none;
  overflow: auto;
  background: var(--jp-layout-color0);
}

.jp-Notebook.jp-mod-scrollPastEnd::after {
  display: block;
  content: '';
  min-height: var(--jp-notebook-scroll-padding);
}

.jp-MainAreaWidget-ContainStrict .jp-Notebook * {
  contain: strict;
}

.jp-Notebook .jp-Cell {
  overflow: visible;
}

.jp-Notebook .jp-Cell .jp-InputPrompt {
  cursor: move;
}

/*-----------------------------------------------------------------------------
| Notebook state related styling
|
| The notebook and cells each have states, here are the possibilities:
|
| - Notebook
|   - Command
|   - Edit
| - Cell
|   - None
|   - Active (only one can be active)
|   - Selected (the cells actions are applied to)
|   - Multiselected (when multiple selected, the cursor)
|   - No outputs
|----------------------------------------------------------------------------*/

/* Command or edit modes */

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-InputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-OutputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

/* cell is active */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser {
  background: var(--jp-brand-color1);
}

/* cell is dirty */
.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt {
  color: var(--jp-warn-color1);
}

.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt::before {
  color: var(--jp-warn-color1);
  content: '•';
}

.jp-Notebook .jp-Cell.jp-mod-active.jp-mod-dirty .jp-Collapser {
  background: var(--jp-warn-color1);
}

/* collapser is hovered */
.jp-Notebook .jp-Cell .jp-Collapser:hover {
  box-shadow: var(--jp-elevation-z2);
  background: var(--jp-brand-color1);
  opacity: var(--jp-cell-collapser-not-active-hover-opacity);
}

/* cell is active and collapser is hovered */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser:hover {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/* Command mode */

.jp-Notebook.jp-mod-commandMode .jp-Cell.jp-mod-selected {
  background: var(--jp-notebook-multiselected-color);
}

.jp-Notebook.jp-mod-commandMode
  .jp-Cell.jp-mod-active.jp-mod-selected:not(.jp-mod-multiSelected) {
  background: transparent;
}

/* Edit mode */

.jp-Notebook.jp-mod-editMode .jp-Cell.jp-mod-active .jp-InputArea-editor {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-cell-editor-active-background);
}

/*-----------------------------------------------------------------------------
| Notebook drag and drop
|----------------------------------------------------------------------------*/

.jp-Notebook-cell.jp-mod-dropSource {
  opacity: 0.5;
}

.jp-Notebook-cell.jp-mod-dropTarget,
.jp-Notebook.jp-mod-commandMode
  .jp-Notebook-cell.jp-mod-active.jp-mod-selected.jp-mod-dropTarget {
  border-top-color: var(--jp-private-notebook-selected-color);
  border-top-style: solid;
  border-top-width: 2px;
}

.jp-dragImage {
  display: block;
  flex-direction: row;
  width: var(--jp-private-notebook-dragImage-width);
  height: var(--jp-private-notebook-dragImage-height);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
  overflow: visible;
}

.jp-dragImage-singlePrompt {
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

.jp-dragImage .jp-dragImage-content {
  flex: 1 1 auto;
  z-index: 2;
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  line-height: var(--jp-code-line-height);
  padding: var(--jp-code-padding);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background-color);
  color: var(--jp-content-font-color3);
  text-align: left;
  margin: 4px 4px 4px 0;
}

.jp-dragImage .jp-dragImage-prompt {
  flex: 0 0 auto;
  min-width: 36px;
  color: var(--jp-cell-inprompt-font-color);
  padding: var(--jp-code-padding);
  padding-left: 12px;
  font-family: var(--jp-cell-prompt-font-family);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: 1.9;
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
}

.jp-dragImage-multipleBack {
  z-index: -1;
  position: absolute;
  height: 32px;
  width: 300px;
  top: 8px;
  left: 8px;
  background: var(--jp-layout-color2);
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

/*-----------------------------------------------------------------------------
| Cell toolbar
|----------------------------------------------------------------------------*/

.jp-NotebookTools {
  display: block;
  min-width: var(--jp-sidebar-min-width);
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
    * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  overflow: auto;
}

.jp-ActiveCellTool {
  padding: 12px 0;
  display: flex;
}

.jp-ActiveCellTool-Content {
  flex: 1 1 auto;
}

.jp-ActiveCellTool .jp-ActiveCellTool-CellContent {
  background: var(--jp-cell-editor-background);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  min-height: 29px;
}

.jp-ActiveCellTool .jp-InputPrompt {
  min-width: calc(var(--jp-cell-prompt-width) * 0.75);
}

.jp-ActiveCellTool-CellContent > pre {
  padding: 5px 4px;
  margin: 0;
  white-space: normal;
}

.jp-MetadataEditorTool {
  flex-direction: column;
  padding: 12px 0;
}

.jp-RankedPanel > :not(:first-child) {
  margin-top: 12px;
}

.jp-KeySelector select.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: var(--jp-border-width) solid var(--jp-border-color1);
}

.jp-KeySelector label,
.jp-MetadataEditorTool label,
.jp-NumberSetter label {
  line-height: 1.4;
}

.jp-NotebookTools .jp-select-wrapper {
  margin-top: 4px;
  margin-bottom: 0;
}

.jp-NumberSetter input {
  width: 100%;
  margin-top: 4px;
}

.jp-NotebookTools .jp-Collapse {
  margin-top: 16px;
}

/*-----------------------------------------------------------------------------
| Presentation Mode (.jp-mod-presentationMode)
|----------------------------------------------------------------------------*/

.jp-mod-presentationMode .jp-Notebook {
  --jp-content-font-size1: var(--jp-content-presentation-font-size1);
  --jp-code-font-size: var(--jp-code-presentation-font-size);
}

.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-InputPrompt,
.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-OutputPrompt {
  flex: 0 0 110px;
}

/*-----------------------------------------------------------------------------
| Side-by-side Mode (.jp-mod-sideBySide)
|----------------------------------------------------------------------------*/
.jp-mod-sideBySide.jp-Notebook .jp-Notebook-cell {
  margin-top: 3em;
  margin-bottom: 3em;
  margin-left: 5%;
  margin-right: 5%;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell {
  display: grid;
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-output-size)
    );
  grid-template-rows: auto minmax(0, 1fr) auto;
  grid-template-areas:
    'header header header'
    'input handle output'
    'footer footer footer';
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell.jp-mod-resizedCell {
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-resized-cell)
    );
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellHeader {
  grid-area: header;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-inputWrapper {
  grid-area: input;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-outputWrapper {
  /* overwrite the default margin (no vertical separation needed in side by side move */
  margin-top: 0;
  grid-area: output;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellFooter {
  grid-area: footer;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle {
  grid-area: handle;
  user-select: none;
  display: block;
  height: 100%;
  cursor: ew-resize;
  padding: 0 var(--jp-cell-padding);
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle::after {
  content: '';
  display: block;
  background: var(--jp-border-color2);
  height: 100%;
  width: 5px;
}

.jp-mod-sideBySide.jp-Notebook
  .jp-CodeCell.jp-mod-resizedCell
  .jp-CellResizeHandle::after {
  background: var(--jp-border-color0);
}

.jp-CellResizeHandle {
  display: none;
}

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Cell-Placeholder {
  padding-left: 55px;
}

.jp-Cell-Placeholder-wrapper {
  background: #fff;
  border: 1px solid;
  border-color: #e5e6e9 #dfe0e4 #d0d1d5;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  margin: 10px 15px;
}

.jp-Cell-Placeholder-wrapper-inner {
  padding: 15px;
  position: relative;
}

.jp-Cell-Placeholder-wrapper-body {
  background-repeat: repeat;
  background-size: 50% auto;
}

.jp-Cell-Placeholder-wrapper-body div {
  background: #f6f7f8;
  background-image: -webkit-linear-gradient(
    left,
    #f6f7f8 0%,
    #edeef1 20%,
    #f6f7f8 40%,
    #f6f7f8 100%
  );
  background-repeat: no-repeat;
  background-size: 800px 104px;
  height: 104px;
  position: absolute;
  right: 15px;
  left: 15px;
  top: 15px;
}

div.jp-Cell-Placeholder-h1 {
  top: 20px;
  height: 20px;
  left: 15px;
  width: 150px;
}

div.jp-Cell-Placeholder-h2 {
  left: 15px;
  top: 50px;
  height: 10px;
  width: 100px;
}

div.jp-Cell-Placeholder-content-1,
div.jp-Cell-Placeholder-content-2,
div.jp-Cell-Placeholder-content-3 {
  left: 15px;
  right: 15px;
  height: 10px;
}

div.jp-Cell-Placeholder-content-1 {
  top: 100px;
}

div.jp-Cell-Placeholder-content-2 {
  top: 120px;
}

div.jp-Cell-Placeholder-content-3 {
  top: 140px;
}

</style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
The following CSS variables define the main, public API for styling JupyterLab.
These variables should be used by all plugins wherever possible. In other
words, plugins should not define custom colors, sizes, etc unless absolutely
necessary. This enables users to change the visual theme of JupyterLab
by changing these variables.

Many variables appear in an ordered sequence (0,1,2,3). These sequences
are designed to work well together, so for example, `--jp-border-color1` should
be used with `--jp-layout-color1`. The numbers have the following meanings:

* 0: super-primary, reserved for special emphasis
* 1: primary, most important under normal situations
* 2: secondary, next most important under normal situations
* 3: tertiary, next most important under normal situations

Throughout JupyterLab, we are mostly following principles from Google's
Material Design when selecting colors. We are not, however, following
all of MD as it is not optimized for dense, information rich UIs.
*/

:root {
  /* Elevation
   *
   * We style box-shadows using Material Design's idea of elevation. These particular numbers are taken from here:
   *
   * https://github.com/material-components/material-components-web
   * https://material-components-web.appspot.com/elevation.html
   */

  --jp-shadow-base-lightness: 0;
  --jp-shadow-umbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.2
  );
  --jp-shadow-penumbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.14
  );
  --jp-shadow-ambient-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.12
  );
  --jp-elevation-z0: none;
  --jp-elevation-z1: 0 2px 1px -1px var(--jp-shadow-umbra-color),
    0 1px 1px 0 var(--jp-shadow-penumbra-color),
    0 1px 3px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z2: 0 3px 1px -2px var(--jp-shadow-umbra-color),
    0 2px 2px 0 var(--jp-shadow-penumbra-color),
    0 1px 5px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z4: 0 2px 4px -1px var(--jp-shadow-umbra-color),
    0 4px 5px 0 var(--jp-shadow-penumbra-color),
    0 1px 10px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z6: 0 3px 5px -1px var(--jp-shadow-umbra-color),
    0 6px 10px 0 var(--jp-shadow-penumbra-color),
    0 1px 18px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z8: 0 5px 5px -3px var(--jp-shadow-umbra-color),
    0 8px 10px 1px var(--jp-shadow-penumbra-color),
    0 3px 14px 2px var(--jp-shadow-ambient-color);
  --jp-elevation-z12: 0 7px 8px -4px var(--jp-shadow-umbra-color),
    0 12px 17px 2px var(--jp-shadow-penumbra-color),
    0 5px 22px 4px var(--jp-shadow-ambient-color);
  --jp-elevation-z16: 0 8px 10px -5px var(--jp-shadow-umbra-color),
    0 16px 24px 2px var(--jp-shadow-penumbra-color),
    0 6px 30px 5px var(--jp-shadow-ambient-color);
  --jp-elevation-z20: 0 10px 13px -6px var(--jp-shadow-umbra-color),
    0 20px 31px 3px var(--jp-shadow-penumbra-color),
    0 8px 38px 7px var(--jp-shadow-ambient-color);
  --jp-elevation-z24: 0 11px 15px -7px var(--jp-shadow-umbra-color),
    0 24px 38px 3px var(--jp-shadow-penumbra-color),
    0 9px 46px 8px var(--jp-shadow-ambient-color);

  /* Borders
   *
   * The following variables, specify the visual styling of borders in JupyterLab.
   */

  --jp-border-width: 1px;
  --jp-border-color0: var(--md-grey-400);
  --jp-border-color1: var(--md-grey-400);
  --jp-border-color2: var(--md-grey-300);
  --jp-border-color3: var(--md-grey-200);
  --jp-inverse-border-color: var(--md-grey-600);
  --jp-border-radius: 2px;

  /* UI Fonts
   *
   * The UI font CSS variables are used for the typography all of the JupyterLab
   * user interface elements that are not directly user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-ui-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-ui-font-scale-factor: 1.2;
  --jp-ui-font-size0: 0.83333em;
  --jp-ui-font-size1: 13px; /* Base font size */
  --jp-ui-font-size2: 1.2em;
  --jp-ui-font-size3: 1.44em;
  --jp-ui-font-family: system-ui, -apple-system, blinkmacsystemfont, 'Segoe UI',
    helvetica, arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
    'Segoe UI Symbol';

  /*
   * Use these font colors against the corresponding main layout colors.
   * In a light theme, these go from dark to light.
   */

  /* Defaults use Material Design specification */
  --jp-ui-font-color0: rgba(0, 0, 0, 1);
  --jp-ui-font-color1: rgba(0, 0, 0, 0.87);
  --jp-ui-font-color2: rgba(0, 0, 0, 0.54);
  --jp-ui-font-color3: rgba(0, 0, 0, 0.38);

  /*
   * Use these against the brand/accent/warn/error colors.
   * These will typically go from light to darker, in both a dark and light theme.
   */

  --jp-ui-inverse-font-color0: rgba(255, 255, 255, 1);
  --jp-ui-inverse-font-color1: rgba(255, 255, 255, 1);
  --jp-ui-inverse-font-color2: rgba(255, 255, 255, 0.7);
  --jp-ui-inverse-font-color3: rgba(255, 255, 255, 0.5);

  /* Content Fonts
   *
   * Content font variables are used for typography of user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-content-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-content-line-height: 1.6;
  --jp-content-font-scale-factor: 1.2;
  --jp-content-font-size0: 0.83333em;
  --jp-content-font-size1: 14px; /* Base font size */
  --jp-content-font-size2: 1.2em;
  --jp-content-font-size3: 1.44em;
  --jp-content-font-size4: 1.728em;
  --jp-content-font-size5: 2.0736em;

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-content-presentation-font-size1: 17px;
  --jp-content-heading-line-height: 1;
  --jp-content-heading-margin-top: 1.2em;
  --jp-content-heading-margin-bottom: 0.8em;
  --jp-content-heading-font-weight: 500;

  /* Defaults use Material Design specification */
  --jp-content-font-color0: rgba(0, 0, 0, 1);
  --jp-content-font-color1: rgba(0, 0, 0, 0.87);
  --jp-content-font-color2: rgba(0, 0, 0, 0.54);
  --jp-content-font-color3: rgba(0, 0, 0, 0.38);
  --jp-content-link-color: var(--md-blue-900);
  --jp-content-font-family: system-ui, -apple-system, blinkmacsystemfont,
    'Segoe UI', helvetica, arial, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol';

  /*
   * Code Fonts
   *
   * Code font variables are used for typography of code and other monospaces content.
   */

  --jp-code-font-size: 13px;
  --jp-code-line-height: 1.3077; /* 17px for 13px base */
  --jp-code-padding: 5px; /* 5px for 13px base, codemirror highlighting needs integer px value */
  --jp-code-font-family-default: menlo, consolas, 'DejaVu Sans Mono', monospace;
  --jp-code-font-family: var(--jp-code-font-family-default);

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-code-presentation-font-size: 16px;

  /* may need to tweak cursor width if you change font size */
  --jp-code-cursor-width0: 1.4px;
  --jp-code-cursor-width1: 2px;
  --jp-code-cursor-width2: 4px;

  /* Layout
   *
   * The following are the main layout colors use in JupyterLab. In a light
   * theme these would go from light to dark.
   */

  --jp-layout-color0: white;
  --jp-layout-color1: white;
  --jp-layout-color2: var(--md-grey-200);
  --jp-layout-color3: var(--md-grey-400);
  --jp-layout-color4: var(--md-grey-600);

  /* Inverse Layout
   *
   * The following are the inverse layout colors use in JupyterLab. In a light
   * theme these would go from dark to light.
   */

  --jp-inverse-layout-color0: #111;
  --jp-inverse-layout-color1: var(--md-grey-900);
  --jp-inverse-layout-color2: var(--md-grey-800);
  --jp-inverse-layout-color3: var(--md-grey-700);
  --jp-inverse-layout-color4: var(--md-grey-600);

  /* Brand/accent */

  --jp-brand-color0: var(--md-blue-900);
  --jp-brand-color1: var(--md-blue-700);
  --jp-brand-color2: var(--md-blue-300);
  --jp-brand-color3: var(--md-blue-100);
  --jp-brand-color4: var(--md-blue-50);
  --jp-accent-color0: var(--md-green-900);
  --jp-accent-color1: var(--md-green-700);
  --jp-accent-color2: var(--md-green-300);
  --jp-accent-color3: var(--md-green-100);

  /* State colors (warn, error, success, info) */

  --jp-warn-color0: var(--md-orange-900);
  --jp-warn-color1: var(--md-orange-700);
  --jp-warn-color2: var(--md-orange-300);
  --jp-warn-color3: var(--md-orange-100);
  --jp-error-color0: var(--md-red-900);
  --jp-error-color1: var(--md-red-700);
  --jp-error-color2: var(--md-red-300);
  --jp-error-color3: var(--md-red-100);
  --jp-success-color0: var(--md-green-900);
  --jp-success-color1: var(--md-green-700);
  --jp-success-color2: var(--md-green-300);
  --jp-success-color3: var(--md-green-100);
  --jp-info-color0: var(--md-cyan-900);
  --jp-info-color1: var(--md-cyan-700);
  --jp-info-color2: var(--md-cyan-300);
  --jp-info-color3: var(--md-cyan-100);

  /* Cell specific styles */

  --jp-cell-padding: 5px;
  --jp-cell-collapser-width: 8px;
  --jp-cell-collapser-min-height: 20px;
  --jp-cell-collapser-not-active-hover-opacity: 0.6;
  --jp-cell-editor-background: var(--md-grey-100);
  --jp-cell-editor-border-color: var(--md-grey-300);
  --jp-cell-editor-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-cell-editor-active-background: var(--jp-layout-color0);
  --jp-cell-editor-active-border-color: var(--jp-brand-color1);
  --jp-cell-prompt-width: 64px;
  --jp-cell-prompt-font-family: var(--jp-code-font-family-default);
  --jp-cell-prompt-letter-spacing: 0;
  --jp-cell-prompt-opacity: 1;
  --jp-cell-prompt-not-active-opacity: 0.5;
  --jp-cell-prompt-not-active-font-color: var(--md-grey-700);

  /* A custom blend of MD grey and blue 600
   * See https://meyerweb.com/eric/tools/color-blend/#546E7A:1E88E5:5:hex */
  --jp-cell-inprompt-font-color: #307fc1;

  /* A custom blend of MD grey and orange 600
   * https://meyerweb.com/eric/tools/color-blend/#546E7A:F4511E:5:hex */
  --jp-cell-outprompt-font-color: #bf5b3d;

  /* Notebook specific styles */

  --jp-notebook-padding: 10px;
  --jp-notebook-select-background: var(--jp-layout-color1);
  --jp-notebook-multiselected-color: var(--md-blue-50);

  /* The scroll padding is calculated to fill enough space at the bottom of the
  notebook to show one single-line cell (with appropriate padding) at the top
  when the notebook is scrolled all the way to the bottom. We also subtract one
  pixel so that no scrollbar appears if we have just one single-line cell in the
  notebook. This padding is to enable a 'scroll past end' feature in a notebook.
  */
  --jp-notebook-scroll-padding: calc(
    100% - var(--jp-code-font-size) * var(--jp-code-line-height) -
      var(--jp-code-padding) - var(--jp-cell-padding) - 1px
  );

  /* Rendermime styles */

  --jp-rendermime-error-background: #fdd;
  --jp-rendermime-table-row-background: var(--md-grey-100);
  --jp-rendermime-table-row-hover-background: var(--md-light-blue-50);

  /* Dialog specific styles */

  --jp-dialog-background: rgba(0, 0, 0, 0.25);

  /* Console specific styles */

  --jp-console-padding: 10px;

  /* Toolbar specific styles */

  --jp-toolbar-border-color: var(--jp-border-color1);
  --jp-toolbar-micro-height: 8px;
  --jp-toolbar-background: var(--jp-layout-color1);
  --jp-toolbar-box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.24);
  --jp-toolbar-header-margin: 4px 4px 0 4px;
  --jp-toolbar-active-background: var(--md-grey-300);

  /* Statusbar specific styles */

  --jp-statusbar-height: 24px;

  /* Input field styles */

  --jp-input-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-input-active-background: var(--jp-layout-color1);
  --jp-input-hover-background: var(--jp-layout-color1);
  --jp-input-background: var(--md-grey-100);
  --jp-input-border-color: var(--jp-inverse-border-color);
  --jp-input-active-border-color: var(--jp-brand-color1);
  --jp-input-active-box-shadow-color: rgba(19, 124, 189, 0.3);

  /* General editor styles */

  --jp-editor-selected-background: #d9d9d9;
  --jp-editor-selected-focused-background: #d7d4f0;
  --jp-editor-cursor-color: var(--jp-ui-font-color0);

  /* Code mirror specific styles */

  --jp-mirror-editor-keyword-color: #008000;
  --jp-mirror-editor-atom-color: #88f;
  --jp-mirror-editor-number-color: #080;
  --jp-mirror-editor-def-color: #00f;
  --jp-mirror-editor-variable-color: var(--md-grey-900);
  --jp-mirror-editor-variable-2-color: rgb(0, 54, 109);
  --jp-mirror-editor-variable-3-color: #085;
  --jp-mirror-editor-punctuation-color: #05a;
  --jp-mirror-editor-property-color: #05a;
  --jp-mirror-editor-operator-color: #a2f;
  --jp-mirror-editor-comment-color: #408080;
  --jp-mirror-editor-string-color: #ba2121;
  --jp-mirror-editor-string-2-color: #708;
  --jp-mirror-editor-meta-color: #a2f;
  --jp-mirror-editor-qualifier-color: #555;
  --jp-mirror-editor-builtin-color: #008000;
  --jp-mirror-editor-bracket-color: #997;
  --jp-mirror-editor-tag-color: #170;
  --jp-mirror-editor-attribute-color: #00c;
  --jp-mirror-editor-header-color: blue;
  --jp-mirror-editor-quote-color: #090;
  --jp-mirror-editor-link-color: #00c;
  --jp-mirror-editor-error-color: #f00;
  --jp-mirror-editor-hr-color: #999;

  /*
    RTC user specific colors.
    These colors are used for the cursor, username in the editor,
    and the icon of the user.
  */

  --jp-collaborator-color1: #ffad8e;
  --jp-collaborator-color2: #dac83d;
  --jp-collaborator-color3: #72dd76;
  --jp-collaborator-color4: #00e4d0;
  --jp-collaborator-color5: #45d4ff;
  --jp-collaborator-color6: #e2b1ff;
  --jp-collaborator-color7: #ff9de6;

  /* Vega extension styles */

  --jp-vega-background: white;

  /* Sidebar-related styles */

  --jp-sidebar-min-width: 250px;

  /* Search-related styles */

  --jp-search-toggle-off-opacity: 0.5;
  --jp-search-toggle-hover-opacity: 0.8;
  --jp-search-toggle-on-opacity: 1;
  --jp-search-selected-match-background-color: rgb(245, 200, 0);
  --jp-search-selected-match-color: black;
  --jp-search-unselected-match-background-color: var(
    --jp-inverse-layout-color0
  );
  --jp-search-unselected-match-color: var(--jp-ui-inverse-font-color0);

  /* Icon colors that work well with light or dark backgrounds */
  --jp-icon-contrast-color0: var(--md-purple-600);
  --jp-icon-contrast-color1: var(--md-green-600);
  --jp-icon-contrast-color2: var(--md-pink-600);
  --jp-icon-contrast-color3: var(--md-blue-600);

  /* Button colors */
  --jp-accept-color-normal: var(--md-blue-700);
  --jp-accept-color-hover: var(--md-blue-800);
  --jp-accept-color-active: var(--md-blue-900);
  --jp-warn-color-normal: var(--md-red-700);
  --jp-warn-color-hover: var(--md-red-800);
  --jp-warn-color-active: var(--md-red-900);
  --jp-reject-color-normal: var(--md-grey-600);
  --jp-reject-color-hover: var(--md-grey-700);
  --jp-reject-color-active: var(--md-grey-800);

  /* File or activity icons and switch semantic variables */
  --jp-jupyter-icon-color: #f37626;
  --jp-notebook-icon-color: #f37626;
  --jp-json-icon-color: var(--md-orange-700);
  --jp-console-icon-background-color: var(--md-blue-700);
  --jp-console-icon-color: white;
  --jp-terminal-icon-background-color: var(--md-grey-800);
  --jp-terminal-icon-color: var(--md-grey-200);
  --jp-text-editor-icon-color: var(--md-grey-700);
  --jp-inspector-icon-color: var(--md-grey-700);
  --jp-switch-color: var(--md-grey-400);
  --jp-switch-true-position-color: var(--md-orange-900);
}
</style>
<style type="text/css">
/* Force rendering true colors when outputing to pdf */
* {
  -webkit-print-color-adjust: exact;
}

/* Misc */
a.anchor-link {
  display: none;
}

/* Input area styling */
.jp-InputArea {
  overflow: hidden;
}

.jp-InputArea-editor {
  overflow: hidden;
}

.cm-editor.cm-s-jupyter .highlight pre {
/* weird, but --jp-code-padding defined to be 5px but 4px horizontal padding is hardcoded for pre.cm-line */
  padding: var(--jp-code-padding) 4px;
  margin: 0;

  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;

}

.jp-OutputArea-output pre {
  line-height: inherit;
  font-family: inherit;
}

.jp-RenderedText pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
}

/* Hiding the collapser by default */
.jp-Collapser {
  display: none;
}

@page {
    margin: 0.5in; /* Margin for each printed piece of paper */
}

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}
</style>
<!-- Load mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML-full,Safe"> </script>
<!-- MathJax configuration -->
<script type="text/x-mathjax-config">
    init_mathjax = function() {
        if (window.MathJax) {
        // MathJax loaded
            MathJax.Hub.Config({
                TeX: {
                    equationNumbers: {
                    autoNumber: "AMS",
                    useLabelIds: true
                    }
                },
                tex2jax: {
                    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                    processEscapes: true,
                    processEnvironments: true
                },
                displayAlign: 'center',
                CommonHTML: {
                    linebreaks: {
                    automatic: true
                    }
                }
            });

            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        }
    }
    init_mathjax();
    </script>
<!-- End of mathjax configuration --><script type="module">
  document.addEventListener("DOMContentLoaded", async () => {
    const diagrams = document.querySelectorAll(".jp-Mermaid > pre.mermaid");
    // do not load mermaidjs if not needed
    if (!diagrams.length) {
      return;
    }
    const mermaid = (await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.0/mermaid.esm.min.mjs")).default;
    const parser = new DOMParser();

    mermaid.initialize({
      maxTextSize: 100000,
      startOnLoad: false,
      fontFamily: window
        .getComputedStyle(document.body)
        .getPropertyValue("--jp-ui-font-family"),
      theme: document.querySelector("body[data-jp-theme-light='true']")
        ? "default"
        : "dark",
    });

    let _nextMermaidId = 0;

    function makeMermaidImage(svg) {
      const img = document.createElement("img");
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const svgEl = doc.querySelector("svg");
      const { maxWidth } = svgEl?.style || {};
      const firstTitle = doc.querySelector("title");
      const firstDesc = doc.querySelector("desc");

      img.setAttribute("src", `data:image/svg+xml,${encodeURIComponent(svg)}`);
      if (maxWidth) {
        img.width = parseInt(maxWidth);
      }
      if (firstTitle) {
        img.setAttribute("alt", firstTitle.textContent);
      }
      if (firstDesc) {
        const caption = document.createElement("figcaption");
        caption.className = "sr-only";
        caption.textContent = firstDesc.textContent;
        return [img, caption];
      }
      return [img];
    }

    async function makeMermaidError(text) {
      let errorMessage = "";
      try {
        await mermaid.parse(text);
      } catch (err) {
        errorMessage = `${err}`;
      }

      const result = document.createElement("details");
      result.className = 'jp-RenderedMermaid-Details';
      const summary = document.createElement("summary");
      summary.className = 'jp-RenderedMermaid-Summary';
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.innerText = text;
      pre.appendChild(code);
      summary.appendChild(pre);
      result.appendChild(summary);

      const warning = document.createElement("pre");
      warning.innerText = errorMessage;
      result.appendChild(warning);
      return [result];
    }

    async function renderOneMarmaid(src) {
      const id = `jp-mermaid-${_nextMermaidId++}`;
      const parent = src.parentNode;
      let raw = src.textContent.trim();
      const el = document.createElement("div");
      el.style.visibility = "hidden";
      document.body.appendChild(el);
      let results = null;
      let output = null;
      try {
        const { svg } = await mermaid.render(id, raw, el);
        results = makeMermaidImage(svg);
        output = document.createElement("figure");
        results.map(output.appendChild, output);
      } catch (err) {
        parent.classList.add("jp-mod-warning");
        results = await makeMermaidError(raw);
        output = results[0];
      } finally {
        el.remove();
      }
      parent.classList.add("jp-RenderedMermaid");
      parent.appendChild(output);
    }

    void Promise.all([...diagrams].map(renderOneMarmaid));
  });
</script>
<style>
  .jp-Mermaid:not(.jp-RenderedMermaid) {
    display: none;
  }

  .jp-RenderedMermaid {
    overflow: auto;
    display: flex;
  }

  .jp-RenderedMermaid.jp-mod-warning {
    width: auto;
    padding: 0.5em;
    margin-top: 0.5em;
    border: var(--jp-border-width) solid var(--jp-warn-color2);
    border-radius: var(--jp-border-radius);
    color: var(--jp-ui-font-color1);
    font-size: var(--jp-ui-font-size1);
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .jp-RenderedMermaid figure {
    margin: 0;
    overflow: auto;
    max-width: 100%;
  }

  .jp-RenderedMermaid img {
    max-width: 100%;
  }

  .jp-RenderedMermaid-Details > pre {
    margin-top: 1em;
  }

  .jp-RenderedMermaid-Summary {
    color: var(--jp-warn-color2);
  }

  .jp-RenderedMermaid:not(.jp-mod-warning) pre {
    display: none;
  }

  .jp-RenderedMermaid-Summary > pre {
    display: inline-block;
    white-space: normal;
  }
</style>
<!-- End of mermaid configuration --></head>
<body class="jp-Notebook" data-jp-theme-light="true" data-jp-theme-name="JupyterLab Light">
<main>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=62483d72-c6d3-49ae-98d7-683e6b202f81">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h1 id="Anime-Recommendation-Model">Anime Recommendation Model<a class="anchor-link" href="#Anime-Recommendation-Model">¶</a></h1>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=d121c93d-7056-4d5d-8a0c-ff33a6e1bf5f">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h4 id="Original-Author:-Thien-An-Bui">Original Author: Thien-An Bui<a class="anchor-link" href="#Original-Author:-Thien-An-Bui">¶</a></h4>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=06dfd109-a792-4ed3-8fa0-45eb367b738e">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="Load-in-Libraries">Load in Libraries<a class="anchor-link" href="#Load-in-Libraries">¶</a></h3>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=88bd174d">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [2]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cosine</span>

<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1242</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=ccc8d6a5">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="Load-in-the-Data">Load in the Data<a class="anchor-link" href="#Load-in-the-Data">¶</a></h3>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=f9642b61">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [4]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Load the data from the CSV file</span>
<span class="n">animes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'animes.csv'</span><span class="p">)</span>
<span class="n">users</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'profiles_modified.csv'</span><span class="p">)</span>

<span class="c1"># Handle the 'aired' column in the animes dataset</span>
<span class="k">def</span> <span class="nf">parse_aired_date</span><span class="p">(</span><span class="n">date_range</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">date_range</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="c1"># Split the range and take the start date</span>
    <span class="n">start_date</span> <span class="o">=</span> <span class="n">date_range</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">' to '</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">'%b </span><span class="si">%d</span><span class="s1">, %Y'</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">'coerce'</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

<span class="n">animes</span><span class="p">[</span><span class="s1">'aired_start'</span><span class="p">]</span> <span class="o">=</span> <span class="n">animes</span><span class="p">[</span><span class="s1">'aired'</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">parse_aired_date</span><span class="p">)</span>

<span class="c1"># Handle the 'birthday' column in the users dataset</span>
<span class="k">def</span> <span class="nf">parse_birthday</span><span class="p">(</span><span class="n">birthday</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">birthday</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">birthday</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">'</span><span class="si">%d</span><span class="s1">-%b-%y'</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">'coerce'</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

<span class="n">users</span><span class="p">[</span><span class="s1">'birthday_parsed'</span><span class="p">]</span> <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="s1">'birthday'</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">parse_birthday</span><span class="p">)</span>

<span class="c1"># Print dataset shapes for confirmation</span>
<span class="nb">print</span><span class="p">(</span><span class="n">animes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>(19311, 13)
(81727, 7)
</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=fbba80ef">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [5]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">animes</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[5]:</div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/html" tabindex="0">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>uid</th>
<th>title</th>
<th>synopsis</th>
<th>genre</th>
<th>aired</th>
<th>episodes</th>
<th>members</th>
<th>popularity</th>
<th>ranked</th>
<th>score</th>
<th>img_url</th>
<th>link</th>
<th>aired_start</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>28891</td>
<td>Haikyuu!! Second Season</td>
<td>Following their participation at the Inter-Hig...</td>
<td>['Comedy', 'Sports', 'Drama', 'School', 'Shoun...</td>
<td>Oct 4, 2015 to Mar 27, 2016</td>
<td>25.0</td>
<td>489888</td>
<td>141</td>
<td>25.0</td>
<td>8.82</td>
<td>https://cdn.myanimelist.net/images/anime/9/766...</td>
<td>https://myanimelist.net/anime/28891/Haikyuu_Se...</td>
<td>2015-10-04</td>
</tr>
<tr>
<th>1</th>
<td>23273</td>
<td>Shigatsu wa Kimi no Uso</td>
<td>Music accompanies the path of the human metron...</td>
<td>['Drama', 'Music', 'Romance', 'School', 'Shoun...</td>
<td>Oct 10, 2014 to Mar 20, 2015</td>
<td>22.0</td>
<td>995473</td>
<td>28</td>
<td>24.0</td>
<td>8.83</td>
<td>https://cdn.myanimelist.net/images/anime/3/671...</td>
<td>https://myanimelist.net/anime/23273/Shigatsu_w...</td>
<td>2014-10-10</td>
</tr>
<tr>
<th>2</th>
<td>34599</td>
<td>Made in Abyss</td>
<td>The Abyss—a gaping chasm stretching down into ...</td>
<td>['Sci-Fi', 'Adventure', 'Mystery', 'Drama', 'F...</td>
<td>Jul 7, 2017 to Sep 29, 2017</td>
<td>13.0</td>
<td>581663</td>
<td>98</td>
<td>23.0</td>
<td>8.83</td>
<td>https://cdn.myanimelist.net/images/anime/6/867...</td>
<td>https://myanimelist.net/anime/34599/Made_in_Abyss</td>
<td>2017-07-07</td>
</tr>
<tr>
<th>3</th>
<td>5114</td>
<td>Fullmetal Alchemist: Brotherhood</td>
<td>"In order for something to be obtained, someth...</td>
<td>['Action', 'Military', 'Adventure', 'Comedy', ...</td>
<td>Apr 5, 2009 to Jul 4, 2010</td>
<td>64.0</td>
<td>1615084</td>
<td>4</td>
<td>1.0</td>
<td>9.23</td>
<td>https://cdn.myanimelist.net/images/anime/1223/...</td>
<td>https://myanimelist.net/anime/5114/Fullmetal_A...</td>
<td>2009-04-05</td>
</tr>
<tr>
<th>4</th>
<td>31758</td>
<td>Kizumonogatari III: Reiketsu-hen</td>
<td>After helping revive the legendary vampire Kis...</td>
<td>['Action', 'Mystery', 'Supernatural', 'Vampire']</td>
<td>Jan 6, 2017</td>
<td>1.0</td>
<td>214621</td>
<td>502</td>
<td>22.0</td>
<td>8.83</td>
<td>https://cdn.myanimelist.net/images/anime/3/815...</td>
<td>https://myanimelist.net/anime/31758/Kizumonoga...</td>
<td>2017-01-06</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>19306</th>
<td>32979</td>
<td>Flip Flappers</td>
<td>Cocona is an average middle schooler living wi...</td>
<td>['Sci-Fi', 'Adventure', 'Comedy', 'Magic']</td>
<td>Oct 6, 2016 to Dec 29, 2016</td>
<td>13.0</td>
<td>134252</td>
<td>843</td>
<td>1070.0</td>
<td>7.73</td>
<td>https://cdn.myanimelist.net/images/anime/4/822...</td>
<td>https://myanimelist.net/anime/32979/Flip_Flappers</td>
<td>2016-10-06</td>
</tr>
<tr>
<th>19307</th>
<td>123</td>
<td>Fushigi Yuugi</td>
<td>While visiting the National Library, junior-hi...</td>
<td>['Adventure', 'Fantasy', 'Magic', 'Martial Art...</td>
<td>Apr 6, 1995 to Mar 28, 1996</td>
<td>52.0</td>
<td>84407</td>
<td>1292</td>
<td>1071.0</td>
<td>7.73</td>
<td>https://cdn.myanimelist.net/images/anime/2/201...</td>
<td>https://myanimelist.net/anime/123/Fushigi_Yuugi</td>
<td>1995-04-06</td>
</tr>
<tr>
<th>19308</th>
<td>1281</td>
<td>Gakkou no Kaidan</td>
<td>Years ago, all of the ghosts in a haunted scho...</td>
<td>['Mystery', 'Horror', 'Supernatural']</td>
<td>Oct 22, 2000 to Mar 25, 2001</td>
<td>19.0</td>
<td>83093</td>
<td>1314</td>
<td>1073.0</td>
<td>7.73</td>
<td>https://cdn.myanimelist.net/images/anime/9/183...</td>
<td>https://myanimelist.net/anime/1281/Gakkou_no_K...</td>
<td>2000-10-22</td>
</tr>
<tr>
<th>19309</th>
<td>450</td>
<td>InuYasha Movie 2: Kagami no Naka no Mugenjo</td>
<td>Inuyasha and company have finally destroyed Na...</td>
<td>['Action', 'Adventure', 'Comedy', 'Historical'...</td>
<td>Dec 21, 2002</td>
<td>1.0</td>
<td>71989</td>
<td>1469</td>
<td>1077.0</td>
<td>7.73</td>
<td>https://cdn.myanimelist.net/images/anime/1162/...</td>
<td>https://myanimelist.net/anime/450/InuYasha_Mov...</td>
<td>2002-12-21</td>
</tr>
<tr>
<th>19310</th>
<td>87</td>
<td>Mobile Suit Gundam: Char's Counterattack</td>
<td>The year is Universal Century 0093. Char Aznab...</td>
<td>['Military', 'Sci-Fi', 'Space', 'Drama', 'Mecha']</td>
<td>Mar 12, 1988</td>
<td>1.0</td>
<td>29248</td>
<td>2604</td>
<td>1081.0</td>
<td>7.73</td>
<td>https://cdn.myanimelist.net/images/anime/1523/...</td>
<td>https://myanimelist.net/anime/87/Mobile_Suit_G...</td>
<td>1988-03-12</td>
</tr>
</tbody>
</table>
<p>19311 rows × 13 columns</p>
</div>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=d6271295">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [6]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">users</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[6]:</div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/html" tabindex="0">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>user_id</th>
<th>profile</th>
<th>gender</th>
<th>birthday</th>
<th>favorite_anime</th>
<th>link</th>
<th>birthday_parsed</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>1</td>
<td>DesolatePsyche</td>
<td>Male</td>
<td>2-Oct-94</td>
<td>['33352', '25013', '5530', '33674', '1482', '2...</td>
<td>https://myanimelist.net/profile/DesolatePsyche</td>
<td>1994-10-02</td>
</tr>
<tr>
<th>1</th>
<td>2</td>
<td>baekbeans</td>
<td>Female</td>
<td>10-Nov-00</td>
<td>['11061', '31964', '853', '20583', '918', '925...</td>
<td>https://myanimelist.net/profile/baekbeans</td>
<td>2000-11-10</td>
</tr>
<tr>
<th>2</th>
<td>3</td>
<td>skrn</td>
<td>NaN</td>
<td>NaN</td>
<td>['918', '2904', '11741', '17074', '23273', '32...</td>
<td>https://myanimelist.net/profile/skrn</td>
<td>NaT</td>
</tr>
<tr>
<th>3</th>
<td>4</td>
<td>edgewalker00</td>
<td>Male</td>
<td>5-Sep</td>
<td>['5680', '849', '2904', '3588', '37349']</td>
<td>https://myanimelist.net/profile/edgewalker00</td>
<td>NaT</td>
</tr>
<tr>
<th>4</th>
<td>5</td>
<td>aManOfCulture99</td>
<td>Male</td>
<td>30-Oct-99</td>
<td>['4181', '7791', '9617', '5680', '2167', '4382...</td>
<td>https://myanimelist.net/profile/aManOfCulture99</td>
<td>1999-10-30</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>81722</th>
<td>81723</td>
<td>lovelessxd</td>
<td>Female</td>
<td>6-Aug-92</td>
<td>['853', '5114']</td>
<td>https://myanimelist.net/profile/lovelessxd</td>
<td>1992-08-06</td>
</tr>
<tr>
<th>81723</th>
<td>81724</td>
<td>Shattered_Angel</td>
<td>Female</td>
<td>6-Sep-94</td>
<td>['150', '27', '1520', '121', '31452', '32995',...</td>
<td>https://myanimelist.net/profile/Shattered_Angel</td>
<td>1994-09-06</td>
</tr>
<tr>
<th>81724</th>
<td>81725</td>
<td>FluffyWalrus</td>
<td>Male</td>
<td>NaN</td>
<td>['121', '43', '237', '202', '205']</td>
<td>https://myanimelist.net/profile/FluffyWalrus</td>
<td>NaT</td>
</tr>
<tr>
<th>81725</th>
<td>81726</td>
<td>camco</td>
<td>Female</td>
<td>23-Sep</td>
<td>['199', '4224', '7054', '13601', '14713']</td>
<td>https://myanimelist.net/profile/camco</td>
<td>NaT</td>
</tr>
<tr>
<th>81726</th>
<td>81727</td>
<td>nyja-chan</td>
<td>Female</td>
<td>13-Nov</td>
<td>['39195', '38000', '440', '457', '34599', '225...</td>
<td>https://myanimelist.net/profile/nyja-chan</td>
<td>NaT</td>
</tr>
</tbody>
</table>
<p>81727 rows × 7 columns</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=43bed920">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="EDA">EDA<a class="anchor-link" href="#EDA">¶</a></h3>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=6477ee81">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h4 id="Animes-Dataset">Animes Dataset<a class="anchor-link" href="#Animes-Dataset">¶</a></h4>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=8001a908">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [9]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="c1"># Display basic information about the dataset</span>
<span class="nb">print</span><span class="p">(</span><span class="n">animes</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>

<span class="c1"># Summary statistics of numerical columns</span>
<span class="nb">print</span><span class="p">(</span><span class="n">animes</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>

<span class="c1"># Distribution of Scores</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">animes</span><span class="p">[</span><span class="s1">'score'</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Distribution of Scores'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Distribution of Popularity</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">animes</span><span class="p">[</span><span class="s1">'popularity'</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Distribution of Popularity'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Genres distribution</span>
<span class="n">genres_count</span> <span class="o">=</span> <span class="n">animes</span><span class="p">[</span><span class="s1">'genre'</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">', '</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>

<span class="c1"># Create a DataFrame for Seaborn barplot compatibility</span>
<span class="n">genres_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'Genre'</span><span class="p">:</span> <span class="n">genres_count</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">'Count'</span><span class="p">:</span> <span class="n">genres_count</span><span class="o">.</span><span class="n">values</span><span class="p">})</span>

<span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">genres_df</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">'Count'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">'Genre'</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s1">'viridis'</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">'Genre'</span><span class="p">,</span> <span class="n">dodge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Top Genres'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Count'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 19311 entries, 0 to 19310
Data columns (total 13 columns):
 #   Column       Non-Null Count  Dtype         
---  ------       --------------  -----         
 0   uid          19311 non-null  int64         
 1   title        19311 non-null  object        
 2   synopsis     18336 non-null  object        
 3   genre        19311 non-null  object        
 4   aired        19311 non-null  object        
 5   episodes     18605 non-null  float64       
 6   members      19311 non-null  int64         
 7   popularity   19311 non-null  int64         
 8   ranked       16099 non-null  float64       
 9   score        18732 non-null  float64       
 10  img_url      19131 non-null  object        
 11  link         19311 non-null  object        
 12  aired_start  17139 non-null  datetime64[ns]
dtypes: datetime64[ns](1), float64(3), int64(3), object(6)
memory usage: 1.9+ MB
None
                uid      episodes       members    popularity        ranked  \
count  19311.000000  18605.000000  1.931100e+04  19311.000000  16099.000000   
mean   19358.904096     11.460414  3.472609e+04   7720.830304   6866.524194   
min        1.000000      1.000000  2.500000e+01      1.000000      1.000000   
25%     4833.500000      1.000000  3.880000e+02   3725.000000   2895.500000   
50%    18327.000000      2.000000  2.389000e+03   7539.000000   6963.000000   
75%    33896.500000     12.000000  1.450150e+04  11613.000000  10601.500000   
max    40960.000000   3057.000000  1.871043e+06  16338.000000  14675.000000   
std    14271.446515     47.950386  1.121772e+05   4676.786104   4390.018768   

              score                    aired_start  
count  18732.000000                          17139  
mean       6.436107  2006-05-09 17:03:41.179765632  
min        1.250000            1917-04-28 00:00:00  
25%        5.770000            2001-02-11 00:00:00  
50%        6.410000            2010-03-06 00:00:00  
75%        7.150000            2015-07-08 12:00:00  
max        9.230000            2020-12-25 00:00:00  
std        1.007941                            NaN  
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedImage jp-OutputArea-output" tabindex="0">
<img alt="No description has been provided for this image" class="" src="data:image/png;base64,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GAZvrc0G4EfDkk/7vUlaR68IB86GOnYWN7B+f4nZ5YgX8ohANGvWLD744AM+//xzOnf+bqlqfHzTuTXH9uIUFBS4eo3i4+Opr6+npKTklG3y8/OP+9zCwsLjep+a2Ww2IiIiWjxERI717cEyduRVEOjvx7UXdjK7HJ8VbIWqbZ8D8OZaHZciZ8/UQGQYBvfccw/vvvsun332GV27dm3xeteuXYmPj2fp0qWu5+rr61m5ciUjRowAYPDgwQQEBLRok5uby9atW11t0tLSKCsrY926da42a9eupayszNVGRORcLFrX1Dt0Zf94OoQEmlyNb6v8tmmhzidb8iip0lwiOTumrjKbOXMmb731Fu+//z7h4eGuniC73U5wcDAWi4XZs2fz+OOP07NnT3r27Mnjjz9OSEgIN998s6vt7bffzgMPPEB0dDRRUVE8+OCDDBgwwLXqrE+fPkyYMIE77riDl156CYA777yTSZMmaYWZiJyzyrpGPvj2MAA3/SDZ5GqkPm8P3SL92VfSyH83HOSnl3YzuyTxIqb2EL344ouUlZUxcuRIEhISXI933nnH1eZXv/oVs2fP5u6772bIkCEcOnSITz/9lPDwcFebZ555hmuuuYZp06Zx8cUXExISwocffojV+t1GXW+++SYDBgxg3LhxjBs3joEDB/LGG2+06f2KSPvy4beHqa530C0mlGFdo8wuR4Cx3UIAeGtdtiZXy1kxtYfoTP5ntVgszJ07l7lz5560TVBQEM8//zzPP//8SdtERUWxcOHCcylTROSE3t3QtNR+2tAkTab2EJcmB/PGlir2FVaxNusIw7tFm12SeIlz6iHq1q0bxcXFxz1fWlpKt27qohSR9i/nSDXr95dgscA1F2gytacICfBjyqBEANfeUCJn4pwC0f79+1sci9Gsrq6OQ4cOnXdRIiKe7r2NTd/rRnSPJt4eZHI18n3XHF3tt2RbHnWNx/+sEjmRsxoy++CDD1z/vmTJEux2u+trh8PB8uXL6dKli9uKExHxRIZhsHhTUyBS75DnGdolithwGwUVdXy5q4gxfU+8vYrI951VILrmmmuApnk9M2bMaPFaQEAAXbp04c9//rPbihMR8URbDpWxr7CKoAA/JvSPN7scOYbVz8JVAxOY//V+/rf5sAKRnJGzCkROZ9PW6F27dmX9+vXExGiLehHxPe9uaOod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"/>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedImage jp-OutputArea-output" tabindex="0">
<img alt="No description has been provided for this image" class="" src="data:image/png;base64,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//4bvibRtWIPEZETpKeno7q6GtXV1cjPz8fWrVuxZMkSyGQyrFmzxr76qCGffvopNm7ciFGjRiEqKgpVVVX44osvAADDhg0DAGi1WkRHR+O7775DYmIiAgMDERwc3Kgl4kDt0M2YMWOQnJyMNm3aYPny5UhJScF7770HHx8fAEDfvn3RqVMnzJgxA9XV1QgICMCaNWuwbdu2eufr3r07Vq9ejU8++QQJCQnw8vK6bA/KG2+8gR9++AFDhw7F66+/jsDAQKxYsQI//vgj3n//feh0uka16VJz5szB8OHDMXToUMyYMQNKpRILFy5Eeno6vvrqqybpBWmIv78/XnvtNfztb3/DI488goceeghFRUV48803oVar8cYbbziUVyqV+Mc//oHy8nL07dsX27dvx9tvv4077rgDgwYNAlAbaiZMmIAvvvgC7du3R8+ePbFr1y57cLqSzp07o3379njllVcghEBgYCC+//57+1DWjejevTtWrVqFr7/+GrGxsVCr1ejevbt9/4QJEzBz5kz8+uuvePXVV6FUKm/4mkTXzLlzuok8S92KnrqXUqkUoaGhYvDgwWL27NkiPz+/3jGXrtZJTU0V99xzj4iOjhYqlUoEBQWJwYMHi7Vr1zoct379etG7d2+hUqkEADFp0iSH8xUUFFz1WkLUrjIbNWqU+O9//yu6desmlEqliImJEXPnzq13/IkTJ8SIESOEn5+fCAkJEdOmTRM//vhjvVVmxcXF4r777hP+/v5CkiSHa6KB1XGHDh0Sd911l9DpdEKpVIqePXvWW0FVt8rsm2++cdh+pRVXl9q6dau47bbbhEajEd7e3qJ///7i+++/b/B817PK7FrK/utf/xI9evQQSqVS6HQ6cffdd4vDhw87lJk0aZLQaDTi4MGDYsiQIcLb21sEBgaKv/71r6K8vNyhrNFoFE888YTQ6/VCo9GIu+66S5w9e/aaVpkdOXJEDB8+XGi1WhEQECDuv/9+kZWVVe/Y6/1ZOnv2rBgxYoTQarUCQIMrDSdPnizkcrnIzs6+6teMqClJQlxlSQsREbmEyZMn47///S/Ky8udXZVmYbFYEBMTg0GDBuE///mPs6tDHoZDZkRE5FQFBQU4fvw4lixZggsXLuCVV15xdpXIAzEQERGRU/3444949NFH0aZNGyxcuJBL7ckpOGRGREREHo/L7omI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8cH48eMBADqdDo8//jheeOEFBAUFITAwEDNmzED37t3rTdImIiIiz+TSgehavPTSSzCZTHj66adhMBjQr18//PLLL9BqtfYy8+bNg1wux7hx42AymZCYmIilS5dCJpM5seZERETkKtwuEG3evNnhvSRJSE5ORnJy8mWPUavVWLBgARYsWNC8lSMiIiK35NJziIiIiIhaAgMREREReTwGIiIiIvJ4DERERETk8RiIiIiIyOMxEBEREZHHYyAiIiIij8dARERERB6PgYiIiIg8HgMREREReTwGIiIiIvJ4DERERETk8RiIiIiIyOMxEBEREZHHYyAiIiIij8dARERERB6PgYiIiIg8HgMREREReTwGIiIiIvJ4DERERETk8RiIiIiIyOMxEBEREZHHYyAiIiIij8dARERERB6PgYiIiIg8HgMREREReTwGIiIiIvJ4DERERETk8RiIiIiIyOMxEBEREZHHYyAiIiIij8dARERERB6PgYiIiIg8HgMREREReTwGIiIiIvJ4DERERETk8RiIiIiIyOMxEBEREZHHYyAiIiIij8dARERERB6PgYiIiIg8HgMREREReTwGIiIiIvJ4DERERETk8RiIiIiIyOO5dCCaM2cO+vbtC61Wi9DQUPz5z3/G8ePHHcoIIZCcnIzw8HB4e3tjyJAhOHz4sEMZs9mMadOmITg4GBqNBmPGjEF2dnZLNoWIiIhcmEsHoi1btuCZZ57Bjh07kJKSgurqaowYMQIVFRX2Mu+//z7mzp2Ljz76CLt370ZYWBiGDx+OsrIye5mkpCSsWbMGq1atwrZt21BeXo7Ro0ejpqbGGc0iIiIiFyN3dgWuZN26dQ7vlyxZgtDQUKSlpeFPf/oThBCYP38+Zs2ahbFjxwIAli1bBr1ej5UrV2LKlCkwGo1YvHgxvvzySwwbNgwAsHz5ckRGRmL9+vUYOXJki7eLiIiIXItL9xBdymg0AgACAwMBABkZGcjLy8OIESPsZVQqFQYPHozt27cDANLS0mC1Wh3KhIeHIz4+3l6mIWazGaWlpQ4vIiIiap3cJhAJIfD8889j0KBBiI+PBwDk5eUBAPR6vUNZvV5v35eXlwelUomAgIDLlmnInDlzoNPp7K/IyMimbA4RERG5ELcJRFOnTsXBgwfx1Vdf1dsnSZLDeyFEvW2XulqZmTNnwmg02l/nzp1rXMWJiIjI5blFIJo2bRrWrl2LTZs2ISIiwr49LCwMAOr19OTn59t7jcLCwmCxWGAwGC5bpiEqlQp+fn4OLyIiImqdXDoQCSEwdepUrF69Ghs3bkS7du0c9rdr1w5hYWFISUmxb7NYLNiyZQsGDhwIAEhISIBCoXAok5ubi/T0dHsZIiIi8mwuvcrsmWeewcqVK/Hdd99Bq9Xae4J0Oh28vb0hSRKSkpIwe/ZsxMXFIS4uDrNnz4aPjw/Gjx9vL/v444/jhRdeQFBQEAIDAzFjxgx0797dvuqMiIiIPJtLB6JPPvkEADBkyBCH7UuWLMHkyZMBAC+99BJMJhOefvppGAwG9OvXD7/88gu0Wq29/Lx58yCXyzFu3DiYTCYkJiZi6dKlkMlkLdUUIiIicmEuHYiEEFctI0kSkpOTkZycfNkyarUaCxYswIIFC5qwdkRERNRauPQcIiIiIqKWwEBEREREHo+BiIiIiDweAxERERF5PAYiIiIi8ngMREREROTxGIiIiIjI4zEQERERkcdjICIiIiKPx0BEREREHo+BiIiIiDweAxERERF5PAYiIiIi8ngMREREROTxGIiIiIjI4zEQERERkcdjICIiIiKPx0BEREREHo+BiIiIiDweAxERERF5PAYiIiIi8ngMREREROTxGIiIiIjI4zEQERERkcdjICIiIiKPx0BEREREHo+BiIiIiDweAxERERF5PAYiIiIi8ngMREREROTxGIiIiIjI4zEQERERkcdjICIiIiKPx0BEREREHo+BiIiIiDweAxERERF5PAYiIiIi8ngMREREROTxGIiIiIjI4zEQERERkcdjICIiIiKPx0BEREREHo+BiIiIiDweAxERERF5PI8KRAsXLkS7du2gVquRkJCArVu3OrtKRERE5AI8JhB9/fXXSEpKwqxZs7Bv3z7ceuutuOOOO5CVleXsqhEREZGTeUwgmjt3Lh5//HE88cQT6NKlC+bPn4/IyEh88sknzq4aEREROZlHBCKLxYK0tDSMGDHCYfuIESOwfft2J9WKiIiIXIXc2RVoCYWFhaipqYFer3fYrtfrkZeX1+AxZrMZZrPZ/t5oNAIASktLm7Ru5eXlAIDsk4dhNlU26bkvZJ0GAOSdPYHTGh+XP6+7npt1bplzs84tc253rHNznpt1bplzF2RnAKj9TGzqz9m68wkhrlxQeIDz588LAGL79u0O299++23RqVOnBo954403BAC++OKLL7744qsVvM6dO3fFrOARPUTBwcGQyWT1eoPy8/Pr9RrVmTlzJp5//nn7e5vNhuLiYgQFBUGSpCarW2lpKSIjI3Hu3Dn4+fk12XldQWtuG9C628e2uafW3DagdbePbWs+QgiUlZUhPDz8iuU8IhAplUokJCQgJSUF99xzj317SkoK7r777gaPUalUUKlUDtv8/f2brY5+fn6t7h9BndbcNqB1t49tc0+tuW1A624f29Y8dDrdVct4RCACgOeffx4TJ05Enz59MGDAACxatAhZWVl46qmnnF01IiIicjKPCUQPPPAAioqK8NZbbyE3Nxfx8fH46aefEB0d7eyqERERkZN5TCACgKeffhpPP/20s6vhQKVS4Y033qg3PNcatOa2Aa27fWybe2rNbQNad/vYNueThLjaOjQiIiKi1s0jbsxIREREdCUMREREROTxGIiIiIjI4zEQERERkcdjIHKyhQsXol27dlCr1UhISMDWrVudXSUHc+bMQd++faHVahEaGoo///nPOH78uEMZIQSSk5MRHh4Ob29vDBkyBIcPH3YoYzabMW3aNAQHB0Oj0WDMmDHIzs52KGMwGDBx4kTodDrodDpMnDgRJSUlzd1Euzlz5kCSJCQlJdm3uXPbzp8/jwkTJiAoKAg+Pj7o1asX0tLS3L5t1dXVePXVV9GuXTt4e3sjNjYWb731Fmw2m1u27ddff8Vdd92F8PBwSJKEb7/91mF/S7YlKysLd911FzQaDYKDg/Hss8/CYrE0S9usVitefvlldO/eHRqNBuHh4XjkkUeQk5Pj9m271JQpUyBJEubPn99q2nb06FGMGTMGOp0OWq0W/fv3R1ZWlsu37Ypu+EFh1GirVq0SCoVCfP755+LIkSNi+vTpQqPRiMzMTGdXzW7kyJFiyZIlIj09Xezfv1+MGjVKREVFifLycnuZd999V2i1WvG///1PHDp0SDzwwAOiTZs2orS01F7mqaeeEm3bthUpKSli7969YujQoaJnz56iurraXub2228X8fHxYvv27WL79u0iPj5ejB49ukXauWvXLhETEyN69Oghpk+f7vZtKy4uFtHR0WLy5Mli586dIiMjQ6xfv16cOnXK7dv29ttvi6CgIPHDDz+IjIwM8c033whfX18xf/58t2zb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tzfMZjPCwsLs2++9915MmzYN3333HcaNGwcAWLJkCSZPngxJkhpVXyK6MewhIiKn69+/v0MQGDBgAE6ePIkjR45ALpfbgw4ABAUFoVOnTjh69Kh9m1wuR58+fezvO3fuDH9/f4cy12vfvn24++67ER0dDa1Wax9ey8rKcih38XWvlUqlwoQJE/DFF18AAPbv348DBw402ANFRC2DgYiI3I4Qol5PSkM9K3XbvLy87HOS6lw85HapiooKjBgxAr6+vli+fDl2796NNWvWAKgdSruYRqNpVBueeOIJpKSkIDs7G1988QUSExMRHR3dqHMR0Y1jICIip9uxY0e993FxcejatSuqq6uxc+dO+76ioiKcOHECXbp0sW+rrq7Gnj177O+PHz+OkpISdO7cGQAQEhKC3Nxch2vs37//svU5duwYCgsL8e677+LWW29F586dHSZUXw+lUomampp627t3744+ffrg888/x8qVKx2G6Iio5TEQEZHTnTt3Ds8//zyOHz+Or776CgsWLMD06dMRFxeHu+++G3/5y1+wbds2HDhwABMmTEDbtm1x9913249XKBSYNm0adu7cib179+LRRx9F//797fOHbrvtNuzZswf//ve/cfLkSbzxxhtIT0+/bH2ioqKgVCqxYMECnDlzBmvXrsX//d//NaptMTExOHjwII4fP47CwkKHnqknnngC7777LmpqanDPPfc06vxE1DQYiIjI6R555BGYTCbcfPPNeOaZZzBt2jQ8+eSTAGonGyckJGD06NEYMGAAhBD46aefoFAo7Mf7+Pjg5Zdfxvjx4zFgwAB4e3tj1apV9v0jR47Ea6+9hpdeegl9+/ZFWVkZHnnkkcvWJyQkBEuXLsU333yDrl274t1338Xf//73RrXtL3/5Czp16oQ+ffogJCQEv/32m33fQw89BLlcjvHjx0OtVjfq/ETUNCRx6cA6EVELGjJkCHr16oX58+c36vilS5ciKSkJJSUlTVqvlnDu3DnExMRg9+7duOmmm5xdHSKPxmX3REQtzGq1Ijc3F6+88gr69+/PMETkAjhkRkTUwn777TdER0cjLS0Nn376qbOrQ0TgkBkRERERe4iIiIiIGIiIiIjI4zEQERERkcdjICIiIiKPx0BEREREHo+BiIiIiDweAxERERF5PAYiIiIi8ngMREREROTx/j/Smq421R37cwAAAABJRU5ErkJggg=="/>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedImage jp-OutputArea-output" tabindex="0">
<img alt="No description has been provided for this image" class="" src="data:image/png;base64,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vXpVHTp0yHFtAACgcMj1FxSfO3dO8+bN04gRI3T27FlJ/9yC/fXXX/OsuPshJCREJ0+e1LJly5SYmKi33npLK1euzHE/QUFB2rVrl5KSkvTnn38qMzNTISEh2r17t9atW6cjR45o9OjRiouLsx7z888/a8SIEdqxY4dOnDih9evX68iRI6pWrZq1TbVq1dSwYUMNHz5cXbt2laura55cNwAAMJ9cBbsDBw6ocuXKmjJlit58802dO3dOkrRy5UqNGDEiL+u759q2bavBgwdr4MCBCgsL0/bt2zV69Ogc9zN06FA5OjoqNDRUJUuW1MmTJ9WvXz916NBBnTt31oMPPqgzZ87YzN65ubnp8OHD6tixoypXrqy+fftq4MCBeu6552z67t27t65cuaJevXrd9fUCAADzytVbsS1atFDdunU1depUeXp6av/+/apQoYK2b9+ubt26KSkp6R6UWnhNnDhRy5Yt08GDB++qn+tv1fBWLID8iLdigZvLyVuxuZqxi4uLyzKrJEllypRRSkpKbrrETfz999+Ki4vT//73P7344ov2LgcAAORzuQp2RYsWvemX3f70008qWbLkXReFfwwcOFD/+c9/9PDDD3MbFgAA3FGugl3btm01fvx4689uWSwWnTx5Uq+++qo6duyYpwUWZrGxsUpPT9dHH30kR0dHe5cDAADyuVwFuzfffFN//PGHSpUqpUuXLunhhx9WSEiIPDw8NHHixLyuEQAAANmQq++x8/Ly0rZt27Rp0ybt2bNHmZmZqlu3rlq0aJHX9QEAACCbcjRjd+nSJa1evdq6vn79ev32229KSUnRmjVrNGzYMF2+fDnPiwQAAMCd5WjGbtGiRVq9erXatGkjSZo9e7aqV69u/dLcw4cPKyAgQIMHD877SgEAAHBbOZqxW7JkSZa3M5cuXapNmzZp06ZNmjZtmpYvX56nBQIAACB7chTsjhw5osqVK1vXixYtKgeH/+uiQYMGSkhIyLvqAAAAkG05uhWbmpqqIkX+75A//vjDZn9mZqbS09PzpjLcM98NG3HHb64GAAAFT45m7MqWLasffvjhlvsPHDigsmXL3nVRAAAAyLkcBbvHHntMY8aMuembr5cuXdK4cePUunXrPCsOAAAA2WcxDMPIbuPff/9dYWFhcnZ21sCBA1W5cmVZLBYdPnxYs2fP1rVr17Rv3z75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"/>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=4f9f569f">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h4 id="Users-Dataset">Users Dataset<a class="anchor-link" href="#Users-Dataset">¶</a></h4>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=0f0a2cf7">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [11]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Display basic information about the dataset</span>
<span class="nb">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>

<span class="c1"># Summary statistics of numerical columns (if any)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>

<span class="c1"># Gender distribution</span>
<span class="n">sns</span><span class="o">.</span><span class="n">countplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">'gender'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">users</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">'gender'</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s1">'Set2'</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Gender Distribution'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Convert 'birthday' to datetime format with a specified format</span>
<span class="n">users</span><span class="p">[</span><span class="s1">'birthday'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="s1">'birthday'</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">'</span><span class="si">%d</span><span class="s1">-%b-%y'</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">'coerce'</span><span class="p">)</span>

<span class="c1"># Calculate age</span>
<span class="n">users</span><span class="p">[</span><span class="s1">'age'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="o">.</span><span class="n">today</span><span class="p">()</span> <span class="o">-</span> <span class="n">users</span><span class="p">[</span><span class="s1">'birthday'</span><span class="p">])</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">days</span> <span class="o">//</span> <span class="mi">365</span>

<span class="c1"># Plot the age distribution</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">'age'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">users</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Age Distribution'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Age'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Number of favorite animes per user</span>
<span class="n">users</span><span class="p">[</span><span class="s1">'favorite_count'</span><span class="p">]</span> <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="s1">'favorite_anime'</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">'favorite_count'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">users</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Number of Favorite Animes per User'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Count'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 81727 entries, 0 to 81726
Data columns (total 7 columns):
 #   Column           Non-Null Count  Dtype         
---  ------           --------------  -----         
 0   user_id          81727 non-null  int64         
 1   profile          81727 non-null  object        
 2   gender           53856 non-null  object        
 3   birthday         46807 non-null  object        
 4   favorite_anime   81727 non-null  object        
 5   link             81727 non-null  object        
 6   birthday_parsed  36339 non-null  datetime64[ns]
dtypes: datetime64[ns](1), int64(1), object(5)
memory usage: 4.4+ MB
None
            user_id                birthday_parsed
count  81727.000000                          36339
mean   40864.000000  1995-08-07 12:23:23.979195904
min        1.000000            1969-01-01 00:00:00
25%    20432.500000            1992-02-04 00:00:00
50%    40864.000000            1995-08-03 00:00:00
75%    61295.500000            1998-07-17 00:00:00
max    81727.000000            2068-12-18 00:00:00
std    23592.697062                            NaN
</pre>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedImage jp-OutputArea-output" tabindex="0">
<img alt="No description has been provided for this image" class="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk0AAAHFCAYAAADv8c1wAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8fJSN1AAAACXBIWXMAAA9hAAAPYQGoP6dpAABG4ElEQVR4nO3dfVwVdd7/8fcR4YAoR27kLkktlVS0EkrRSvMGJEHLNiuKJBUtTDNhbe1WW+9vsmuzy8yrtMyi3XVtt9UIK3XzXim2THJ108Srg1jiQUgBcX5/7OX8PKI2EgrY6/l4zOPBzPczM98ZJ3j3nZlzbIZhGAIAAMAFNarrDgAAADQEhCYAAAALCE0AAAAWEJoAAAAsIDQBAABYQGgCAACwgNAEAABgAaEJAADAAkITAACABYQm4Ffmyy+/1IgRI3TttdfKx8dHPj4+ateunUaPHq0dO3bUWb9at26t1NTUy7Yvm80mm82mRo0ayeFwqEOHDnrooYeUk5NzznVsNpsmT558UftZvXr1Ra9zrn0tXbpUNputVv99vv/+e02ePFl5eXnV2iZPniybzVZr+wKuFI3rugMALp9FixbpscceU2RkpB5//HF16tRJNptN+fn5evfdd3XTTTdp7969uvbaa+u6q5dcz549NXfuXElSaWmpdu/eraysLMXHx+vuu+/Wu+++K09PT7N+8+bNatmy5UXtY/Xq1XrllVcuOjjVZF8X6/vvv9eUKVPUunVr3XDDDW5tI0eO1IABAy7p/oGGiNAE/Eps3LhR6enpGjhwoP785z/Ly8vLbOvTp4/GjBmjP/3pT/Lx8anDXtaOqqoqnTx5Una7/bw1zZs3V/fu3c35fv36acyYMZo8ebKmTJmiZ555RrNmzTLbz6y9FAzD0IkTJ+Tj43PJ9/VzWrZseclDG9AQcXsO+JWYPn26PDw8tGjRIrfAdKZ77rlH4eHhbst27NihQYMGKSAgQN7e3rrxxhv1xz/+0a3m9O2jtWvX6tFHH1VQUJACAwM1ZMgQff/99261lZWVmjhxokJDQ9WkSRPdcsst2rZt2zn7U1hYqNGjR6tly5by8vJSmzZtNGXKFJ08edKs2b9/v2w2m2bPnq2pU6eqTZs2stvtWrt2bU1OkyZPnqxOnTppwYIFOnHihLn87FtmP/30kzIzM9WmTRt5e3srICBAMTExevfddyVJqampeuWVV8x1T0/79+83lz322GN69dVX1aFDB9ntdr355pvn3NdpxcXFevjhhxUQECBfX18lJSXp22+/das5323O3r17q3fv3pKkdevW6aabbpIkPfzww2bfTu/zXLfnTp06pdmzZ+u6666T3W5XcHCwHnroIR08eLDafqKiorR9+3bdeuutatKkia655hrNnDlTp06dOv+JBxoARpqAX4GqqiqtXbtWMTExCgsLs7ze2rVrNWDAAHXr1k2vvvqqHA6HsrKydO+99+qnn36q9sd55MiRGjhwoN555x0VFBTot7/9rR588EF9+umnZk1aWpreeustZWZmqn///tq5c6eGDBmiY8eOuW2rsLBQN998sxo1aqTnnntO1157rTZv3qypU6dq//79WrJkiVv9H/7wB7Vv315z586Vn5+f2rVrd/En6v8kJSVp5syZ2rFjh2655ZZz1kyYMEHLli3T1KlTdeONN6qsrEw7d+7Ujz/+KEl69tlnVVZWpj//+c/avHmzud6Z5//999/XZ599pueee06hoaEKDg6+YL9GjBih/v37m+f3mWeeUe/evfXll1+qefPmlo+va9euWrJkiR5++GE988wzGjhwoCRdcHTp0Ucf1WuvvabHHntMiYmJ2r9/v5599lmtW7dOn3/+uYKCgszawsJCPfDAA8rIyNDzzz+vlStXatKkSQoPD9dDDz1kuZ9AvWMAuOIVFhYakoz77ruvWtvJkyeNyspKczp16pTZdt111xk33nijUVlZ6bZOYmKiERYWZlRVVRmGYRhLliwxJBnp6eludbNnzzYkGU6n0zAMw8jPzzckGU888YRb3fLlyw1JxrBhw8xlo0ePNpo2bWp89913brVz5841JBlff/21YRiGsW/fPkOSce211xoVFRWWzkerVq2MgQMHnrd94cKFhiTjvffeM5dJMp5//nlzPioqyrjzzjsvuJ8xY8YY5/s1K8lwOBzGkSNHztl25r5On9+77rrLrW7jxo2GJGPq1Klux3bmeTytV69eRq9evcz57du3G5KMJUuWVKt9/vnn3fp9+t/t7H/frVu3GpKMp556ym0/koytW7e61Xbs2NGIj4+vti+gIeH2HPArFx0dLU9PT3OaN2+eJGnv3r365ptv9MADD0iSTp48aU533HGHnE6ndu/e7batQYMGuc136dJFkvTdd99JknnL7PQ2Txs6dKgaN3Yf+P773/+u22+/XeHh4W77TkhIkCStX7++2r7PfHD7lzAM42drbr75Zn344Yf63e9+p3Xr1un48eMXvZ8+ffrI39/fcv3Z561Hjx5q1apVjW9FWnV6+2ePLN58883q0KGDPvnkE7floaGhuvnmm92WdenSxbwOgIaK23PAr0BQUJB8fHzO+UfrnXfe0U8//SSn0+kWeg4dOiRJyszMVGZm5jm3+8MPP7jNBwYGus2ffhD7dKA4fesqNDTUra5x48bV1j106JA++OCD8wahs/d9Mbcdf87p83T2811n+sMf/qCWLVvqvffe06xZs+Tt7a34+HjNmTPH8q3Bi+3z2eft9LLT5/VSOb39c/U3PDy82nV19r+l9J9roSbBEqhPCE3Ar4CHh4f69OmjnJwcOZ1Otz9+HTt2lCTzAeXTTj+jMmnSJA0ZMuSc242MjLyofpz+Y1pYWKirrrrKXH7y5Mlqf/iDgoLUpUsXTZs27ZzbOjvQ1NbnChmGoQ8++EC+vr6KiYk5b52vr6+mTJmiKVOm6NChQ+aoU1JSkr755htL+7rYPhcWFp5zWdu2bc15b29vlZeXV6v74Ycf3J47uhin/92cTme1556+//77Gm8XaGi4PQf8SkyaNElVVVV65JFHVFlZ+bP1kZGRateunf75z38qJibmnFOzZs0uqg+n395avny52/I//vGPbm/ESVJiYqJ27typa6+99pz7vtAo0C8xZcoU7dq1S48//ri8vb0trRMSEqLU1FTdf//92r17t3766SdJ1Ufafqmzz9umTZv03XffmedV+s/bc19++aVb3b/+9a9qt1Ivpm99+vSRJL399ttuy7dv3678/Hz17dvX8jEADRkjTcCvRM+ePfXKK69o7Nix6tq1q0aNGqVOnTqpUaNGcjqdWrFihSTJz8/PXGfRokVKSEhQfHy8UlNTddVVV+nIkSPKz8/X559/rj/96U8X1YcOHTrowQcf1EsvvSRPT0/169dPO3fuNN94O9MLL7ygNWvWqEePHho3bpwiIyN14sQJ7d+/X6tXr9arr776iz5L6OjRo9qyZYskqayszPxwy88++0xDhw7VlClTLrh+t27dlJiYqC5dusjf31/5+flatmyZYmNj1aRJE0lS586dJUmzZs1SQkKCPDw81KVLl/N+5MPP2bFjh0aOHKl7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9OghSYqNjZXL5dK2bdvMmq1bt8rlcrnV7Ny5U06n06zJycmR3W5XdHR0rRwvAABouOr09tyYMWP0zjvv6K9//auaNWtmjvQ4HA75+PiotLRUkydP1t13362wsDDt379fTz31lIKCgnTXXXeZtSNGjFBGRoYCAwMVEBCgzMxMde7c2XybrkOHDhowYIDS0tK0aNEiSdKoUaOUmJioyMhISVJcXJw6duyolJQUzZkzR0eOHFFmZqbS0tIYQQIAAHU70rRw4UK5XC717t1bYWFh5vTee+9Jkjw8PPTVV19p8ODBat++vYYNG6b27dtr8+bNatasmbmd+fPn684779TQoUPVs2dPNWnSRB988IE8PDzMmuXLl6tz586Ki4tTXFycunTpomXLlpntHh4eWrVqlby9vdWzZ08NHTpUd955p+bOnXv5TggAAKi3bIZhGHXdiStFSUmJHA6HXC5XjUenMj58q5Z7hYZsXsJDdd0FALjiWf37XS8eBAcAAKjvCE0AAAAWEJoAAAAsIDQBAABYQGgCAACwgNAEAABgAaEJAADAAkITAACABYQmAAAACwhNAAAAFhCaAAAALCA0AQAAWEBoAgAAsIDQBAAAYAGhCQAAwAJCEwAAgAWEJgAAAAsITQAAABYQmgAAACwgNAEAAFhAaAIAALCA0AQAAGABoQkAAMACQhMAAIAFhCYAAAALCE0AAAAWEJoAAAAsIDQBAABYQGgCAACwoEahqU+fPjp69Gi15SUlJerTp88v7RMAAEC9U6PQtG7dOlVUVFRbfuLECX322We/uFMAAAD1TeOLKf7yyy/Nn3ft2qXCwkJzvqqqStnZ2brqqqtqr3cAAAD1xEWFphtuuEE2m002m+2ct+F8fHz08ssv11rnAAAA6ouLCk379u2TYRi65pprtG3bNrVo0cJs8/LyUnBwsDw8PGq9kwAAAHXtokJTq1atJEmnTp26JJ0BAACory4qNJ3pX//6l9atW6eioqJqIeq55577xR0DAACoT2oUmhYvXqxHH31UQUFBCg0Nlc1mM9tsNhuhCQAAXHFq9JEDU6dO1bRp01RYWKi8vDx98cUX5vT5559b3s6MGTN00003qVmzZgoODtadd96p3bt3u9UYhqHJkycrPDxcPj4+6t27t77++mu3mvLyco0dO1ZBQUHy9fXVoEGDdPDgQbea4uJipaSk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xx9/1AsvvCCn06moqCitXr1arVq1quuuAQCAOkZoOkt6errS09Pruhu/ana7Xc8//3y1W59AXeK6RH3DNXn52Yyfe78OAAAAfLglAACAFYQmAAAACwhNAAAAFhCa0CDs379fNptNeXl5dd0V4KK0bt1aL730Ul13A78C/J689AhNuGRSU1Nls9nO+TlX6enpstlsSk1NvfwdwxXr9DV39rR379667hquAKevr5kzZ7otf//99y/5t0CcfW0HBgZqwIAB+vLLL82aiIgI8+NycGkQmnBJRUREKCsrS8eP//8vIj5x4oTeffddXX311XXYM1ypBgwYIKfT6Ta1adOmrruFK4S3t7dmzZql4uLiy77vM6/tTz75RI0bN1ZiYqLZ7uHhodDQUDVufGk/TaiiouKSbr8+IzThkuratauuvvpq/eUvfzGX/eUvf1FERIRuvPFGc1l2drZuueUWNW/eXIGBgUpMTNS///3vC257165duuOOO9S0aVOFhIQoJSVFP/zwwyU7FjQMdrtdoaGhbpOHh4c++OADRUdHy9vbW9dcc42mTJmikydPmuvZbDYtWrRIiYmJatKkiTp06KDNmzdr79696t27t3x9fRUbG+t2Xf773//W4MGDFRISoqZNm+qmm27Sxx9/fMH+uVwujRo1SsHBwfLz81OfPn30z3/+85KdD9Sufv36KTQ0VDNmzDhvzYoVK9SpUyfZ7Xa1bt1a8+bNc2tv3bq1pk+fruHDh6tZs2a6+uqr9dprr/3svs+8tm+44QY9+eSTKigo0OHDhyVVvz23bt062Ww2ffLJJ4qJiVGTJk3Uo0cP7d6929ymlWu4devWmjp1qlJTU+VwOJSWlqY+ffrosccec6v78ccfZbfb9emnn/7ssTRUhCZccg8//LCWLFlizr/xxhsaPny4W01ZWZkmTJig7du365NPPlGjRo1011136dSpU+fcptPpVK9evXTDDTdox44dys7O1qFDhzR06NBLeixomD766CM9+OCDGjdunHbt2qVFixZp6dKlmjZtmlvd73//ez300EPKy8vTddddp+TkZI0ePVqTJk3Sjh07JMntD0VpaanuuOMOffzxx/riiy8UHx+vpKQkHThw4Jz9MAxDAwcOVGFhoVavXq3c3Fx17dpVffv21ZEjRy7dCUCt8fDw0PTp0/Xyyy/r4MGD1dpzc3M1dOhQ3Xffffrqq680efJkPfvss1q6dKlb3bx58xQTE6MvvvhC6enpevTRR/XNN99Y7kdpaamWL1+utm3bKjAw8IK1Tz/9tObNm6cdO3aocePGbr9/rV7Dc+bMUVRUlHJzc/Xss89q5MiReuedd1ReXm7WLF++XOHh4br99tstH0eDYwCXyLBhw4zBgwcbhw8fNux2u7Fv3z5j//79hre3t3H48GFj8ODBxrBhw865blFRkSHJ+OqrrwzDMIx9+/YZkowvvvjCMAzDePbZZ424uDi3dQoKCgxJxu7duy/lYaEeGzZsmOHh4WH4+vqa029+8xvj1ltvNaZPn+5Wu2zZMiMsLMycl2Q888wz5vzmzZsNScbrr79uLnv33XcNb2/vC/ahY8eOxssvv2zOt2rVypg/f75hGIbxySefGH5+fsaJEyfc1rn22muNRYsWXfTx4vI6/TvNMAyje/fuxvDhww3DMIyVK1cap/+cJicnG/3793db77e//a3RsWNHc75Vq1bGgw8+aM6fOnXKCA4ONhYuXHjBfZ95bUsywsLCjNzcXLPm7N+Ta9euNSQZH3/8sVmzatUqQ5Jx/Pjx8+7rXNfwnXfe6VZz4sQJIyAgwHjvvffMZTfccIMxefLk8273SsBIEy65oKAgDRw4UG+++aaWLFmigQMHKigoyK3m3//+t5KTk3XNNdfIz8/PfAblfP/Hnpubq7Vr16pp06bmdN1115nbwq/X7bffrry8PHP6wx/+oNzcXL3wwgtu10taWpqcTqd++uknc90uXbqYP4eEhEiSOnfu7LbsxIkTKikpkfSfEdKJEyeqY8eOat68uZo2bapvvvnmgtdtaWmpAgMD3fqyb98+rtsGZtasWXrzzTe1a9cut+X5+fnq2bOn27KePXtqz549qqqqMpedea3ZbDaFhoaqqKhIkpSQkGBeG506dTLrzry2t27dqri4OCUkJOi77767YF/P3FdYWJgkmfuyeg3HxMS4zdvtdj344IN64403JEl5eXn65z//ecW/3MN3z+GyGD58uHlb45VXXqnWnpSUpIiICC1evFjh4eE6deqUoqKizvvA4alTp5SUlKRZs2ZVazv9SwG/Tr6+vmrbtq3bslOnTmnKlCkaMmRItXpvb2/zZ09PT/Pn029DnWvZ6dvGv/3tb/XRRx9p7ty5atu2rXx8fPSb3/zmgtdtWFiY1q1bV62tefPm1g4Q9cJtt92m+Ph4PfXUU25BwTCMam/SGef4trIzryvpP9fW6evqf/7nf8yXZ86sO/vajo6OlsPh0OLFizV16tTz9rU2rmFfX99q2x05cqRuuOEGHTx4UG+88Yb69u17xX/BPaEJl8WAAQPM/wjj4+Pd2n788Ufl5+dr0aJFuvXWWyVJGzZsuOD2unbtqhUrVqh169aX/E0RNHxdu3bV7t27q4WpX+qzzz5Tamqq7rrrLkn/eT5k//79F+xHYWGhGjdurNatW9dqX3D5zZw5UzfccIPat29vLuvYsWO131+bNm1S+/bt5eHhYWm7V111laU6m82mRo0aub2dfLEu9ho+U+fOnRUTE6PFixfrnXfe0csvv1zjfjQU3J7DZeHh4aH8/Hzl5+dX+8Xh7++vwMBAvfbaa9q7d68+/fRTTZgw4YLbGzNmjI4cOaL7779f27Zt07fffqucnBwNHz7cbQgckKTnnntOb731liZPnqyvv/5a+fn5eu+99/TMM8/8ou22bdtWf/nLX8xbE8nJyed9eUH6z5tXsbGxuvPOO/XRRx9p//792rRpk5555hnzQXM0HJ07d9YDDzzgFhYyMjL0ySef6Pe//73+9a9/6c0339SCBQuUmZn5i/dXXl6uwsJCFRYWKj8/X2PHjlVpaamSkpJqvM2LvYbPNnLkSM2cOVNVVVVm8LqSEZpw2fj5+cnPz6/a8kaNGikrK0u5ubmKiorSE088oTlz5lxwW+Hh4dq4caOqqqoUHx+vqKgoPf7443I4HGrUiMsa7uLj4/X3v/9da9as0U033aTu3bvrxRdf/MW3EubPny9/f3/16NFDSUlJio+PV9euXc9bb7PZtHr1at12220aPny42rdvr/vuu0/79+83n6FCw/L73//e7fZb165d9cc//lFZWVmKiorSc889pxdeeKFWnvXJzs5WWFiYwsLC1K1bN23fvl1/+tOf1Lt37xpv82Kv4bPdf//9aty4sZKTk91udV+pbMa5brYCAAD8jIKCArVu3Vrbt2+/qLDVUBGaAADARamsrJTT6dTvfvc7fffdd9q4cWNdd+my4D4GAAC4KBs3blSrVq2Um5urV199ta67c9kw0gQAAGABI00AAAAWEJoAAAAsIDQBAABYQGgCAACwgNAEALUgNTVVd955Z113A8AlRGgCAACwgNAEAPWAYRg6efJkXXcDwAUQmgBcUY4dO6YHHnhAvr6+CgsL0/z589W7d2+NHz9eklRRUaGJEyfqqquukq+vr7p166Z169aZ6y9dulTNmzfXRx99pA4dOqhp06YaMGCAnE6nWVNVVaUJEyaoefPmCgwM1MSJE3X2R94ZhqHZs2frmmuukY+Pj66//nr9+c9/NtvXrVsnm82mjz76SDExMbLb7frss88u6bkB8MsQmgBcUSZMmKCNGzfqb3/7m9asWaPPPvtMn3/+udn+8MMPa+PGjcrKytKXX36pe+65RwMGDNCePXvMmp9++klz587VsmXL9I9//EMHDhxw+5b6efPm6Y033tDrr7+uDRs26MiRI1q5cqVbP5555hktWbJECxcu1Ndff60nnnhCDz74oNavX+9WN3HiRM2YMUP5+fnq0qXLJTorAGqFAQBXiJKSEsPT09P405/+ZC47evSo0aRJE+Pxxx839u7da9hsNuN///d/3dbr27evMWnSJMMwDGPJkiWGJGPv3r1m+yuvvGKEhISY82FhYcbMmTPN+crKSqNly5bG4MGDDcMwjNLSUsPb29vYtGmT235GjBhh3H///YZhGMbatWsNScb7779fOwcP4JJrXNehDQBqy7fffqvKykrdfPPN5jKHw6HIyEhJ0ueffy7DMNS+fXu39crLyxUYGGjON2nSRNdee605HxYWpqKiIkmSy+WS0+lUbGys2d64cWPFxMSYt+h27dqlEydOqH///m77qaio0I033ui2LCYm5pccMoDLiNAE4IpxOrTYbLZzLj916pQ8PDyUm5srDw8Pt5qmTZuaP3t6erq12Wy2as8sXcipU6ckSatWrdJVV13l1ma3293mfX19LW8XQN0iNAG4Ylx77bXy9PTUtm3bFBERIUkqKSnRnj171KtXL914442qqqpSUVGRbr311hrtw+FwKCwsTFu2bNFtt90mSTp58qRyc3PVtWtXSVLHjh1lt9t14MAB9erVq3YODkCdIzQBuGI0a9ZMw4YN029/+1sFBAQoODhYzz//vBo1aiSbzab27dvrgQce0EMPPaR58+bpxhtv1A8//KBPP/1UnTt31h133GFpP48//rhmzpypdu3aqUOHDnrxxRd19OhRt35kZmbqiSee0KlTp3TLLbeopKREmzZtUtOmTTVs2LBLdAYAXEqEJgBXlBdffFGPPPKIEhMT5efnp4kTJ6qgoEDe3t6SpCVLlmjq1KnKyMjQ//7v/yowMFCxsbGWA5MkZWRkyOl0KjU1VY0aNdLw4cN11113yeVymTW///3vFRwcrBkzZujbb79V8+bN1bVrVz311FO1fswALg+bcTE36gGggSkrK9NVV12lefPmacSIEXXdHQANGCNNAK4oX3zxhb755hvdfPPNcrlceuGFFyRJgwcPruOeAWjoCE0Arjhz587V7t275eXlpejoaH322WcKCgqq624BaOC4PQcAAGABX6MCAABgAaEJAADAAkITAACABYQmAAAACwhNAAAAFhCaAAAALCA0AQAAWEBoAgAAsIDQBAAAYMH/A0ToqNzwu1XjAAAAAElFTkSuQmCC"/>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedImage jp-OutputArea-output" tabindex="0">
<img alt="No description has been provided for this image" class="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlIAAAHFCAYAAAA5VBcVAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8fJSN1AAAACXBIWXMAAA9hAAAPYQGoP6dpAABnuUlEQVR4nO3deXhU1eE//vedJZPJNmQhGQIJRIxhCZugbLaAIEsJ1FpFRVJsEVAEjEJVvmiN/hQqLvARXJBSoYJiW8G6RkApSlkNRlkiKgIJkD2TyT7r+f0xmUuGJJBlkpnJvF/Pcx/IvWfunHtJmHfOOfccSQghQEREREQtpvB0BYiIiIh8FYMUERERUSsxSBERERG1EoMUERERUSsxSBERERG1EoMUERERUSsxSBERERG1EoMUERERUSsxSBERERG1EoMUETXbK6+8AkmSkJyc7OmqQJIkeVMqlQgPD8egQYMwf/58HDx4sEH5s2fPQpIkbNq0qUXv884772DNmjUtek1j75Weng5JklBcXNyic13JyZMnkZ6ejrNnzzY4du+996JXr15uey8iahyDFBE129///ncAwIkTJ3Do0CEP1wa4/fbbceDAAezbtw/btm3DH/7wBxw8eBAjR47EQw895FK2W7duOHDgAKZOndqi92hNkGrte7XUyZMn8fTTTzcapJ588kns2LGjXd+fiACVpytARL7hm2++wXfffYepU6fik08+wcaNGzF8+HCP1ikmJgYjRoyQv540aRLS0tIwb948vPLKK+jTpw8eeOABAIBGo3Ep2x5sNhusVmuHvNfV9O7d26PvT+Qv2CJFRM2yceNGAMBf//pXjBo1Ctu2bUN1dXWDcufPn8ftt9+O0NBQdOnSBffccw+OHDnSaLfaN998g+nTpyMiIgKBgYEYMmQI/vnPf7apnkqlEuvWrUNUVBReeOEFeX9j3W1FRUWYN28e4uLioNFo0LVrV4wePRq7d+8GAIwdOxaffPIJzp0759KVWP98q1atwrPPPouEhARoNBrs2bPnit2Iubm5uO222xAWFgadTodZs2ahqKjIpYwkSUhPT2/w2l69euHee+8FAGzatAl33HEHAGDcuHFy3Zzv2VjXXm1tLZYtW4aEhAQEBASge/fuePDBB1FWVtbgfVJSUpCRkYHrr78eWq0Wffr0kVskiegSBikiuqqamhq8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"/>
</div>
</div>
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedImage jp-OutputArea-output" tabindex="0">
<img alt="No description has been provided for this image" class="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk0AAAHFCAYAAADv8c1wAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8fJSN1AAAACXBIWXMAAA9hAAAPYQGoP6dpAACE30lEQVR4nO3dd3xUVdoH8N+dmkIyaaRBEooYSgApCgEVEAggxbaiohEssGuBRWBVdF3R1xUVRXfBti5iAcRdUdcVjQQQlKWXSAsICISSENImfTKZOe8fk7nJkDZJpuf3/XxGyb1n7pybm8k8Oec5z5WEEAJERERE1CSFuztARERE5A0YNBERERHZgUETERERkR0YNBERERHZgUETERERkR0YNBERERHZgUETERERkR0YNBERERHZgUETERERkR0YNJHP+eijjyBJEvz8/HD27Nl6+0eOHImkpCQ39AzYsmULJEnCF1984ZbXb6kzZ85g4sSJCAsLgyRJmDt3bqNtu3TpAkmSGnyUlpa6rtMtMHLkSIwcOVL+ury8HIsWLcKWLVuc9ppGoxHR0dEO+zmQJAmLFi1qe8famS5dumDSpEkN7tu7dy8kScJHH33k2k6Rx1O5uwNEzmIwGPDnP/8Zn376qbu74rWeeOIJ7Nq1Cx9++CGio6MRExPTZPvhw4fj9ddfr7c9ICDAWV1sk3feecfm6/LycrzwwgsAYBNMOdK3336LS5cuAQBWrFiB3/3ud2063o4dO9C5c2dHdI2ImsGgiXzW+PHjsWbNGixYsAD9+/d3d3dcqqKiAn5+fpAkqU3HOXz4MK677jrceuutdrUPCQnB0KFD2/SarlBeXo6AgAD07t3b5a+9YsUKaDQajBgxAhs2bMD58+fbFPR4w/fbHYQQqKyshL+/v7u7YhfrzyR5Nk7Pkc968sknER4ejqeeeqrJdmfOnGl0KP7KqY9FixZBkiQcPHgQd955J3Q6HcLCwjBv3jxUV1fj+PHjGD9+PIKCgtClSxe89tprDb5mZWUl5s2bh+joaPj7+2PEiBE4cOBAvXZ79+7FlClTEBYWBj8/PwwYMAD/+te/bNpYpyM3bNiABx98EB07dkRAQAAMBkOj55yVlYX77rsPkZGR0Gq16NWrF9544w2YzWYAtdOIJ0+exPfffy9Ps505c6bJ72VT3n77bdx4442IjIxEYGAg+vbti9deew1Go1FuM3fuXAQGBqK4uLje8++66y5ERUXJ7c1mM1577TX07NkTWq0WkZGRuP/++3H+/Hmb51mnY3/66ScMGzYMAQEBePDBB+V91hGlM2fOoGPHjgCAF154QT7nGTNmyMc6ceIEpk2bZvN9e/vtt+3+Hly8eBFpaWmYPHky/vSnP8FsNjf4czdjxgx06NABJ0+exM0334wOHTogLi4O8+fPr3ddr/wZtf48bN68GTNnzkR4eDiCg4Nx//33o6ysDDk5OZg6dSpCQkIQExODBQsW2FwDAKiqqsJLL70kf287duyIBx54AJcvX7Zpt3nzZowcORLh4eHw9/dHfHw87rjjDpSXlzf5fbBOjX311Vfo168f/Pz80K1bN/z973+v17a4uBgLFixA165dodFo0KlTJ8ydOxdlZWX1vg+PP/443nvvPfTq1QtarRYff/xxk/1oid9++w133303YmNjodVqERUVhdGjRyMjI8Om3eeff47k5GQEBgaiQ4cOGDduXL33tvX6Hjp0CCkpKQgKCsLo0aMd1ldyIkHkY1auXCkAiD179oi//e1vAoDYtGmTvH/EiBGiT58+8tenT58WAMTKlSvrHQuAeP755+Wvn3/+eQFAJCYmiv/7v/8T6enp4sknnxQAxOOPPy569uwp/v73v4v09HTxwAMPCABi3bp18vN//PFHAUDExcWJW265Rfz3v/8Vq1atEldddZUIDg4Wp06dkttu3rxZaDQaccMNN4jPP/9cpKWliRkzZtTrq/V8O3XqJGbNmiW+//578cUXX4jq6uoGvz+5ubmiU6dOomPHjuK9994TaWlp4vHHHxcAxCOPPCKEEEKv14sdO3aI6OhoMXz4cLFjxw6xY8cOUVlZ2ej3PSEhQdx8883CaDTaPEwmkxBCiCeeeEK8++67Ii0tTWzevFm8+eabIiIiQjzwwAPyMX755RcBQHzwwQc2xy4sLBRarVbMmzdP3jZr1iz5+56Wlibee+890bFjRxEXFycuX74stxsxYoQICwsTcXFxYtmyZeLHH38UW7dulfeNGDFCCCFEZWWlSEtLEwDEQw89JJ/zyZMnhRBCHDlyROh0OtG3b1/xySefiA0bNoj58+cLhUIhFi1a1Oj3pa6//vWvAoBYv369MJvNIiEhQXTt2lWYzWabdtOnTxcajUb06tVLvP7662Lj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eT9fP0dPOD9JiObW1xERERGR75aWJSIiInIgBk1EREREdmDQRERERGQHBk1EREREdmDQ5CHeeecddO3aFX5+fhg0aBB+/vnnJttv3boVgwYNgp+fH7p164b33nvPRT1tmcWLF+Paa69FUFAQIiMjceutt+L48eNNPmfLli2WG4le8Th27JiLet0yixYtqtfX6OjoJp/jLdcPALp06dLg9XjssccabO8N1++nn37C5MmTERsbC0mS8PXXX9vsF0Jg0aJFiI2Nhb+/P0aOHIkjR440e9x169ahd+/e0Gq16N27N7766isnnUHTmjo/o9GIp556Cn379kVgYCBiY2Nx//334+LFi00e86OPPmrwulZWVjr5bOpr7vrNmDGjXj+HDh3a7HE95foBzZ9jQ9dCkiQsWbKk0WN60jW057PBE9+HDJo8wOeff465c+fi2WefxYEDB3DDDTdgwoQJyMpq+O7Qp0+fxs0334wbbrgBBw4cwDPPPIM5c+Zg3bp1Lu5587Zu3YrHHnsMO3fuRHp6Oqqrq5GSkoKysrJmn3v8+HFkZ2fLjx49erigx63Tp08fm74eOnSo0bbedP0AYM+ePTbnlp6eDgC48847m3yeJ1+/srIy9O/fH8uXL29w/2uvvYalS5di+fLl2LNnD6KjozF27FiUlJQ0eswdO3bgrrvuQmpqKn755RekpqZi6tSp2LVrl7NOo1FNnV95eTn279+P5557Dvv378eXX36JX3/9FVOmTGn2uMHBwTbXNDs7G35+fs44hSY1d/0AYPz48Tb9/O6775o8piddP6D5c7zyOnz44YeQJAl33HFHk8f1lGtoz2eDR74PHXGzW2qb6667TvzhD3+w2dazZ0/x9NNPN9j+ySefFD179rTZ9vvf/14MHTrUaX10lNzcXAFAbN26tdE2P/74owAgCgsLXdexNnj++edF//797W7vzddPCCH++Mc/iu7duwuz2dzgfm+7fgDEV199JX9tNptFdHS0eOWVV+RtlZWVQqfTiffee6/R40ydOlWMHz/eZtu4cePE3Xff7fA+t8SV59eQ3bt3CwDi7NmzjbZZuXKl0Ol0ju2cAzR0ftOnTxe33HJLi47jqddPCPuu4S233CJuuummJtt46jUUov5ng6e+DznS5GZVVVXYt28fUlJSbLanpKRg+/btDT5nx44d9dqPGzcOe/fuhdFodFpfHUGv1wMAwsLCmm07YMAAxMTEYPTo0fjxxx+d3bU2OXHiBGJjY9G1a1fcfffd+O233xpt683Xr6qqCqtWrcKDDz7Y7E2pven61XX69Gnk5OTYXCOtVosRI0Y0+p4EGr+uTT3HU+j1ekiS1Oy9M0tLS5GQkIDOnTtj0qRJOHDggGs62ApbtmxBZGQkrr76asycORO5ublNtvfm63fp0iWsX78eDz30ULNtPfUaXvnZ4KnvQwZNbpaXlweTyYSoqCib7VFRUcjJyWnwOTk5OQ22r66uRl5entP62lZCCMybNw/XX389kpKSGm0XExODf/zjH1i3bh2+/PJLJCYmYvTo0fjpp59c2Fv7DRkyBJ988gl++OEHfPDBB8jJycGwYcOQn5/fYHtvvX4A8PXXX6OoqAgzZsxotI23Xb8rWd93LXlPWp/X0ud4gsrKSjz99NOYNm1akzdB7dmzJz766CN88803+Oyzz+Dn54fhw4fjxIkTLuytfSZMmIDVq1dj8+bNeOONN7Bnzx7cdNNNMBgMjT7HW68fAHz88ccICgrC7bff3mQ7T72GDX02eOr7kLdR8RBX/tUuhGjyL/mG2je03ZM8/vjjOHjwILZt29Zku8TERCQmJspfJycn49y5c3j99ddx4403OrubLTZhwgT533379kVycjK6d++Ojz/+GPPmzWvwOd54/QBgxYoVmDBhAmJjYxtt423XrzEtfU+29jnuZDQacffdd8NsNuOdd95psu3QoUNtkqmHDx+OgQMHYtmyZfj73//u7K62yF133SX/OykpCYMHD0ZCQgLWr1/fZGDhbdfP6sMPP8S9997bbG6Sp17Dpj4bPO19yJEmN4uIiIBSqawXBefm5taLlq2io6MbbK9SqRAeHu60vrbF7Nmz8c033+DHH39E586dW/z8oUOHuv2vIXsFBgaib9++jfbXG68fAJw9exYbN27Eww8/3OLnetP1s658bMl70vq8lj7HnYxGI6ZOnYrTp08jPT29yVGmhigUClx77bVecV1jYmKQkJDQZF+97fpZ/fzzzzh+/Hir3peecA0b+2zw1PchgyY302g0GDRokLwiySo9PR3Dhg1r8DnJycn12m/YsAGDBw+GWq12Wl9bQwiBxx9/HF9++SU2b96Mrl27tuo4Bw4cQExMjIN75xwGgwGZmZmN9tebrl9dK1eu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"/>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=f60ef424">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="Feature-Engineering-and-Data-Prep">Feature Engineering and Data Prep<a class="anchor-link" href="#Feature-Engineering-and-Data-Prep">¶</a></h3>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=88f0a0a3">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [13]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">users</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[13]:</div>
<div class="jp-RenderedText jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/plain" tabindex="0">
<pre>user_id                0
profile                0
gender             27871
birthday           45388
favorite_anime         0
link                   0
birthday_parsed    45388
age                45388
favorite_count         0
dtype: int64</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=e1aa5c69">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h4 id="We-have-some-user-profiles-with-no-favorite-animes-listed.">We have some user profiles with no favorite animes listed.<a class="anchor-link" href="#We-have-some-user-profiles-with-no-favorite-animes-listed.">¶</a></h4>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=d847e1d0">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [15]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">users</span><span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[15]:</div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/html" tabindex="0">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>user_id</th>
<th>profile</th>
<th>gender</th>
<th>birthday</th>
<th>favorite_anime</th>
<th>link</th>
<th>birthday_parsed</th>
<th>age</th>
<th>favorite_count</th>
</tr>
</thead>
<tbody>
<tr>
<th>9</th>
<td>10</td>
<td>shadowsplat</td>
<td>NaN</td>
<td>NaT</td>
<td>[]</td>
<td>https://myanimelist.net/profile/shadowsplat</td>
<td>NaT</td>
<td>NaN</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=7cc513a9">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<p>We will omit these from our analysis since we will be comparing user profiles based on their favorited animes.</p>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=035241cf">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [17]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">users</span> <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="s1">'favorite_anime'</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'[]'</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=b221b2cc">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="Prepare-a-DataFrame-for-Modeling">Prepare a DataFrame for Modeling<a class="anchor-link" href="#Prepare-a-DataFrame-for-Modeling">¶</a></h3>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=c06a2674">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [26]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Extract unique anime IDs</span>
<span class="n">unique_anime_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">anime_id</span> <span class="k">for</span> <span class="n">anime_list</span> <span class="ow">in</span> <span class="n">users</span><span class="p">[</span><span class="s1">'favorite_anime'</span><span class="p">]</span> <span class="k">for</span> <span class="n">anime_id</span> <span class="ow">in</span> <span class="nb">eval</span><span class="p">(</span><span class="n">anime_list</span><span class="p">))</span>

<span class="c1"># Create a dictionary to hold the dummy variables</span>
<span class="n">dummy_data</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">anime_id</span> <span class="ow">in</span> <span class="n">unique_anime_ids</span><span class="p">:</span>
    <span class="n">dummy_data</span><span class="p">[</span><span class="sa">f</span><span class="s1">'anime_</span><span class="si">{</span><span class="n">anime_id</span><span class="si">}</span><span class="s1">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="s1">'favorite_anime'</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">anime_id</span> <span class="ow">in</span> <span class="nb">eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Combine all dummy columns into a single DataFrame</span>
<span class="n">dummy_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dummy_data</span><span class="p">)</span>

<span class="c1"># Add the user_id column and join with dummy DataFrame</span>
<span class="n">user_anime_dataset</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">users</span><span class="p">[[</span><span class="s1">'user_id'</span><span class="p">]]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">dummy_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="application/vnd.jupyter.stderr" tabindex="0">
<pre>C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
C:\Users\tab\AppData\Local\Temp\ipykernel_2392\4053157834.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  user_anime_dataset[f'anime_{anime_id}'] = users['favorite_anime'].apply(lambda x: 1 if anime_id in eval(x) else 0)
</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=eae4dee4">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [27]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Check for duplicate user IDs</span>
<span class="n">user_anime_dataset</span><span class="p">[</span><span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s1">'user_id'</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

<span class="c1"># Example: Remove duplicates (keep the first occurrence)</span>
<span class="n">user_anime_dataset</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s1">'user_id'</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">'first'</span><span class="p">)</span>

<span class="c1"># Remove NAs</span>
<span class="n">user_anime_dataset</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=3e66d359-c444-4fb1-b56b-67727f135d13">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [30]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Extract the anime IDs (removing 'anime_' prefix)</span>
<span class="n">anime_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'_'</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'anime_'</span><span class="p">)]</span>

<span class="c1"># Create a mapping from uid to title</span>
<span class="n">anime_title_mapping</span> <span class="o">=</span> <span class="n">animes</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">'uid'</span><span class="p">)[</span><span class="s1">'title'</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

<span class="c1"># Rename the columns of user_anime_dataset based on the title mapping</span>
<span class="n">new_column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">anime_title_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">anime_id</span><span class="p">,</span> <span class="sa">f</span><span class="s1">'anime_</span><span class="si">{</span><span class="n">anime_id</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span> <span class="k">for</span> <span class="n">anime_id</span> <span class="ow">in</span> <span class="n">anime_ids</span><span class="p">]</span>

<span class="c1"># Add the 'user_id' column back to the new column names</span>
<span class="n">new_column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_column_names</span>

<span class="c1"># Apply the new column names to the user_anime_dataset</span>
<span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">new_column_names</span>

<span class="c1"># Display the resulting dataset</span>
<span class="nb">print</span><span class="p">(</span><span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>   user_id  Yama Hime no Mi  Code Geass: Hangyaku no Lelouch R2  \
0      1.0              0.0                                 1.0   
1      2.0              0.0                                 0.0   
2      3.0              0.0                                 1.0   
3      4.0              0.0                                 1.0   
4      5.0              0.0                                 0.0   

   Onegai☆Teacher  Mazinger Z  Tegamibachi Reverse  Nozoki Ana  \
0             0.0         0.0                  0.0         0.0   
1             0.0         0.0                  0.0         0.0   
2             0.0         0.0                  0.0         0.0   
3             0.0         0.0                  0.0         0.0   
4             0.0         0.0                  0.0         0.0   

   Soredemo Tsuma wo Aishiteru  Katanagatari  Mushishi: Hihamukage  ...  \
0                          0.0           1.0                   0.0  ...   
1                          0.0           0.0                   0.0  ...   
2                          0.0           0.0                   0.0  ...   
3                          0.0           0.0                   0.0  ...   
4                          0.0           0.0                   0.0  ...   

   Kyoukai no Kanata: Shinonome  Kuroko no Basket 3rd Season NG-shuu  \
0                           0.0                                  0.0   
1                           0.0                                  0.0   
2                           0.0                                  0.0   
3                           0.0                                  0.0   
4                           0.0                                  0.0   

   Juuni Kokuki  Sei Juushi Bismarck  Pupipo!  Lupin III (2015)  \
0           0.0                  0.0      0.0               0.0   
1           0.0                  0.0      0.0               0.0   
2           0.0                  0.0      0.0               0.0   
3           0.0                  0.0      0.0               0.0   
4           0.0                  0.0      0.0               0.0   

   Grimm Masterpiece Theater  Kuragehime  Wakaba*Girl  Pokemon Sun &amp; Moon  
0                        0.0         0.0          0.0                 0.0  
1                        0.0         0.0          0.0                 0.0  
2                        0.0         0.0          0.0                 0.0  
3                        0.0         0.0          0.0                 0.0  
4                        0.0         0.0          0.0                 0.0  

[5 rows x 4769 columns]
</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=830374a1-9dc2-4299-a640-618df81f57fb">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [32]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">anime_title_mapping</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[32]:</div>
<div class="jp-RenderedText jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/plain" tabindex="0">
<pre>{28891: 'Haikyuu!! Second Season',
 23273: 'Shigatsu wa Kimi no Uso',
 34599: 'Made in Abyss',
 5114: 'Fullmetal Alchemist: Brotherhood',
 31758: 'Kizumonogatari III: Reiketsu-hen',
 37510: 'Mob Psycho 100 II',
 199: 'Sen to Chihiro no Kamikakushi',
 38000: 'Kimetsu no Yaiba',
 35247: 'Owarimonogatari 2nd Season',
 2904: 'Code Geass: Hangyaku no Lelouch R2',
 32935: 'Haikyuu!!: Karasuno Koukou vs. Shiratorizawa Gakuen Koukou',
 34096: 'Gintama.',
 15335: 'Gintama Movie 2: Kanketsu-hen - Yorozuya yo Eien Nare',
 918: 'Gintama',
 4181: 'Clannad: After Story',
 15417: "Gintama': Enchousen",
 30276: 'One Punch Man',
 16664: 'Kaguya-hime no Monogatari',
 4672: 'Koukaku Kidoutai 2.0',
 8038: 'Nodame Cantabile: Finale - Mine to Kiyora no Saikai',
 7588: 'Saraiya Goyou',
 1253: 'Saint Seiya: Meiou Hades Meikai-hen',
 20767: 'Noragami OVA',
 1425: 'Lupin III: Part II',
 35363: 'Kobayashi-san Chi no Maid Dragon: Valentine, Soshite Onsen! - Amari Kitai Shinaide Kudasai',
 22673: 'Kuroko no Basket 2nd Season NG-shuu',
 6862: 'K-On!: Live House!',
 5680: 'K-On!',
 451: 'InuYasha Movie 3: Tenka Hadou no Ken',
 9563: 'Hidamari Sketch x ☆☆☆ Specials',
 30364: 'Haikyuu!! Movie 2: Shousha to Haisha',
 33280: 'Gochuumon wa Usagi Desu ka??: Dear My Sister',
 36369: 'Ginga Eiyuu Densetsu: Die Neue These - Seiran 1',
 27633: 'Gekkan Shoujo Nozaki-kun Specials',
 31637: 'Gate: Jieitai Kanochi nite, Kaku Tatakaeri 2nd Season',
 38145: 'Doukyonin wa Hiza, Tokidoki, Atama no Ue.',
 552: 'Digimon Adventure',
 1689: 'Byousoku 5 Centimeter',
 8609: 'Detective Conan OVA 10: Kid in Trap Island',
 34944: 'Bungou Stray Dogs: Dead Apple',
 36214: 'Asagao to Kase-san.',
 32863: 'Ansatsu Kyoushitsu 2nd Season: Kagaijugyou-hen',
 36160: 'Yaoguai Mingdan 2nd Season',
 33064: 'Uchuu Senkan Yamato 2202: Ai no Senshi-tachi',
 2265: 'Transformers the Movie',
 11001: 'Toshokan Sensou: Kakumei no Tsubasa',
 39940: 'Shokugeki no Souma: Shin no Sara',
 322: 'Paradise Kiss',
 38958: 'Manga de Wakaru! Fate/Grand Order',
 4472: 'Lucky☆Star: Original na Visual to Animation',
 97: 'Last Exile',
 468: 'Koukaku Kidoutai 2: Innocence',
 7645: 'Heartcatch Precure!',
 3604: 'Hidamari Sketch x 365',
 1491: 'Ginga Tetsudou 999',
 19319: 'Gundam Build Fighters',
 1571: 'Ghost Hunt',
 35222: 'Gakuen Babysitters',
 38770: 'Detective Conan Movie 23: The Fist of Blue Sapphire',
 269: 'Bleach',
 30123: 'Akagami no Shirayuki-hime',
 32998: '91 Days',
 202: "Wolf's Rain",
 5005: 'Tentai Senshi Sunred',
 18397: 'Shingeki no Kyojin OVA',
 3750: 'Maria-sama ga Miteru 4th',
 33263: 'Kubikiri Cycle: Aoiro Savant to Zaregototsukai',
 32380: 'Kono Subarashii Sekai ni Shukufuku wo!: Kono Subarashii Choker ni Shukufuku wo!',
 35860: 'Karakai Jouzu no Takagi-san',
 3092: 'Junjou Romantica',
 38084: 'Fate/Grand Order: Zettai Majuu Sensen Babylonia',
 37033: 'Emiya-san Chi no Kyou no Gohan',
 28999: 'Charlotte',
 388: 'Capeta',
 9724: 'Break Blade 5: Shisen no Hate',
 37985: 'Aggressive Retsuko (ONA) 2nd Season',
 38435: 'Yao Shen Ji 3rd Season',
 20057: 'Space☆Dandy',
 1172: 'Slayers Try',
 397: 'Seikai no Senki II',
 2273: 'Mobile Suit Gundam Wing: Endless Waltz Movie',
 4080: 'Kyou kara Maou! 3rd Series',
 11887: 'Kokoro Connect',
 254: 'Jungle wa Itsumo Hare nochi Guu Deluxe',
 11135: 'Hybrid Child',
 13119: 'Hakuouki Movie 2: Shikon Soukyuu',
 29755: 'Haikyuu!! Movie 1: Owari to Hajimari',
 267: 'Gungrave',
 4872: 'Goku Sayonara Zetsubou Sensei',
 3665: 'Ginga Eiyuu Densetsu Gaiden (1999)',
 37150: 'Douluo Dalu',
 6768: 'Code Geass: Hangyaku no Lelouch R2 Special Edition - Zero Requiem',
 12403: 'Yuru Yuri♪♪',
 39597: 'Sword Art Online: Alicization - War of Underworld',
 15771: 'Saint☆Oniisan (Movie)',
 82: 'Mobile Suit Gundam 0080: War in the Pocket',
 34745: 'Mahoujin Guruguru (2017)',
 3782: 'Kara no Kyoukai 2: Satsujin Kousatsu (Zen)',
 253: 'Jungle wa Itsumo Hare nochi Guu',
 12413: 'Jormungand',
 5630: 'Higashi no Eden',
 38816: 'Hello World',
 29787: 'Gochuumon wa Usagi Desu ka??',
 2321: 'Giant Robo the Animation: Chikyuu ga Seishi Suru Hi',
 37822: 'Douluo Dalu 2nd Season',
 4447: 'Detective Conan Movie 12: Full Score of Fear',
 1505: 'Detective Conan Movie 09: Strategy Above the Depths',
 1472: 'City Hunter 3',
 9465: 'Break Blade 4: Sanka no Chi',
 35507: 'Youkoso Jitsuryoku Shijou Shugi no Kyoushitsu e (TV)',
 38349: 'Wotaku ni Koi wa Muzukashii: Youth',
 17949: 'The Everlasting Guilty Crown',
 12445: 'Tasogare Otome x Amnesia',
 1254: 'Saint Seiya',
 35073: 'Overlord II',
 597: 'Neko no Ongaeshi',
 569: 'Musekinin Kanchou Tylor',
 19111: 'Love Live! School Idol Project 2nd Season',
 14349: 'Little Witch Academia',
 4898: 'Kuroshitsuji',
 249: 'InuYasha (TV)',
 12893: 'Danshi Koukousei no Nichijou Specials',
 8142: 'Colorful (Movie)',
 532: 'Bishoujo Senshi Sailor Moon S',
 21185: 'Baby Steps',
 890: 'Yuusha-Ou GaoGaiGar',
 543: 'Vampire Hunter D (2000)',
 949: 'Top wo Nerae! Gunbuster',
 34504: 'Seitokai Yakuindomo Movie',
 1729: 'Maria-sama ga Miteru 3rd',
 8310: 'Magic Kaito',
 35075: 'Hoozuki no Reitetsu 2nd Season',
 35678: 'Hibike! Euphonium Movie 3: Chikai no Finale',
 15809: 'Hataraku Maou-sama!',
 35111: 'Haikyuu!! Movie 4: Concept no Tatakai',
 7304: 'Detective Conan Movie 08: Time Travel of the Silver Sky',
 1366: 'Detective Conan Movie 07: Crossroad in the Ancient Capital',
 23225: 'Yuru Yuri Nachuyachumi!',
 17909: 'Uchouten Kazoku',
 10521: "Working'!!",
 22319: 'Tokyo Ghoul',
 400: 'Seihou Bukyou Outlaw Star',
 9088: 'Saiyuuki Gaiden',
 33190: 'Planetarian: Hoshi no Hito',
 20: 'Naruto',
 33221: 'Mobile Suit Gundam Thunderbolt: December Sky',
 22097: 'Magi: Sinbad no Bouken',
 3014: 'Ginga Eiyuu Densetsu: Waga Yuku wa Hoshi no Taikai',
 2890: 'Gake no Ue no Ponyo',
 6702: 'Fairy Tail',
 2035: 'Eikoku Koi Monogatari Emma: Molders-hen',
 6351: 'Clannad: After Story - Mou Hitotsu no Sekai, Kyou-hen',
 6377: 'Zan Sayonara Zetsubou Sensei',
 1485: 'Akachan to Boku',
 4163: 'Seto no Hanayome OVA',
 2143: 'Saiyuuki Reload: Burial',
 6007: 'Ookami to Koushinryou II: Ookami to Kohakuiro no Yuuutsu',
 25517: 'Magic Kaito 1412',
 27947: 'Lupin III (2015)',
 1695: 'Les Misérables: Shoujo Cosette',
 187: 'Initial D Third Stage',
 14175: 'Hanasaku Iroha: Home Sweet Home',
 24471: 'Hoozuki no Reitetsu OVA',
 35110: 'Haikyuu!! Movie 3: Sainou to Sense',
 35120: 'Devilman: Crybaby',
 779: 'Detective Conan Movie 01: The Timed Skyscraper',
 10012: 'Carnival Phantasm',
 2605: 'Sayonara Zetsubou Sensei',
 31973: 'Mobile Suit Gundam Thunderbolt',
 4985: 'Mahou Shoujo Lyrical Nanoha: The Movie 1st',
 3572: 'Macross F',
 4280: 'Kara no Kyoukai 4: Garan no Dou',
 429: 'Kaleido Star: Legend of Phoenix - Layla Hamilton Monogatari',
 5781: 'Isekai no Seikishi Monogatari',
 10029: 'Coquelicot-zaka kara',
 38250: 'Xiao Lu He Xiao Lan',
 16916: 'Kuroko no Basket: Tip Off',
 7062: 'Hidamari Sketch x ☆☆☆',
 2623: 'Flanders no Inu (Movie)',
 790: 'Ergo Proxy',
 8408: 'Durarara!! Specials',
 780: 'Detective Conan Movie 02: The Fourteenth Target',
 24921: 'Aoki Hagane no Arpeggio: Ars Nova Cadenza',
 658: 'Touhai Densetsu Akagi: Yami ni Maiorita Tensai',
 2158: 'Terra e... (TV)',
 22: 'Tennis no Ouji-sama',
 9926: 'Sekaiichi Hatsukoi',
 26123: 'Seitokai Yakuindomo* OVA',
 30745: "Kyoukai no Kanata Movie: I'll Be Here - Kako-hen - Yakusoku no Kizuna",
 13767: 'Junjou Romantica OVA',
 2762: 'Igano Kabamaru',
 33899: 'IDOLiSH7',
 967: 'Hokuto no Ken',
 30415: 'High☆Speed!: Free! Starting Days',
 11239: 'Hidamari Sketch x Honeycomb',
 22043: 'Fairy Tail (2014)',
 6505: 'There She Is!!',
 32093: 'Tanaka-kun wa Itsumo Kedaruge',
 6582: 'Tentai Senshi Sunred 2nd Season',
 114: 'Sakigake!! Cromartie Koukou',
 85: 'Mobile Suit Zeta Gundam',
 25649: 'Junjou Romantica 3',
 996: 'Bishoujo Senshi Sailor Moon: Sailor Stars',
 6586: 'Yume-iro Pâtissière',
 3588: 'Soul Eater',
 12815: 'Shirokuma Cafe',
 24: 'School Rumble',
 17549: 'Non Non Biyori',
 18429: 'Lupin III vs. Detective Conan: The Movie',
 34451: 'Kekkai Sensen &amp; Beyond',
 13331: 'Jormungand: Perfect Order',
 9289: 'Hanasaku Iroha',
 36370: 'Ginga Eiyuu Densetsu: Die Neue These - Seiran 2',
 3371: 'Ginga Eiyuu Densetsu Gaiden',
 22961: 'Date A Live II: Kurumi Star Festival',
 1470: 'City Hunter',
 39565: 'Boku no Hero Academia the Movie 2: Heroes:Rising',
 9513: 'Beelzebub',
 28: 'Yakitate!! Japan',
 38917: 'Tong Ling Fei',
 793: 'xxxHOLiC Movie: Manatsu no Yoru no Yume',
 9941: 'Tiger &amp; Bunny',
 11813: 'Shijou Saikyou no Deshi Kenichi OVA',
 27775: 'Plastic Memories',
 40179: 'Mini Toji: Yume',
 7222: 'Macross F Movie 2: Sayonara no Tsubasa',
 1088: 'Macross',
 35857: 'Lupin III: Part 5',
 387: 'Haibane Renmei',
 1594: 'Jigoku Shoujo Futakomori',
 2924: 'ef: A Tale of Memories.',
 35320: 'Cardcaptor Sakura: Clear Card-hen Prologue - Sakura to Futatsu no Kuma',
 12113: 'Berserk: Ougon Jidai-hen II - Doldrey Kouryaku',
 34375: 'Yuuki Yuuna wa Yuusha de Aru: Washio Sumi no Shou 2 - Tamashii',
 30279: 'Yuru Yuri San☆Hai!',
 37786: 'Yagate Kimi ni Naru',
 31098: 'Ushio to Tora (TV) 2nd Season',
 2618: 'Takarajima',
 20815: 'Sekaiichi Hatsukoi: Valentine-hen',
 957: 'Saiunkoku Monogatari',
 2159: 'Ookiku Furikabutte',
 36215: 'One Piece: Episode of East Blue - Luffy to 4-nin no Nakama no Daibouken',
 25161: 'One Piece 3D2Y: Ace no shi wo Koete! Luffy Nakama Tono Chikai',
 10721: 'Mawaru Penguindrum',
 36563: 'Megalo Box',
 6774: 'Kuuchuu Buranko',
 427: 'Kaleido Star',
 2829: 'Ie Naki Ko Remy',
 29093: 'Grisaia no Meikyuu: Caprice no Mayu 0',
 10643: 'Gintama: Dai Hanseikai',
 31339: 'Drifters',
 73: 'Full Metal Panic! The Second Raid',
 6438: 'Detective Conan OVA 09: The Stranger in 10 Years...',
 23983: 'Fuichin-san',
 29893: 'Aria The Avvenire',
 35382: 'Yuri!!! on Ice: Yuri Plisetsky GPF in Barcelona EX - Welcome to The Madness',
 4106: 'Trigun: Badlands Rumble',
 2752: 'Tennis no Ouji-sama: Zenkoku Taikai-hen - Semifinal',
 995: 'Tennis no Ouji-sama: Zenkoku Taikai-hen',
 16395: 'SKET Dance: Imouto no Nayami ni Nayamu Ani ni Nayamu Imouto to Sono Nakama-tachi',
 339: 'Serial Experiments Lain',
 15689: 'Nekomonogatari: Kuro',
 1089: 'Macross: Do You Remember Love?',
 40211: 'Luo Xiao Hei Zhan Ji (Movie)',
 7711: 'Karigurashi no Arrietty',
 10080: 'Kami nomi zo Shiru Sekai II',
 27989: 'Hibike! Euphonium',
 7338: 'Darker than Black: Kuro no Keiyakusha Gaiden',
 15: 'Eyeshield 21',
 66: 'Azumanga Daioh',
 11113: 'Usagi Drop Specials',
 2154: 'Tekkon Kinkreet',
 28297: 'Ore Monogatari!!',
 30885: 'Noragami Aragoto OVA',
 31251: 'Mobile Suit Gundam: Iron-Blooded Orphans',
 33489: 'Little Witch Academia (TV)',
 416: 'Kurenai no Buta',
 5678: 'Kobato.',
 9996: 'Hyouge Mono',
 645: 'Hikaru no Go: Hokuto Hai e no Michi',
 21877: 'High Score Girl',
 122: 'Full Moon wo Sagashite',
 35968: 'Wotaku ni Koi wa Muzukashii',
 77: "Mahou Shoujo Lyrical Nanoha A's",
 31741: 'Magi: Sinbad no Bouken (TV)',
 11739: 'Kimi to Boku. 2',
 934: 'Higurashi no Naku Koro ni',
 18661: 'Kamisama Hajimemashita OVA',
 21855: 'Hanamonogatari',
 268: 'Golden Boy',
 401: 'Rurouni Kenshin: Meiji Kenkaku Romantan - Seisou-hen',
 29803: 'Overlord',
 24997: 'Love Live! The School Idol Movie',
 17265: 'Log Horizon',
 4814: 'Junjou Romantica 2',
 39468: 'Honzuki no Gekokujou: Shisho ni Naru Tame ni wa Shudan wo Erandeiraremasen',
 26213: 'Free!: Eternal Summer - Kindan no All Hard!',
 37435: 'Carole &amp; Tuesday',
 14075: 'Zetsuen no Tempest',
 21647: 'Tamako Love Story',
 9204: 'Omae Umasou da na',
 5682: 'Phantom: Requiem for the Phantom',
 10049: 'Nurarihyon no Mago: Sennen Makyou',
 14807: 'Kara no Kyoukai: Mirai Fukuin',
 1530: 'Kanon (2006)',
 33970: 'Girls &amp; Panzer: Saishuushou Part 1',
 2951: 'Gintama: Nanigoto mo Saiyo ga Kanjin nano de Tasho Senobisuru Kurai ga Choudoyoi',
 3016: 'Ginga Eiyuu Densetsu: Arata Naru Tatakai no Overture',
 227: 'FLCL',
 34438: 'Code Geass: Hangyaku no Lelouch I - Koudou',
 4059: 'Clannad: Mou Hitotsu no Sekai, Tomoyo-hen',
 2563: 'Aria The OVA: Arietta',
 4772: 'Aria The Origination: Sono Choppiri Himitsu no Basho ni...',
 32995: 'Yuri!!! on Ice',
 1023: "Wolf's Rain OVA",
 8063: 'Sekaiichi Hatsukoi OVA',
 33926: 'Quanzhi Gaoshou',
 31490: 'One Piece Film: Gold',
 2448: 'Koukaku Kidoutai: Stand Alone Complex 2nd GIG - Individual Eleven',
 27831: 'Durarara!!x2 Ten',
 36896: 'Boku no Hero Academia the Movie 1: Futari no Hero',
 15039: 'Ano Hi Mita Hana no Namae wo Bokutachi wa Mada Shiranai. Movie',
 1065: 'Touch',
 4053: 'Tennis no Ouji-sama: Zenkoku Taikai-hen - Final',
 20371: 'Sekaiichi Hatsukoi Movie: Yokozawa Takafumi no Baai',
 846: 'School Rumble Ni Gakki',
 36885: 'Saenai Heroine no Sodatekata Fine',
 8740: 'One Piece Film: Strong World Episode 0',
 39592: 'Mobile Suit Gundam: The Origin - Advent of the Red Comet',
 81: 'Mobile Suit Gundam: The 08th MS Team',
 5029: 'Major Movie: Yuujou no Winning Shot',
 16001: 'Kokoro Connect: Michi Random',
 2076: 'Kindaichi Shounen no Jikenbo',
 9656: 'Kimi ni Todoke 2nd Season',
 36963: 'IDOLiSH7 Vibrato',
 23289: 'Gekkan Shoujo Nozaki-kun',
 23199: 'Durarara!!x2 Shou',
 4789: 'ef: A Tale of Melodies.',
 25879: 'Working!!!',
 1943: 'Paprika',
 37675: 'Overlord III',
 7720: 'Ookiku Furikabutte: Natsu no Taikai-hen',
 1453: 'Maison Ikkoku',
 28725: 'Kokoro ga Sakebitagatterunda.',
 6045: 'Kimi ni Todoke',
 2004: 'Hanada Shounen-shi',
 6421: 'Fullmetal Alchemist: Brotherhood Specials',
 31173: 'Akagami no Shirayuki-hime 2nd Season',
 14813: 'Yahari Ore no Seishun Love Comedy wa Machigatteiru.',
 32615: 'Youjo Senki',
 16049: 'Toaru Kagaku no Railgun S',
 35790: 'Tate no Yuusha no Nariagari',
 2150: 'Tanoshii Muumin Ikka',
 535: 'Slayers Next',
 6171: 'Saint Seiya: The Lost Canvas - Meiou Shinwa',
 30015: 'ReLIFE',
 31174: 'Osomatsu-san',
 20507: 'Noragami',
 851: 'Kyou kara Ore wa!!',
 12031: 'Kingdom',
 153: 'Juuni Kokuki',
 9963: 'Detective Conan Movie 15: Quarter of Silence',
 889: 'Black Lagoon',
 21469: 'Stand By Me Doraemon',
 12477: 'Sakasama no Patema',
 14713: 'Kamisama Hajimemashita',
 16: 'Hachimitsu to Clover',
 589: 'Ginga Nagareboshi Gin',
 7465: 'Eve no Jikan (Movie)',
 1363: 'Detective Conan Movie 04: Captured in Her Eyes',
 4901: "Black Lagoon: Roberta's Blood Trail",
 781: 'Detective Conan Movie 03: The Last Wizard of the Century',
 6211: 'Tokyo Magnitude 8.0',
 39231: 'Qiang Shen Ji',
 1486: 'Kodomo no Omocha (TV)',
 3783: 'Kara no Kyoukai 3: Tsuukaku Zanryuu',
 72: 'Full Metal Panic? Fumoffu',
 223: 'Dragon Ball',
 2164: 'Dennou Coil',
 1482: 'D.Gray-man',
 1471: 'City Hunter 2',
 27663: 'Baby Steps 2nd Season',
 4918: 'xxxHOLiC Shunmuki',
 5365: 'Tsumiki no Ie',
 29831: 'Tamayura: Sotsugyou Shashin Part 4 - Ashita',
 1914: 'Saiunkoku Monogatari 2nd Season',
 302: 'Mirai Shounen Conan',
 2034: 'Lovely★Complex',
 237: 'Koukyoushihen Eureka Seven',
 34626: 'Kono Subarashii Sekai ni Shukufuku wo! 2: Kono Subarashii Geijutsu ni Shukufuku wo!',
 33206: 'Kobayashi-san Chi no Maid Dragon',
 36371: 'Ginga Eiyuu Densetsu: Die Neue These - Seiran 3',
 3167: 'Eve no Jikan',
 2759: 'Evangelion: 1.0 You Are (Not) Alone',
 25013: 'Akatsuki no Yona',
 11123: 'Sekaiichi Hatsukoi 2',
 15059: 'Initial D Fifth Stage',
 1974: 'Glass no Kamen (2005)',
 25313: "Gintama': Futon ni Haitte kara Buki Nokoshi ni Kizuite Neru ni Nerenai Toki mo Aru",
 16918: 'Gin no Saji',
 32005: 'Detective Conan Movie 20: The Darkest Nightmare',
 30370: 'Akatsuki no Yona OVA',
 33161: 'Yahari Ore no Seishun Love Comedy wa Machigatteiru. Zoku OVA',
 37430: 'Tensei shitara Slime Datta Ken',
 1257: 'Saint Seiya: Meiou Hades Juuni Kyuu-hen',
 23755: 'Nanatsu no Taizai',
 26117: 'Kokoroya',
 3927: 'Mobile Suit Gundam 00 Second Season',
 2449: 'Koukaku Kidoutai: Stand Alone Complex - The Laughing Man',
 33323: 'Kamisama Hajimemashita: Kamisama, Shiawase ni Naru',
 7791: 'K-On!!',
 12189: 'Hyouka',
 7054: 'Kaichou wa Maid-sama!',
 135: 'Hikaru no Go',
 17739: 'Hidamari Sketch: Sae Hiro Sotsugyou-hen',
 1364: 'Detective Conan Movie 05: Countdown to Heaven',
 34440: 'Code Geass: Hangyaku no Lelouch III - Oudou',
 34437: 'Code Geass: Fukkatsu no Lelouch',
 24277: 'Yowamushi Pedal: Grande Road',
 5681: 'Summer Wars',
 9130: 'Saint Seiya: The Lost Canvas - Meiou Shinwa 2',
 721: 'Princess Tutu',
 15323: 'One Piece: Episode of Nami - Koukaishi no Namida to Nakama no Kizuna',
 14513: 'Magi: The Labyrinth of Magic',
 37514: 'Made in Abyss Movie 1: Tabidachi no Yoake',
 18679: 'Kill la Kill',
 16706: 'Kami nomi zo Shiru Sekai: Megami-hen',
 31051: 'Kuroko no Basket: Saikou no Present Desu',
 3701: 'Kaiba',
 731: 'Interstella5555: The 5tory of The 5ecret 5tar 5ystem',
 186: 'Initial D Second Stage',
 12069: 'Hajime no Ippo: Boxer no Kobushi',
 8425: 'Gosick',
 37989: 'Golden Kamuy 2nd Season',
 27833: 'Durarara!!x2 Ketsu',
 6467: 'Detective Conan Movie 14: The Lost Ship in the Sky',
 1506: 'Detective Conan Movie 10: Requiem of the Detectives',
 2167: 'Clannad',
 2402: 'Ashita no Joe',
 23283: 'Zankyou no Terror',
 1382: 'Yuusha-Ou GaoGaiGar Final',
 28025: 'Tsukimonogatari',
 1430: 'Lupin III: Cagliostro no Shiro',
 31658: 'Kuroko no Basket Movie 4: Last Game',
 1566: 'Koukaku Kidoutai: Stand Alone Complex - Solid State Society',
 239: 'Gankutsuou',
 27821: 'Fate/stay night: Unlimited Blade Works Prologue',
 18689: 'Diamond no Ace',
 21419: 'Detective Conan Movie 18: The Sniper from Another Dimension',
 2025: 'Darker than Black: Kuro no Keiyakusha',
 1367: 'Detective Conan Movie 08: Magician of the Silver Sky',
 38003: 'Bungou Stray Dogs 3rd Season',
 4107: 'Tengen Toppa Gurren Lagann Movie 1: Gurren-hen',
 4938: 'Tsubasa: Shunraiki',
 35838: 'Shoujo Shuumatsu Ryokou',
 1559: 'Shijou Saikyou no Deshi Kenichi',
 38234: 'One Piece Movie 14: Stampede',
 440: 'Shoujo Kakumei Utena',
 21557: 'Omoide no Marnie',
 34577: 'Nanatsu no Taizai: Imashime no Fukkatsu',
 16067: 'Nagi no Asu kara',
 35062: 'Mahoutsukai no Yome',
 8129: 'Kuragehime',
 30831: 'Kono Subarashii Sekai ni Shukufuku wo!',
 16662: 'Kaze Tachinu',
 28071: 'Itsumo Kokoro ni Taiyou wo!',
 18: 'Initial D Fourth Stage',
 38422: 'High Score Girl: Extra Stage',
 9735: 'Gintama: Shinyaku Benizakura-hen',
 3901: 'Baccano! Specials',
 47: 'Akira',
 962: 'Aria The Natural',
 4477: 'Nodame Cantabile: Paris-hen',
 1827: 'Seirei no Moribito',
 6336: 'Mobile Suit Gundam Unicorn',
 2581: 'Mobile Suit Gundam 00',
 16782: 'Kotonoha no Niwa',
 3702: 'Detroit Metal City',
 24833: 'Ansatsu Kyoushitsu',
 34376: 'Yuuki Yuuna wa Yuusha de Aru: Washio Sumi no Shou 3 - Yakusoku',
 34076: 'Uchouten Kazoku 2',
 11597: 'Nisemonogatari',
 4722: 'Skip Beat!',
 19123: 'One Piece: Episode of Merry - Mou Hitori no Nakama no Monogatari',
 17603: 'Mr. Pen Pen',
 1735: 'Naruto: Shippuuden',
 32902: 'Mahoutsukai no Yome: Hoshi Matsu Hito',
 232: 'Cardcaptor Sakura',
 25363: 'Gensei Shugoshin P-hyoro Ikka OVA',
 34537: 'Yoru wa Mijikashi Arukeyo Otome',
 23623: 'Non Non Biyori Repeat',
 6864: 'xxxHOLiC Rou',
 35158: 'Warau Salesman Tokubetsu Bangumi',
 10153: "Mahou Shoujo Lyrical Nanoha: The Movie 2nd A's",
 28223: 'Death Parade',
 37171: 'Asobi Asobase',
 11977: 'Mahou Shoujo Madoka★Magica Movie 1: Hajimari no Monogatari',
 25681: 'Kamisama Hajimemashita◎',
 20899: 'JoJo no Kimyou na Bouken Part 3: Stardust Crusaders',
 265: 'Hajime no Ippo: Mashiba vs. Kimura',
 39533: 'Given',
 37520: 'Dororo',
 38731: 'Diamond no Ace: Act II',
 36946: 'Dragon Ball Super Movie: Broly',
 1519: 'Black Lagoon: The Second Barrage',
 31715: 'Working!!!: Lord of the Takanashi',
 23327: 'Space☆Dandy 2nd Season',
 38249: 'Saiki Kusuo no Ψ-nan: Kanketsu-hen',
 36990: 'Non Non Biyori Movie: Vacation',
 23317: 'Kuroshitsuji: Book of Murder',
 39112: 'Kawaki wo Ameku',
 121: 'Fullmetal Alchemist',
 5460: 'Detective Conan Movie 13: The Raven Chaser',
 17605: 'Mr. Pen Pen II',
 6547: 'Angel Beats!',
 4155: 'One Piece Film: Strong World',
 9890: 'Major: Message',
 35677: 'Liz to Aoi Tori',
 30298: 'Mahou no Princess Minky Momo: Yume wo Dakishimete Specials',
 1604: 'Katekyo Hitman Reborn!',
 22145: 'Kuroshitsuji: Book of Circus',
 39198: 'Kanata no Astra',
 22507: 'Initial D Final Stage',
 138: 'Hunter x Hunter: Greed Island',
 35628: 'Honoo no Alpenrose: Ai no Symphony Ongaku-hen',
 10271: 'Gyakkyou Burai Kaiji: Hakairoku-hen',
 38408: 'Boku no Hero Academia 4th Season',
 12115: 'Berserk: Ougon Jidai-hen III - Kourin',
 9175: 'Tsuruhime Ja!',
 34822: 'Tsuki ga Kirei',
 13759: 'Sakura-sou no Pet na Kanojo',
 12859: 'One Piece Film: Z',
 33051: 'Mobile Suit Gundam: Iron-Blooded Orphans 2nd Season',
 585: 'Mimi wo Sumaseba',
 28675: "Kyoukai no Kanata Movie 2: I'll Be Here - Mirai-hen",
 39570: 'High Score Girl II',
 813: 'Dragon Ball Z',
 10800: 'Chihayafuru',
 32867: 'Bungou Stray Dogs 2nd Season',
 34636: 'Ballroom e Youkoso',
 23847: 'Yahari Ore no Seishun Love Comedy wa Machigatteiru. Zoku',
 3091: 'xxxHOLiC Kei',
 6: 'Trigun',
 2236: 'Toki wo Kakeru Shoujo',
 2559: 'Romeo no Aoi Sora',
 853: 'Ouran Koukou Host Club',
 10937: 'Mobile Suit Gundam: The Origin',
 3226: 'Major S4',
 6811: 'InuYasha: Kanketsu-hen',
 372: 'Cardcaptor Sakura Movie 2: Fuuin Sareta Card',
 7674: 'Bakuman.',
 32188: 'Steins;Gate: Kyoukaimenjou no Missing Link - Divide By Zero',
 9863: 'SKET Dance',
 1033: 'Sennen Joyuu',
 35466: 'ReLIFE: Kanketsu-hen',
 512: 'Majo no Takkyuubin',
 18195: 'Little Busters!: Refrain',
 11771: 'Kuroko no Basket',
 36296: 'Hinamatsuri',
 1889: 'Higurashi no Naku Koro ni Kai',
 22297: 'Fate/stay night: Unlimited Blade Works',
 759: 'Tokyo Godfathers',
 36949: 'Shokugeki no Souma: San no Sara - Tootsuki Ressha-hen',
 36275: 'Natsume Yuujinchou Roku Specials',
 185: 'Initial D First Stage',
 31988: 'Hibike! Euphonium 2',
 3002: 'Gyakkyou Burai Kaiji: Ultimate Survivor',
 6945: 'Gintama: Shiroyasha Koutan',
 6675: 'Redline',
 40080: 'Quanzhi Gaoshou zhi Dianfeng Rongyao',
 5690: 'Nodame Cantabile: Finale',
 11917: 'Major: World Series',
 37515: 'Made in Abyss Movie 2: Hourou Suru Tasogare',
 15227: 'Kono Sekai no Katasumi ni',
 14719: 'JoJo no Kimyou na Bouken (TV)',
 264: 'Hajime no Ippo: Champion Road',
 2966: 'Ookami to Koushinryou',
 1842: 'Major S3',
 139: 'Hunter x Hunter: Greed Island Final',
 21899: 'Gintama: Yorinuki Gintama-san on Theater 2D',
 19363: 'Gin no Saji 2nd Season',
 38680: 'Fruits Basket 1st Season',
 11843: 'Danshi Koukousei no Nichijou',
 36649: 'Banana Fish',
 329: 'Planetes',
 30503: 'Noragami Aragoto',
 30: 'Neon Genesis Evangelion',
 627: 'Major S1',
 43: 'Koukaku Kidoutai',
 9617: 'K-On! Movie',
 4224: 'Toradora!',
 31240: 'Re:Zero kara Hajimeru Isekai Seikatsu',
 19815: 'No Game No Life',
 39621: 'Mahou no LumiTear',
 38993: 'Karakai Jouzu no Takagi-san 2',
 34036: 'Detective Conan: Episode One - The Great Detective Turned Small',
 18617: 'Girls &amp; Panzer Movie',
 32937: 'Kono Subarashii Sekai ni Shukufuku wo! 2',
 137: 'Hunter x Hunter: Yorkshin City Kanketsu-hen',
 25537: "Fate/stay night Movie: Heaven's Feel - I. Presage Flower",
 30346: 'Doukyuusei (Movie)',
 31964: 'Boku no Hero Academia',
 57: 'Beck',
 5081: 'Bakemonogatari',
 37095: 'Violet Evergarden: Kitto "Ai" wo Shiru Hi ga Kuru no Darou',
 12029: 'Uchuu Senkan Yamato 2199',
 2685: 'Tsubasa: Tokyo Revelations',
 2418: 'Stranger: Mukou Hadan',
 35788: 'Shokugeki no Souma: San no Sara',
 40542: 'Saiki Kusuo no Ψ-nan: Shidou-hen',
 37078: 'Quanzhi Gaoshou Specials',
 1210: 'NHK ni Youkoso!',
 34534: 'Natsume Yuujinchou Go Specials',
 31812: 'Kuroshitsuji Movie: Book of the Atlantic',
 513: 'Tenkuu no Shiro Laputa',
 45: 'Rurouni Kenshin: Meiji Kenkaku Romantan',
 1698: 'Nodame Cantabile',
 4081: 'Natsume Yuujinchou',
 7655: 'Major S6',
 18115: 'Magi: The Kingdom of Magic',
 28701: 'Fate/stay night: Unlimited Blade Works 2nd Season',
 1365: 'Detective Conan Movie 06: The Phantom of Baker Street',
 32282: 'Shokugeki no Souma: Ni no Sara',
 5040: 'One Outs',
 20651: 'Natsume Yuujinchou: Itsuka Yuki no Hi ni',
 5420: 'Kemono no Souja Erin',
 30230: 'Diamond no Ace: Second Season',
 25781: 'Shingeki no Kyojin: Kuinaki Sentaku',
 12531: 'Sakamichi no Apollon',
 437: 'Perfect Blue',
 36538: 'Natsume Yuujinchou Movie: Utsusemi ni Musubu',
 11979: 'Mahou Shoujo Madoka★Magica Movie 2: Eien no Monogatari',
 486: 'Kino no Tabi: The Beautiful World',
 17389: 'Kingdom 2nd Season',
 6594: 'Katanagatari',
 32366: 'Gintama°: Aizome Kaori-hen',
 3784: 'Evangelion: 2.0 You Can (Not) Advance',
 10863: 'Steins;Gate: Oukoubakko no Poriomania',
 25835: 'Shirobako',
 34240: 'Shelter',
 5341: 'Ookami to Koushinryou II',
 38450: 'Mo Dao Zu Shi 2',
 37105: 'Grand Blue',
 10087: 'Fate/Zero',
 5: 'Cowboy Bebop: Tengoku no Tobira',
 37055: 'Youjo Senki Movie',
 2246: 'Mononoke',
 13601: 'Psycho-Pass',
 16894: 'Kuroko no Basket 2nd Season',
 28805: 'Bakemono no Ko',
 523: 'Tonari no Totoro',
 13125: 'Shinsekai yori',
 25777: 'Shingeki no Kyojin Season 2',
 35848: 'Promare',
 9756: 'Mahou Shoujo Madoka★Magica',
 9260: 'Kizumonogatari I: Tekketsu-hen',
 30709: 'Kamisama Hajimemashita: Kako-hen',
 37999: 'Kaguya-sama wa Kokurasetai: Tensai-tachi no Renai Zunousen',
 37450: 'Seishun Buta Yarou wa Bunny Girl Senpai no Yume wo Minai',
 5941: 'Cross Game',
 10030: 'Bakuman. 2nd Season',
 31181: 'Owarimonogatari',
 11981: 'Mahou Shoujo Madoka★Magica Movie 3: Hangyaku no Monogatari',
 467: 'Koukaku Kidoutai: Stand Alone Complex',
 14397: 'Chihayafuru 2',
 35557: 'Houseki no Kuni (TV)',
 39195: 'Beastars',
 36259: 'Pingu in the City',
 22789: 'Barakamon',
 2251: 'Baccano!',
 31646: '3-gatsu no Lion',
 5028: 'Major S5',
 572: 'Kaze no Tani no Nausicaä',
 136: 'Hunter x Hunter',
 28171: 'Shokugeki no Souma',
 877: 'Nana',
 24415: 'Kuroko no Basket 3rd Season',
 5205: 'Kara no Kyoukai 7: Satsujin Kousatsu (Kou)',
 392: 'Yuu☆Yuu☆Hakusho',
 10162: 'Usagi Drop',
 38889: 'Kono Oto Tomare! 2nd Season',
 16498: 'Shingeki no Kyojin',
 22535: 'Kiseijuu: Sei no Kakuritsu',
 777: 'Hellsing Ultimate',
 2921: 'Ashita no Joe 2',
 32843: 'Senki Zesshou Symphogear XV',
 35851: 'Sayonara no Asa ni Yakusoku no Hana wo Kazarou',
 33: 'Kenpuu Denki Berserk',
 10408: 'Hotarubi no Mori e',
 35760: 'Shingeki no Kyojin Season 3',
 12431: 'Uchuu Kyoudai',
 37965: 'Kaze ga Tsuyoku Fuiteiru',
 38691: 'Dr. Stone',
 31043: 'Boku dake ga Inai Machi',
 33255: 'Saiki Kusuo no Ψ-nan',
 205: 'Samurai Champloo',
 10165: 'Nichijou',
 7472: 'Gintama Movie 1: Shinyaku Benizakura-hen',
 3297: 'Aria The Origination',
 9989: 'Ano Hi Mita Hana no Namae wo Bokutachi wa Mada Shiranai.',
 33674: 'No Game No Life: Zero',
 32: 'Neon Genesis Evangelion: The End of Evangelion',
 32182: 'Mob Psycho 100',
 35843: 'Gintama.: Porori-hen',
 11577: 'Steins;Gate Movie: Fuka Ryouiki no Déjà vu',
 170: 'Slam Dunk',
 37208: 'Mo Dao Zu Shi',
 21: 'One Piece',
 578: 'Hotaru no Haka',
 30484: 'Steins;Gate 0',
 6114: 'Rainbow: Nisha Rokubou no Shichinin',
 36999: 'Zoku Owarimonogatari',
 38826: 'Tenki no Ko',
 34612: 'Saiki Kusuo no Ψ-nan 2',
 38040: 'Kono Subarashii Sekai ni Shukufuku wo!: Kurenai Densetsu',
 26055: 'JoJo no Kimyou na Bouken Part 3: Stardust Crusaders 2nd Season',
 36456: 'Boku no Hero Academia 3rd Season',
 21329: 'Mushishi: Hihamukage',
 4565: 'Tengen Toppa Gurren Lagann Movie 2: Lagann-hen',
 4282: 'Kara no Kyoukai 5: Mujun Rasen',
 28735: 'Shouwa Genroku Rakugo Shinjuu',
 36098: 'Kimi no Suizou wo Tabetai',
 5300: 'Zoku Natsume Yuujinchou',
 31933: 'JoJo no Kimyou na Bouken Part 4: Diamond wa Kudakenai',
 33486: 'Boku no Hero Academia 2nd Season',
 32983: 'Natsume Yuujinchou Go',
 30654: 'Ansatsu Kyoushitsu 2nd Season',
 12365: 'Bakuman. 3rd Season',
 28957: 'Mushishi Zoku Shou: Suzu no Shizuku',
 7785: 'Yojouhan Shinwa Taikei',
 33352: 'Violet Evergarden',
 35839: 'Sora yori mo Tooi Basho',
 22135: 'Ping Pong the Animation',
 10379: 'Natsume Yuujinchou San',
 19647: 'Hajime no Ippo: Rising',
 20583: 'Haikyuu!!',
 11741: 'Fate/Zero 2nd Season',
 33049: "Fate/stay night Movie: Heaven's Feel - II. Lost Butterfly",
 31757: 'Kizumonogatari II: Nekketsu-hen',
 7311: 'Suzumiya Haruhi no Shoushitsu',
 1535: 'Death Note',
 34591: 'Natsume Yuujinchou Roku',
 37779: 'Yakusoku no Neverland',
 11665: 'Natsume Yuujinchou Shi',
 19: 'Monster',
 5258: 'Hajime no Ippo: New Challenger',
 2001: 'Tengen Toppa Gurren Lagann',
 12355: 'Ookami Kodomo no Ame to Yuki',
 457: 'Mushishi',
 431: 'Howl no Ugoku Shiro',
 245: 'Great Teacher Onizuka',
 21939: 'Mushishi Zoku Shou',
 37991: 'JoJo no Kimyou na Bouken Part 5: Ougon no Kaze',
 38329: 'Seishun Buta Yarou wa Yumemiru Shoujo no Yume wo Minai',
 36838: 'Gintama.: Shirogane no Tamashii-hen',
 44: 'Rurouni Kenshin: Meiji Kenkaku Romantan - Tsuioku-hen',
 24701: 'Mushishi Zoku Shou 2nd Season',
 17074: 'Monogatari Series: Second Season',
 37491: 'Gintama.: Shirogane no Tamashii-hen - Kouhan-sen',
 1575: 'Code Geass: Hangyaku no Lelouch',
 37521: 'Vinland Saga',
 263: 'Hajime no Ippo',
 33095: 'Shouwa Genroku Rakugo Shinjuu: Sukeroku Futatabi-hen',
 164: 'Mononoke Hime',
 1: 'Cowboy Bebop',
 28851: 'Koe no Katachi',
 35180: '3-gatsu no Lion 2nd Season',
 820: 'Ginga Eiyuu Densetsu',
 9969: "Gintama'",
 28977: 'Gintama°',
 38524: 'Shingeki no Kyojin Season 3 Part 2',
 32281: 'Kimi no Na wa.',
 11061: 'Hunter x Hunter (2011)',
 9253: 'Steins;Gate',
 801: 'Koukaku Kidoutai: Stand Alone Complex 2nd GIG',
 24687: 'Mushishi Zoku Shou: Odoro no Michi',
 338: 'Versailles no Bara',
 558: 'Major S2',
 34798: 'Yuru Camp△',
 1142: 'Hachimitsu to Clover II',
 24985: 'Elite Jack!!',
 235: 'Detective Conan (TV)',
 6746: 'Durarara!!',
 31149: 'Persona 3 the Movie 4: Winter of Rebirth',
 861: 'xxxHOLiC',
 18179: 'Yowamushi Pedal',
 34100: 'Fate/kaleid liner Prisma☆Illya Movie: Sekka no Chikai',
 2952: 'Final Fantasy VII: Advent Children Complete',
 3907: 'Ginga Sengoku Gunyuuden Rai',
 32122: 'Gintama°: Umai-mono wa Atomawashi ni Suru to Yokodorisareru kara Yappari Saki ni Kue',
 29095: 'Grisaia no Rakuen',
 849: 'Suzumiya Haruhi no Yuuutsu',
 31765: 'Sword Art Online Movie: Ordinal Scale',
 1096: 'Kidou Keisatsu Patlabor 2 the Movie',
 5485: 'Shin Mazinger Shougeki! Z-hen',
 6154: 'Saint Seiya: Meiou Hades Juuni Kyuu-hen - Yomigaerishi Gold Saint-tachi no Shinwa',
 20159: 'Pokemon: The Origin',
 28881: 'New Initial D Movie: Legend 2 - Tousou',
 19613: 'New Initial D Movie: Legend 1 - Kakusei',
 80: 'Mobile Suit Gundam',
 1910: 'Master Keaton OVA',
 19489: 'Little Witch Academia: Mahoujikake no Parade',
 19703: 'Kyousou Giga (TV)',
 34544: 'Koutetsujou no Kabaneri Movie 3: Unato Kessen',
 5835: 'Hanasakeru Seishounen',
 1824: 'Hadashi no Gen',
 2828: 'Ie Naki Ko',
 35198: 'Free!: Take Your Marks',
 317: 'Final Fantasy VII: Advent Children',
 2761: 'Densetsu Kyojin Ideon: Hatsudou-hen',
 32370: 'D.Gray-man Hallow',
 1818: 'Claymore',
 14741: 'Chuunibyou demo Koi ga Shitai!',
 10218: 'Berserk: Ougon Jidai-hen I - Haou no Tamago',
 37873: 'BanG Dream! Garupa☆Pico',
 33350: 'Zhen Hun Jie',
 16870: 'The Last: Naruto the Movie',
 29830: 'Tamayura: Sotsugyou Shashin Part 3 - Akogare',
 30727: 'Saenai Heroine no Sodatekata ♭',
 6591: 'Rurouni Kenshin DVD-BOX Special Ending',
 36796: 'Owarimonogatari 2nd Season Recaps',
 32547: 'Non Non Biyori Repeat: Hotaru ga Tanoshinda',
 30952: 'New Initial D Movie: Legend 3 - Mugen',
 34914: 'New Game!!',
 93: 'Mobile Suit Gundam SEED',
 5310: 'Macross F Movie 1: Itsuwari no Utahime',
 34021: 'Lupin the IIIrd: Chikemuri no Ishikawa Goemon',
 6115: 'Lupin III vs. Detective Conan',
 18153: 'Kyoukai no Kanata',
 35658: 'Kuroko no Basket: Last Game NG-shuu',
 36593: 'Hug tto! Precure',
 4886: 'InuYasha: Kuroi Tessaiga',
 17895: 'Golden Time',
 6033: 'Dragon Ball Kai',
 1473: "City Hunter '91",
 33354: 'Cardcaptor Sakura: Clear Card-hen',
 9252: 'Break Blade 3: Kyoujin no Kizu',
 8516: 'Baka to Test to Shoukanjuu Ni!',
 1375: 'Watashi no Ashinaga Ojisan',
 12017: 'Tiger &amp; Bunny Movie 2: The Rising',
 2451: 'Space Cobra',
 7724: 'Shiki',
 10083: 'Shiki Specials',
 13203: 'Lupin the Third: Mine Fujiko to Iu Onna',
 1887: 'Lucky☆Star',
 20517: 'Little Busters!: EX',
 3603: 'JoJo no Kimyou na Bouken: Phantom Blood',
 40269: 'Kengan Ashura 2nd Season',
 570: 'Jin-Rou',
 38333: 'Gochuumon wa Usagi Desu ka??: Sing for You',
 35972: 'Fairy Tail: Final Series',
 106: 'Hana yori Dango',
 985: 'Dragon Ball Z Special 2: Zetsubou e no Hankou!! Nokosareta Chousenshi - Gohan to Trunks',
 479: 'Ueki no Housoku',
 407: 'Tantei Gakuen Q',
 29829: 'Tamayura: Sotsugyou Shashin Part 2 - Hibiki',
 534: 'Slayers',
 33502: 'Shuumatsu Nani Shitemasu ka? Isogashii Desu ka? Sukutte Moratte Ii Desu ka?',
 154: 'Shaman King',
 1007: 'Ranma ½ OVA',
 38262: 'Pingu in the City (2018)',
 38201: 'Osomatsu-san Movie',
 38347: 'KisKis! Wode Nanyou Shi Bohe Tang',
 1379: 'Kino no Tabi: The Beautiful World - Nanika wo Suru Tame ni - Life Goes On.',
 516: 'Keroro Gunsou',
 8525: 'Kami nomi zo Shiru Sekai',
 11237: 'Hidamari Sketch x SP',
 25303: 'Haikyuu!!: Lev Genzan!',
 12117: 'Detective Conan Movie 16: The Eleventh Striker',
 6024: "Chi's Sweet Home: Atarashii Ouchi",
 31478: 'Bungou Stray Dogs',
 1520: 'Black Jack',
 1562: 'Yamato Nadeshiko Shichihenge♥',
 8311: 'Tegamibachi Reverse',
 24893: 'Sidonia no Kishi: Daikyuu Wakusei Seneki',
 2104: 'Seto no Hanayome',
 210: 'Ranma ½',
 30240: 'Prison School',
 795: 'Oniisama e...',
 31772: 'One Punch Man Specials',
 31764: 'Nejimaki Seirei Senki: Tenkyou no Alderamin',
 91: 'Mobile Suit Gundam Wing: Endless Waltz',
 30311: 'Kuroko no Basket 3rd Season NG-shuu',
 10357: 'Jinrui wa Suitai Shimashita',
 37029: 'Hoozuki no Reitetsu 2nd Season: Sono Ni',
 20431: 'Hoozuki no Reitetsu',
 28907: 'Gate: Jieitai Kanochi nite, Kaku Tatakaeri',
 30902: 'Yuru Yuri Nachuyachumi!+',
 21867: 'The Disappearance of Conan Edogawa: The Worst Two Days in History',
 7044: 'Zan Sayonara Zetsubou Sensei Bangaichi',
 32551: 'Digimon Adventure tri. 3: Kokuhaku',
 22777: 'Dragon Ball Kai (2014)',
 10119: 'Seitokai Yakuindomo OVA',
 4087: 'Michiko to Hatchin',
 9734: 'K-On!!: Keikaku!',
 14353: 'Death Billiards',
 35608: 'Chuunibyou demo Koi ga Shitai! Movie: Take On Me',
 31704: 'One Punch Man: Road to Hero',
 18245: 'White Album 2',
 23249: 'Uchuu Senkan Yamato 2199: Hoshimeguru Hakobune',
 34902: 'Tsurezure Children',
 36106: 'Shingeki no Kyojin: Lost Girls',
 36702: 'Shingeki no Kyojin Season 2 Movie: Kakusei no Houkou',
 582: 'Sexy Commando Gaiden: Sugoiyo!! Masaru-san',
 517: 'School Rumble: Ichi Gakki Hoshuu',
 5530: 'Pandora Hearts',
 90: 'Mobile Suit Gundam Wing',
 3545: 'Kochira Katsushikaku Kameari Kouenmae Hashutsujo',
 16904: 'K: Missing Kings',
 4192: 'Hayate no Gotoku!!',
 2508: 'Genshiken 2',
 15487: 'Kuroko no Basket NG-shuu',
 6984: 'Hidamari Sketch x 365 Specials',
 644: 'Hachimitsu to Clover Specials',
 120: 'Fruits Basket',
 7305: 'Detective Conan Movie 10: Promo Special',
 2724: 'Daicon Opening Animations',
 2450: 'Crayon Shin-chan Movie 09: Arashi wo Yobu Mouretsu! Otona Teikoku no Gyakushuu',
 34439: 'Code Geass: Hangyaku no Lelouch II - Handou',
 3841: "Chi's Sweet Home",
 38753: 'Araburu Kisetsu no Otome-domo yo.',
 28677: 'Yamada-kun to 7-nin no Majo (TV)',
 13667: 'Naruto: Shippuuden Movie 6 - Road to Ninja',
 1462: 'Memories',
 4454: 'Macross F: Close Encounter - Deculture Edition',
 10460: 'Kimi to Boku.',
 38619: 'Joshikousei no Mudazukai',
 33446: 'Huyao Xiao Hongniang: Yue Hong',
 8479: 'Hetalia World Series',
 37141: 'Hataraku Saibou (TV)',
 19115: 'Giovanni no Shima',
 38671: 'Enen no Shouboutai',
 33032: 'Drifters: Special Edition',
 10534: 'Doraemon Movie 31: Shin Nobita to Tetsujin Heidan - Habatake Tenshi-tachi',
 34430: 'Detective Conan Movie 21: The Crimson Love Letter',
 28479: 'Detective Conan Movie 19: The Hellfire Sunflowers',
 531: 'Bishoujo Senshi Sailor Moon R: The Movie',
 37525: 'Babylon',
 28249: 'Arslan Senki (TV)',
 21995: 'Ao Haru Ride',
 31483: 'Akagami no Shirayuki-hime: Nandemonai Takaramono, Kono Page',
 31783: 'Yowamushi Pedal: New Generation',
 39741: 'Violet Evergarden Gaiden: Eien to Jidou Shuki Ningyou',
 396: 'Seikai no Senki',
 4921: 'Ramayana: The Legend of Prince Rama',
 37442: 'Psycho-Pass: Sinners of the System Case.3 - Onshuu no Kanata ni＿＿',
 1719: 'Rozen Maiden: Ouvertüre',
 37407: 'Penguin Highway',
 12917: 'Madang-eul Naon Amtalg',
 31289: 'One Piece: Episode of Sabo - 3 Kyoudai no Kizuna Kiseki no Saikai to Uketsugareru Ishi',
 10090: 'Koukaku Kidoutai: Stand Alone Complex - Solid State Society 3D',
 21659: 'Kill la Kill Specials',
 15117: 'Kami nomi zo Shiru Sekai: Tenri-hen',
 6904: 'Hellsing: Digest for Freaks',
 28669: 'Go! Princess Precure',
 31859: 'Hai to Gensou no Grimgar',
 30191: 'Durarara!!x2 Shou: Watashi no Kokoro wa Nabe Moyou',
 28121: 'Dungeon ni Deai wo Motomeru no wa Machigatteiru Darou ka',
 38436: 'Doupo Cangqiong 3rd Season',
 38409: 'Cike Wu Liuqi',
 8514: 'Break Blade 2: Ketsubetsu no Michi',
 2753: 'Ushiro no Shoumen Daare',
 32673: 'Udon no Kuni no Kiniro Kemari',
 1000: 'Uchuu Kaizoku Captain Herlock',
 6213: 'Toaru Kagaku no Railgun',
 5074: 'Tetsuwan Birdy Decode:02',
 20847: 'Seitokai Yakuindomo*',
 15959: 'Nurarihyon no Mago OVA',
 1376: 'Ojamajo Doremi Na-i-sho',
 39071: 'Machikado Mazoku',
 25015: "Kyoukai no Kanata Movie 1: I'll Be Here - Kako-hen",
 251: 'Kyou kara Maou!',
 32871: 'Kuroko no Basket Movie 3: Winter Cup - Tobira no Mukou',
 34542: 'Inuyashiki',
 8426: 'Hourou Musuko',
 13117: 'Hakuouki Movie 1: Kyoto Ranbu',
 36028: 'Golden Kamuy',
 14735: 'Detective Conan Movie 17: Private Eye in the Distant Sea',
 21405: 'Bokura wa Minna Kawai-sou',
 13535: 'Binbougami ga!',
 1961: 'Arashi no Yoru ni',
 9074: 'Arakawa Under the Bridge x Bridge',
 36904: 'Aggressive Retsuko (ONA)',
 22265: 'Free!: Eternal Summer',
 2397: 'Digimon Adventure: Bokura no War Game!',
 35798: 'Detective Conan Movie 22: Zero The Enforcer',
 31733: 'Bishoujo Senshi Sailor Moon Crystal Season III',
 7193: 'Aoi Bungaku Series',
 33253: 'Ajin 2nd Season',
 1921: 'Urusei Yatsura Movie 2: Beautiful Dreamer',
 2582: 'Soukou Kihei Votoms',
 21339: 'Psycho-Pass Movie',
 474: 'Macross Plus',
 28069: 'Shigatsu wa Kimi no Uso: Moments',
 2994: 'Death Note: Rewrite',
 1092: 'Mobile Suit Gundam III: Encounters in Space',
 23385: 'Kyoukai no Kanata: Shinonome',
 324: 'Kidou Keisatsu Patlabor: On Television',
 255: 'Jungle wa Itsumo Hare nochi Guu Final',
 27991: 'K: Return of Kings',
 ...}</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=680e25ba">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [33]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">user_anime_dataset</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[33]:</div>
<div class="jp-RenderedHTMLCommon jp-RenderedHTML jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/html" tabindex="0">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>user_id</th>
<th>Yama Hime no Mi</th>
<th>Code Geass: Hangyaku no Lelouch R2</th>
<th>Onegai☆Teacher</th>
<th>Mazinger Z</th>
<th>Tegamibachi Reverse</th>
<th>Nozoki Ana</th>
<th>Soredemo Tsuma wo Aishiteru</th>
<th>Katanagatari</th>
<th>Mushishi: Hihamukage</th>
<th>...</th>
<th>Kyoukai no Kanata: Shinonome</th>
<th>Kuroko no Basket 3rd Season NG-shuu</th>
<th>Juuni Kokuki</th>
<th>Sei Juushi Bismarck</th>
<th>Pupipo!</th>
<th>Lupin III (2015)</th>
<th>Grimm Masterpiece Theater</th>
<th>Kuragehime</th>
<th>Wakaba*Girl</th>
<th>Pokemon Sun &amp; Moon</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>1.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>1</th>
<td>2.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>2</th>
<td>3.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>3</th>
<td>4.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>4</th>
<td>5.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>65119</th>
<td>81721.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>65120</th>
<td>81723.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>65121</th>
<td>81724.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>65122</th>
<td>81725.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<th>65124</th>
<td>81727.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>...</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<p>52429 rows × 4769 columns</p>
</div>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=675d5ba8">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [34]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Testing to ensure these are all displaying "1"</span>
<span class="n">selected_anime_uids</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'33352'</span><span class="p">,</span> <span class="s1">'25013'</span><span class="p">,</span> <span class="s1">'5530'</span><span class="p">,</span> <span class="s1">'33674'</span><span class="p">,</span> <span class="s1">'1482'</span><span class="p">,</span> <span class="s1">'269'</span><span class="p">,</span> <span class="s1">'18245'</span><span class="p">,</span> <span class="s1">'2904'</span><span class="p">,</span> <span class="s1">'27899'</span><span class="p">,</span> <span class="s1">'17074'</span><span class="p">,</span> <span class="s1">'12291'</span><span class="p">,</span> <span class="s1">'226'</span><span class="p">,</span> <span class="s1">'28851'</span><span class="p">,</span> <span class="s1">'8525'</span><span class="p">,</span> <span class="s1">'6594'</span><span class="p">,</span> <span class="s1">'4981'</span><span class="p">,</span> <span class="s1">'1698'</span><span class="p">,</span> <span class="s1">'457'</span><span class="p">,</span> <span class="s1">'235'</span><span class="p">,</span> <span class="s1">'34618'</span><span class="p">]</span>

<span class="c1"># Filter the user_anime_dataset for user_id = 1 and selected anime columns</span>
<span class="n">anime_title_mapping</span> <span class="o">=</span> <span class="n">animes</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">'uid'</span><span class="p">)[</span><span class="s1">'title'</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="n">selected_titles</span> <span class="o">=</span> <span class="p">[</span><span class="n">anime_title_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">uid</span><span class="p">),</span> <span class="sa">f</span><span class="s1">'anime_</span><span class="si">{</span><span class="n">uid</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span> <span class="k">for</span> <span class="n">uid</span> <span class="ow">in</span> <span class="n">selected_anime_uids</span><span class="p">]</span>

<span class="c1"># Step 2: Filter for user_id = 1 and selected columns</span>
<span class="n">selected_row</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">+</span> <span class="n">selected_titles</span><span class="p">]</span>

<span class="c1"># Display the result</span>
<span class="nb">print</span><span class="p">(</span><span class="n">selected_row</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>   user_id  Violet Evergarden  Akatsuki no Yona  Pandora Hearts  \
0      1.0                1.0               1.0             1.0   

   No Game No Life: Zero  D.Gray-man  Bleach  White Album 2  \
0                    1.0         1.0     1.0            1.0   

   Code Geass: Hangyaku no Lelouch R2  Tokyo Ghoul √A  ...  Acchi Kocchi (TV)  \
0                                 1.0             1.0  ...                1.0   

   Elfen Lied  Koe no Katachi  Kami nomi zo Shiru Sekai  Katanagatari  \
0         1.0             1.0                       1.0           1.0   

   Casshern Sins  Nodame Cantabile  Mushishi  Detective Conan (TV)  Blend S  
0            1.0               1.0       1.0                   1.0      1.0  

[1 rows x 21 columns]
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=d42a7f38">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<p>Our dataset was created as intended.</p>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=6704d60e">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [36]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># We will save the generated DataFrame to an external CSV file</span>
<span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">'user_anime_dataset.csv'</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=f562a672">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="For-each-run-after-this,-load-in-the-dataset">For each run after this, load in the dataset<a class="anchor-link" href="#For-each-run-after-this,-load-in-the-dataset">¶</a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=d5bd5889">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [38]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">user_anime_dataset</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'user_anime_dataset.csv'</span><span class="p">)</span>
<span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=25523856">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="Item-to-Item-Collaborative-Filtering">Item-to-Item Collaborative Filtering<a class="anchor-link" href="#Item-to-Item-Collaborative-Filtering">¶</a></h3>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell jp-mod-noOutputs" id="cell-id=4bfea341">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [40]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Create a function to calculate cosine similarity between two items</span>
<span class="k">def</span> <span class="nf">calculate_cosine_similarity</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cosine</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=02b41497">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [41]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Select users who have favorited 'One Punch Man' and 'Haikyuu!!'</span>
<span class="n">selected_users</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[(</span><span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'One Punch Man'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> 
                                    <span class="p">(</span><span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'Haikyuu!!'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span>

<span class="c1"># Extract the columns related to animes (excluding 'user_id')</span>
<span class="n">anime_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">selected_users</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="s1">'user_id'</span><span class="p">]</span>

<span class="c1"># Calculate cosine similarity for each anime with 'One Punch Man' and 'Haikyuu!!'</span>
<span class="n">similarities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">anime_columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">'Similarity'</span><span class="p">])</span>

<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">anime_columns</span><span class="p">:</span>
    <span class="n">vector_1</span> <span class="o">=</span> <span class="n">selected_users</span><span class="p">[</span><span class="s1">'One Punch Man'</span><span class="p">]</span>
    <span class="n">vector_2</span> <span class="o">=</span> <span class="n">selected_users</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
    
    <span class="c1"># Calculate magnitudes</span>
    <span class="n">magnitude_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">vector_1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">magnitude_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">vector_2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span>
    
    <span class="k">if</span> <span class="n">magnitude_1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">magnitude_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Assign NaN or 0 similarity if either vector has zero magnitude</span>
        <span class="n">similarities</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'nan'</span><span class="p">)</span>  <span class="c1"># or 0 if you prefer</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Calculate cosine similarity</span>
        <span class="n">similarity</span> <span class="o">=</span> <span class="n">calculate_cosine_similarity</span><span class="p">(</span><span class="n">vector_1</span><span class="p">,</span> <span class="n">vector_2</span><span class="p">)</span>
        <span class="n">similarities</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">similarity</span>

<span class="c1"># Sort animes by similarity and recommend the top 6</span>
<span class="n">recommendations</span> <span class="o">=</span> <span class="n">similarities</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">'Similarity'</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Display the recommended animes</span>
<span class="nb">print</span><span class="p">(</span><span class="n">recommendations</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>                                 Similarity
Haikyuu!!                               1.0
One Punch Man                           1.0
Fullmetal Alchemist: Brotherhood   0.559017
One Piece                          0.549621
Hunter x Hunter (2011)             0.520416
Steins;Gate                        0.444878
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=ab24590f">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<p>All of these recommended animes fall into similar genres as our selected animes (One Punch Man and Haikyuu!!).</p>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=4a6307b9">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="User-to-User-Collaborative-Filtering">User-to-User Collaborative Filtering<a class="anchor-link" href="#User-to-User-Collaborative-Filtering">¶</a></h3>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=87c2a2a0">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [44]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="c1"># Select user 50</span>
<span class="n">target_user_id</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">target_user</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_user_id</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">'user_id'</span><span class="p">)</span>
<span class="n">target_user_animes</span> <span class="o">=</span> <span class="n">target_user</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">target_user</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

<span class="c1"># Calculate cosine similarity with all users</span>
<span class="n">similarities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Similarity'</span><span class="p">])</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">similarity</span> <span class="o">=</span> <span class="n">calculate_cosine_similarity</span><span class="p">(</span><span class="n">target_user</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">row</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">similarities</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">similarity</span>


<span class="c1"># Filter out the target user from the similarity values</span>
<span class="n">similarities</span> <span class="o">=</span> <span class="n">similarities</span><span class="p">[</span><span class="n">similarities</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">target_user_id</span><span class="p">]</span>

<span class="c1"># Find the most similar user with similarity less than 1 (highest value below 1)</span>
<span class="n">most_similar_user_id</span> <span class="o">=</span> <span class="n">similarities</span><span class="p">[</span><span class="n">similarities</span><span class="p">[</span><span class="s1">'Similarity'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span> <span class="o">=</span> <span class="s1">'Similarity'</span><span class="p">,</span> <span class="n">ascending</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># List recommended animes for user based on the most similar user</span>
<span class="n">recommended_animes</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">user_anime_dataset</span><span class="p">[</span><span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">==</span> <span class="n">most_similar_user_id</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

<span class="c1"># Exclude any animes that the targeted user profile has already listed/favorited</span>
<span class="n">recommended_animes</span> <span class="o">=</span> <span class="p">[</span><span class="n">anime</span> <span class="k">for</span> <span class="n">anime</span> <span class="ow">in</span> <span class="n">recommended_animes</span> <span class="k">if</span> <span class="n">anime</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_user_animes</span><span class="p">]</span>

<span class="c1"># Convert the variable to a string.</span>
<span class="n">recommended_animes</span> <span class="o">=</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">recommended_animes</span><span class="p">))</span>

<span class="c1"># Display the recommended animes</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"The most similar user to user </span><span class="si">{</span><span class="n">target_user_id</span><span class="si">}</span><span class="s2"> is user </span><span class="si">{</span><span class="n">most_similar_user_id</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"We would recommend the following based on their most similar user profile: </span><span class="si">{</span><span class="n">recommended_animes</span><span class="si">}</span><span class="s2">. </span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>The most similar user to user 50 is user 20897.
We would recommend the following based on their most similar user profile: Kenpuu Denki Berserk. 

</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=b614ab22-bb30-417b-9699-34764a92f262">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [45]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">target_user_animes</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child jp-OutputArea-executeResult">
<div class="jp-OutputPrompt jp-OutputArea-prompt">Out[45]:</div>
<div class="jp-RenderedText jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/plain" tabindex="0">
<pre>Index(['Akira', 'Afro Samurai', 'Gunnm', 'Samurai Champloo', 'Cowboy Bebop'], dtype='object')</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=7f92d9c3">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<p>The recommendation system returns the profile with the most similarities to our target user profile (excluding identical listings to the target user's favorited animes) and uses this to recommend the target user with a new show they may enjoy based on their provided preferences.</p>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=b7894e3f">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="Use-a-combination-of-user-item-approach-to-build-a-recommendation-score-for-each-anime-for-each-user">Use a combination of user-item approach to build a recommendation score for each anime for each user<a class="anchor-link" href="#Use-a-combination-of-user-item-approach-to-build-a-recommendation-score-for-each-anime-for-each-user">¶</a></h3>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=e3a6b759">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In [48]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cosine</span>

<span class="c1"># Select target user</span>
<span class="n">target_user_id</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">target_user</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_user_id</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">'user_id'</span><span class="p">)</span>
<span class="n">target_user_animes</span> <span class="o">=</span> <span class="n">target_user</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">target_user</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

<span class="c1"># Calculate cosine similarity with all users</span>
<span class="n">similarities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Similarity'</span><span class="p">])</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">similarity</span> <span class="o">=</span> <span class="n">calculate_cosine_similarity</span><span class="p">(</span><span class="n">target_user</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">row</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">similarities</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">similarity</span>

<span class="c1"># Find the top 5 most similar users</span>
<span class="n">top_5_most_similar</span> <span class="o">=</span> <span class="n">similarities</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span> <span class="o">=</span> <span class="s1">'Similarity'</span><span class="p">,</span> <span class="n">ascending</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Initialize an empty DataFrame for recommendation scores</span>
<span class="n">recommendation_scores</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<span class="c1"># Fill in recommendation scores for each user and anime</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">user_anime_dataset</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_user_id</span><span class="p">:</span>
        <span class="k">continue</span>  <span class="c1"># Skip the target user</span>
    
    <span class="c1"># Calculate recommendation score using a combination of user and item approach</span>
    <span class="n">recommendation_scores</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">similarities</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">],</span> <span class="s1">'Similarity'</span><span class="p">]</span>

<span class="c1"># Sum recommendation scores across similar users for each anime</span>
<span class="n">anime_recommendation_scores</span> <span class="o">=</span> <span class="n">recommendation_scores</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Exclude animes that the target user has already seen</span>
<span class="n">anime_recommendation_scores</span> <span class="o">=</span> <span class="n">anime_recommendation_scores</span><span class="p">[</span><span class="n">anime_recommendation_scores</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">target_user_animes</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">]</span>

<span class="c1"># Sort and get the top 10 recommended animes</span>
<span class="n">top_10_recommendations</span> <span class="o">=</span> <span class="n">anime_recommendation_scores</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># Convert the variable to a string</span>
<span class="n">top_10_recommendations_str</span> <span class="o">=</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">top_10_recommendations</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

<span class="c1"># Display the top 5 most similar users and top 10 recommended animes</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"The top 5 most similar users to user </span><span class="si">{</span><span class="n">target_user_id</span><span class="si">}</span><span class="s2"> are </span><span class="si">{</span><span class="n">top_5_most_similar</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"We would recommend the following based on a combination of user-item approach: </span><span class="si">{</span><span class="n">top_10_recommendations_str</span><span class="si">}</span><span class="s2">. </span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>The top 5 most similar users to user 50 are       Similarity
50           1.0
39475        1.0
33833        1.0
20897    0.67082
2243    0.632456.
We would recommend the following based on a combination of user-item approach: Fullmetal Alchemist: Brotherhood, Neon Genesis Evangelion, Steins;Gate, Tengen Toppa Gurren Lagann, Hunter x Hunter (2011), Death Note, FLCL, Mushishi, Code Geass: Hangyaku no Lelouch, Baccano!. 

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=d48d2b41">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h3 id="Analysis">Analysis<a class="anchor-link" href="#Analysis">¶</a></h3>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=54aad307">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<p>Our target profile's favorited animes were:</p>
<ul>
<li>Akira</li>
<li>Afro Samurai</li>
<li>Gunnm</li>
<li>Samurai Champloo</li>
<li>Cowboy Bebop</li>
</ul>
<p>Our model returned the following set of recommendations.</p>
<ul>
<li>Fullmetal Alchemist: Brotherhood</li>
<li>Neon Genesis Evangelion</li>
<li>Steins;Gate</li>
<li>Tengen Toppa Gurren Lagann</li>
<li>Hunter x Hunter (2011)</li>
<li>Death Note</li>
<li>FLCL</li>
<li>Mushishi</li>
<li>Code Geass: Hangyaku no Lelouch</li>
<li>Baccano!</li>
</ul>
<p>Comments:</p>
<ul>
<li>Overall, our model does well in providing similar recommendations to the user based on what they have favorited.</li>
<li>We see that the model's recommendations trend towards action-adventure animes, noting that the first half of the list falls under this category.</li>
<li>There is mix of supernatural and thriller animes (Death Note, Baccano, etc.) that are likely off-branches from Akira's thematics.</li>
</ul>
</div>
</div>
</div>
</div>
</main>
</body>
</html>
